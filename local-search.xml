<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>蓝桥杯（1）</title>
    <link href="/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%881%EF%BC%89-1/"/>
    <url>/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%881%EF%BC%89-1/</url>
    
    <content type="html"><![CDATA[<h1>蓝桥杯（1）</h1><p>写在前面：去年裸考，想着今年好好准备一下，这几周天天被OS和OO折磨，一直拖到现在。看了一下往年题，填空题只要时间复杂度不是特别离谱，直接暴力模拟就行，编程题我主要总结一下常考的算法，由于现在还没上过算法课，好多东西也都不会，写这篇博客就当边学习边总结了。</p><h3 id="最短路径-Floyd算法和Dijkstra算法">最短路径 Floyd算法和Dijkstra算法</h3><img src="/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%881%EF%BC%89-1/path.jpg" class><p>Dijkstra主要用于求两点最短距离和最短路径，而且只能求出一条最短路径。</p><ul><li>首先初始化，我们用edge [2022] [2022]二维数组存储边的权值，本题中无边则权值为一个较大数；定义dis[2022]存储第一个点到各个点的最短距离，初始化为edge[1]；haveFind [2022] 记录是否找到从1到i的最短路径；path[2022]记录从1到此点的前一点</li><li>遍历dis从当前尚未找到最短路径的点中找到最小值，记此点为index，更新haveFind[index] = 1。</li><li>以flag为中间点，遍历如果(dis[index] + edge [index] [i] &lt;= dis[i])那么记dis[i] = dis[index] + edge [index] [i], 并且更新前继节点path[i] = index</li><li>直到index为路径终点结束循环</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> edge[<span class="hljs-number">2022</span>][<span class="hljs-number">2022</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">if</span> (a &lt; b) &#123;<br><span class="hljs-type">int</span> c = a;<br>a = b;<br>b = c;<br>&#125;<br><span class="hljs-keyword">return</span> (b == <span class="hljs-number">0</span>) ? a : gcd(b, a % b);<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> dis[<span class="hljs-number">2022</span>];       <span class="hljs-comment">// 存储着1到各个点最小距离</span><br><span class="hljs-type">int</span> haveFind[<span class="hljs-number">2022</span>];       <span class="hljs-comment">//如果找到了1到某个点的最小距离则该点记为1</span><br><span class="hljs-type">int</span> path[<span class="hljs-number">2022</span>];        <span class="hljs-comment">//比如path[2] = 3,那么改最短路径的前继节点为3</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> flag)</span> &#123;    <span class="hljs-comment">//打印路径</span><br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> lastFlag = path[flag];<br>printPath(lastFlag);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-%d&quot;</span>, flag);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;        <span class="hljs-comment">//初始化edge  </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2021</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(i - j) &gt; <span class="hljs-number">21</span>) &#123;<br>edge[i][j] = edge[j][i] = <span class="hljs-number">1145140000</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j) &#123;<br>edge[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>edge[i][j] = edge[j][i] = i * j / gcd(i, j);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;          <span class="hljs-comment">//初始化dis</span><br>dis[i] = edge[<span class="hljs-number">1</span>][i];<br>&#125;<br><span class="hljs-type">int</span> nowNode = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (nowNode != <span class="hljs-number">2021</span>) &#123;<br><span class="hljs-type">int</span> minDis = <span class="hljs-number">1145140000</span>;<br><span class="hljs-type">int</span> index = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (haveFind[i] != <span class="hljs-number">1</span> &amp;&amp; dis[i] &lt;= minDis) &#123;<br>minDis = dis[i];<br>index = i;<br>&#125;<br>&#125;<br>nowNode = index;<br>haveFind[index] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (haveFind[i] != <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (dis[index] + edge[index][i] &lt;= dis[i]) &#123;<br>dis[i] = dis[index] + edge[index][i];<br>path[i] = index;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, dis[<span class="hljs-number">2021</span>]);<br>printPath(<span class="hljs-number">2021</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Floyd算法更加暴力，可以求任意两点最短距离和路径</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> edge[<span class="hljs-number">2022</span>][<span class="hljs-number">2022</span>];<br><span class="hljs-type">int</span> path[<span class="hljs-number">2022</span>][<span class="hljs-number">2022</span>];<br><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">if</span> (a &lt; b) &#123;<br><span class="hljs-type">int</span> c = a;<br>a = b;<br>b = c;<br>&#125;<br><span class="hljs-keyword">return</span> (b == <span class="hljs-number">0</span>) ? a : gcd(b, a % b);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2021</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(i - j) &gt; <span class="hljs-number">21</span>) &#123;<br>edge[i][j] = edge[j][i] = <span class="hljs-number">1145140000</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j) &#123;<br>edge[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>edge[i][j] = edge[j][i] = i * j / gcd(i, j);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2021</span>; j++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">2021</span>; k++) &#123;<br><span class="hljs-keyword">if</span> (edge[j][i] + edge[i][k] &lt;= edge[j][k]) &#123;<br>edge[j][k] = edge[j][i] + edge[i][k];<br>path[j][k] = path[k][j] = i;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, edge[<span class="hljs-number">1</span>][<span class="hljs-number">2021</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DFS深度搜索">DFS深度搜索</h3><h4 id="例题一">例题一</h4><img src="/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%881%EF%BC%89-1/tree.jpg" class><p>其中N&lt;=100000</p><p>题中认为子节点是无序的，因此才有得到的二叉树不同，例如2放到左边和右边</p><pre><code class=" mermaid">graph TBsubgraph 二叉树2 left1a((1))1a--&gt;2a((2))2a--&gt;5a((5))2a--&gt;3a((3))3a--&gt;4a((4))endsubgraph 多叉树2 left1((1))1--&gt;2((2))1--&gt;3((3))1--&gt;4((4))2--&gt;5((5))endsubgraph 二叉树2 right1d((1))1d--&gt;3d((3))3d--&gt;4d((4))4d--&gt;2d((2))2d--&gt;5d((5))endsubgraph 多叉树2 right1b((1))1b--&gt;3b((3))1b--&gt;4b((4))1b--&gt;2b((2))2b--&gt;5b((5))end</code></pre><p>得到规律，在第二层中，如题中共有2,3,4三个子节点，只要让贡献高度最大的即2排在最右边，此时第二层子节点值为3（子节点个数）+1（第二层子节点各自下一层子节点的最大值）。我们用vector的二维数组，其中tree[i]  中存放着以i节点为父节点的节点标号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 1e6+5</span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; tree[(<span class="hljs-type">int</span>)maxn];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> &#123;<br><span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tree[node].size(); i++) &#123;<br><span class="hljs-type">int</span> value = dfs(tree[node][i]);<br>max = (max &lt; value) ? value : max;<br>&#125;<br><span class="hljs-keyword">return</span> max + tree[node].size();<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> n;<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-type">int</span> j;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;j);<br>tree[j].push_back(i);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dfs(<span class="hljs-number">1</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例题二-受伤的皇后">例题二 受伤的皇后</h4><p>有一个 n×n 的国际象棋棋盘（n 行 n 列的方格图），请在棋盘中摆放 n 个受伤的国际象棋皇后，要求：</p><p>任何两个皇后不在同一行。<br>任何两个皇后不在同一列。<br>如果两个皇后在同一条 45 度角的斜线上，这两个皇后之间行号的差值至少为 3 。<br>请问一共有多少种摆放方案。</p><p>输入描述<br>输入的第一行包含一个整数 n。</p><p>其中，1≤n≤10。</p><p>输出描述<br>输出一个整数，表示答案。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> line[<span class="hljs-number">15</span>]; <span class="hljs-comment">//代表某一行在第几列</span><br><span class="hljs-type">int</span> row[<span class="hljs-number">15</span>];  <span class="hljs-comment">// row[i] 代表第i列是否被放置</span><br><span class="hljs-type">int</span> n, sum;<br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> deep)</span> &#123;      <span class="hljs-comment">//deep 代表当前在存第几行</span><br><span class="hljs-keyword">if</span> (deep == n+<span class="hljs-number">1</span>) &#123;<br>sum++;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (row[i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;      <span class="hljs-comment">//第i列已经被放置了</span><br><span class="hljs-keyword">if</span> ((deep &gt;= <span class="hljs-number">2</span> &amp;&amp; line[deep - <span class="hljs-number">1</span>] == i + <span class="hljs-number">1</span>) || (deep &gt;= <span class="hljs-number">3</span> &amp;&amp; line[deep - <span class="hljs-number">2</span>] == i + <span class="hljs-number">2</span>))<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 看一看副对角线（斜率为1的对角线）是否符合条件</span><br><span class="hljs-keyword">if</span> ((deep &gt;= <span class="hljs-number">2</span> &amp;&amp; i &gt;= <span class="hljs-number">2</span> &amp;&amp; line[deep - <span class="hljs-number">1</span>] == i - <span class="hljs-number">1</span>) || (deep &gt;= <span class="hljs-number">3</span> &amp;&amp; i &gt;= <span class="hljs-number">3</span> &amp;&amp; line[deep - <span class="hljs-number">2</span>] == i - <span class="hljs-number">2</span>))<span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 看一看主对角线（斜率为-1的对角线）是否符合条件</span><br>row[i] = <span class="hljs-number">1</span>;    <span class="hljs-comment">//deep行存储到第i列</span><br>line[deep] = i;<br>dfs(deep + <span class="hljs-number">1</span>);<br>row[i] = <span class="hljs-number">0</span>;     <span class="hljs-comment">//还原</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>dfs(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OS-lab1</title>
    <link href="/2023/03/20/OSlab1/"/>
    <url>/2023/03/20/OSlab1/</url>
    
    <content type="html"><![CDATA[<hr><h1>上机</h1><h2 id="1-lab1-exam：">1.lab1-exam：</h2><p>​      在lab1课下分支的基础上，扩展printk函数，增加新的格式字符串&quot;%[flags] [width] [length]R&quot;,从参数表中得到两个参数，两个参数当做“%[flags] [width] [length]d”输出，具体输出形式为&quot;(参数1,参数2)“。例如printk(”%4R&quot;, 2023, 2023); 输出为&quot;(2023,2023)&quot;。只需要switch代码段增加一个case即可，类似两个case：d。<strong>记着输出完第一个参数，要把neg_flag归0。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br>        <span class="hljs-keyword">if</span>(long_flag) &#123;<br>                               num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);          \\第一个参数<br>       nun = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);                      \\第二个参数，记得声明 <span class="hljs-type">long</span> nun<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>                               num = va_arg(ap, <span class="hljs-type">int</span>);<br>       nun = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>                        <span class="hljs-keyword">if</span>(num &lt;<span class="hljs-number">0</span>)&#123;<br>                                 num = -num;<br> neg_flag = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">char</span> kuo1[] = <span class="hljs-string">&quot;(\0&quot;</span>;<br><span class="hljs-type">char</span> kuo2[] = <span class="hljs-string">&quot;)\0&quot;</span>;<br><span class="hljs-type">char</span> dou[] = <span class="hljs-string">&quot;,\0&quot;</span>;<br>                        out(data, kuo1, <span class="hljs-number">1</span>);        <br>print_num(out, data, num, <span class="hljs-number">10</span>, neg_flag,width,ladjust,padc,<span class="hljs-number">0</span>);<br>out(data, dou, <span class="hljs-number">1</span>);<br>neg_flag = <span class="hljs-number">0</span>;            <span class="hljs-comment">//输出完第一个参数，记得初始neg_flag</span><br><span class="hljs-keyword">if</span>(nun &lt;<span class="hljs-number">0</span>)&#123;<br>                              nun = -nun;<br>      neg_flag = <span class="hljs-number">1</span>;<br>&#125;<br>print_num(out, data, nun, <span class="hljs-number">10</span>, neg_flag,width,ladjust,padc,<span class="hljs-number">0</span>);<br>out(data, kuo2, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><h2 id="2-la1-extra">2.la1-extra</h2><p>​         我们在lab1课下实现的printk是把格式字符串输出到终端，extra的目标是实现sprintf函数，把要输出的内容弄到缓冲区（就是到目标字符串buf），printk的原理为：调用vptintfmt解析fmt，真正的输出是把outputk函数（在vprintfmt传入output函数作为一个参数）。注意到vprintfmt第二个参数为NULL，在声明的时候第二个形参为void * data。第一个参数函数称为回调函数，第二个参数称为回调上下文，在printk并没有用到data。我们可以借助vprintfmt函数，第一个参数传入自定义的函数，第二个参数传入buf（当前缓冲区所在的位置）。我们要实现的自定义函数就是类似的outputk，只不过功能不是输出，而是把写入到当前缓冲区的位置，这时候你突然发现当前文件下memcpy函数已经实现了！！！为了可以一直更新data，我们只需要在所有需要缓冲的地方让data加上缓冲的字符串长度。还有一个小问题是，由于在vprintfmt函数中还调用了print_str, print_char, print_num在这三个函数中，为了把更新后的data传回vprintfmt，我把这三个函数的类型改为void*，然后返回值为更新后的data。<strong>需要注意在vprintfmt对data更新的时候，要先判断data是不是NULL，因为printk也会调用vprintfmt，但传入的data为NULL。其实要写的东西不多，仔细一点就好</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * fmt, ...)</span>&#123;<br>     <span class="hljs-type">void</span> *start = buf;<br>      va_list ap;<br>      va_start(ap, fmt);<br>      vprintfmt(memcpy2, buf, fmt,ap );<br>      va_end(ap);<br>      <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <br>     <span class="hljs-keyword">while</span>(*(<span class="hljs-type">char</span> *)start!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;        <br>           i++;<br>   start++;<br>     &#125;<br> <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n)</span> &#123;<br><span class="hljs-type">void</span> *dstaddr = dst;<br><span class="hljs-type">void</span> *max = dst + n;<br><br><span class="hljs-keyword">if</span> (((u_long)src &amp; <span class="hljs-number">3</span>) != ((u_long)dst &amp; <span class="hljs-number">3</span>)) &#123;<br><span class="hljs-keyword">while</span> (dst &lt; max) &#123;<br>*(<span class="hljs-type">char</span> *)dst++ = *(<span class="hljs-type">char</span> *)src++;<br>&#125;<br><span class="hljs-keyword">return</span> dstaddr;<br>&#125;<br><br><span class="hljs-keyword">while</span> (((u_long)dst &amp; <span class="hljs-number">3</span>) &amp;&amp; dst &lt; max) &#123;<br>*(<span class="hljs-type">char</span> *)dst++ = *(<span class="hljs-type">char</span> *)src++;<br>&#125;<br><br><span class="hljs-comment">// copy machine words while possible</span><br><span class="hljs-keyword">while</span> (dst + <span class="hljs-number">4</span> &lt;= max) &#123;<br>*(<span class="hljs-type">uint32_t</span> *)dst = *(<span class="hljs-type">uint32_t</span> *)src;<br>dst += <span class="hljs-number">4</span>;<br>src += <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-comment">// finish the remaining 0-3 bytes</span><br><span class="hljs-keyword">while</span> (dst &lt; max) &#123;<br>*(<span class="hljs-type">char</span> *)dst++ = *(<span class="hljs-type">char</span> *)src++;<br>&#125;<br><span class="hljs-keyword">return</span> dstaddr;<br>&#125;<br><br><br><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vprintfmt</span><span class="hljs-params">(<span class="hljs-type">fmt_callback_t</span> out, <span class="hljs-type">void</span> *data, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, va_list ap)</span> &#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *s;<br><span class="hljs-type">long</span> num;<br><br><span class="hljs-type">int</span> width;<br><span class="hljs-type">int</span> long_flag; <span class="hljs-comment">// output is long (rather than int)</span><br><span class="hljs-type">int</span> neg_flag;  <span class="hljs-comment">// output is negative</span><br><span class="hljs-type">int</span> ladjust;   <span class="hljs-comment">// output is left-aligned</span><br><span class="hljs-type">char</span> padc;     <span class="hljs-comment">// padding char</span><br><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-comment">/* scan for the next &#x27;%&#x27; */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (1/8) */</span><br>        <span class="hljs-keyword">while</span>(*fmt!=<span class="hljs-string">&#x27;%&#x27;</span>&amp;&amp;*fmt!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>out(data,fmt,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(data!=<span class="hljs-literal">NULL</span>)&#123;<br>data++;<br>&#125;<br>fmt++;<br>&#125;<br><span class="hljs-comment">/* flush the string found so far */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (2/8) */</span><br><br><span class="hljs-comment">/* check &quot;are we hitting the end?&quot; */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (3/8) */</span><br>        <span class="hljs-keyword">if</span>(*fmt == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br><span class="hljs-keyword">if</span>(data!=<span class="hljs-literal">NULL</span>)&#123;<br>                      *(<span class="hljs-type">char</span> *)data = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <br>&#125;<br><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">/* we found a &#x27;%&#x27; */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (4/8) */</span><br>fmt++;<br>ladjust = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(*fmt == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            ladjust = <span class="hljs-number">1</span>;<br>fmt++;<br>&#125;<br><span class="hljs-comment">/* check format flag */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (5/8) */</span><br>padc = <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">if</span> (*fmt == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            padc = <span class="hljs-string">&#x27;0&#x27;</span>;<br>fmt++;<br>&#125;<br><span class="hljs-comment">/* get width */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (6/8) */</span><br>width = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(isDigit(*fmt))&#123;<br>            width *= <span class="hljs-number">10</span>;<br>width += cToD(*fmt);<br>fmt++;<br>&#125;<br><br><span class="hljs-comment">/* check for long */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (7/8) */</span><br>long_flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(*fmt == <span class="hljs-string">&#x27;l&#x27;</span>)&#123;<br>long_flag = <span class="hljs-number">1</span>;<br>fmt++;<br>&#125;<br><br>neg_flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">switch</span> (*fmt) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>            <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">0</span>)&#123;<br>num = -num;<br>neg_flag = <span class="hljs-number">1</span>;<br>&#125;<br>data =print_num(out,data,num,<span class="hljs-number">10</span>,neg_flag,width,ladjust,padc,<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Refer to other parts (case &#x27;b&#x27;, case &#x27;o&#x27;, etc.) and func &#x27;print_num&#x27; to</span><br><span class="hljs-comment"> * complete this part. Think the differences between case &#x27;d&#x27; and the</span><br><span class="hljs-comment"> * others. (hint: &#x27;neg_flag&#x27;).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (8/8) */</span><br><br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;O&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;U&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>c = (<span class="hljs-type">char</span>)va_arg(ap, <span class="hljs-type">int</span>);<br>data = print_char(out, data, c, width, ladjust);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>s = (<span class="hljs-type">char</span> *)va_arg(ap, <span class="hljs-type">char</span> *);<br>data =  print_str(out, data, s, width, ladjust);<br><span class="hljs-keyword">break</span>;<br>  <br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\0&#x27;</span>:<br>fmt--;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">/* output this char as it is */</span><br>out(data, fmt, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(data!=<span class="hljs-literal">NULL</span>)&#123;<br>                                data++;<br>&#125;<br>&#125;<br>fmt++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>lab1思考题</h1><hr><h2 id="一、Thinking">一、Thinking</h2><h3 id="thinking1-1">thinking1.1</h3><p>​        x86交叉编译链：解决编译链程序和目标程序运行环境不同的问题，如在x86环境上使用编译工具进行编译汇编链接，而生成的程序需要运行在ARM开发板上</p><p>​         readelf：显示可执行程序的elf文件信息</p><p>​         objdump：显示程序信息，函数汇编等，常用于调试</p><p>​                              objdump -h **.o 可查看目标文件的结构和内容<br>​                              objdump -S      反汇编  -d可以16进制显示</p><p>​         LD（link script）：主要是用来描述输入文件中的节（section）是如何映射到输出文件的，并且控制输出文件的内存布局（memory layout）；源代码会编译成为目标对象文件（object file），每个对象文件中包含一系列的段（section），为LD的输入文件。</p><h3 id="thinking1-2">thinking1.2</h3><img src="/2023/03/20/OSlab1/2.0.png" class><p>发现在编译hello和readelf时的编译选项并不同</p><img src="/2023/03/20/OSlab1/2.1.png" class><img src="/2023/03/20/OSlab1/2.2.png" class><p>1.static：使用自带的readelf工具发现readelf文件类型为 DYN(Position-Independent Executable file),地址独立可执行文件，这是linux的一种保护方式，可以使程序在任意地址装载。hello则为简单的可执行文件，地址固定。</p><p>2.-32m：在我们的环境中，32位的程序运行的速度会更快，加上-32m选项，编译链接生成32位可执行程序，但是我们自己的readelf只能读64位。但是x86自带交叉编译工具readelf则可以读32位。</p><h3 id="thinking1-3">thinking1.3</h3><p>启动分为两过程，硬件启动和软件启动，硬件启动的入口地址是由硬件决定的，之后才是我们内核也即软件启动，将ELF加载到内存中，此时内核入口由我们自定义的链接器决定。两个入口的含义是不一样的。</p><hr><h2 id="二、实验难点">二、实验难点</h2><h3 id="1-理解我们内核镜像的结构">1.理解我们内核镜像的结构</h3><img src="/2023/03/20/OSlab1/3.1.png" class><p>我们的开始是在stage2初始化CPU和内核栈，之后便调到init中的mips_init 函数用于初始化内核，我们在lab1中完成的仅仅是打印</p><h3 id="2-readelf的补充">2.readelf的补充</h3><p>由ELF的文件地址计算节头表的地址时需要用 binary(const void *)如果用ehdr，ehdr + off，得到的是ehdr偏移ehdr大小的地址</p><h3 id="3-源码的阅读">3.源码的阅读</h3><hr><h2 id="三、实验感想">三、实验感想</h2><h4 id="1-我们现在的mos非常简单，操作系统也非常抽象，在之后的实验中，必须要多读源码，在理解的基础上逐步实现我们的mos">1.我们现在的mos非常简单，操作系统也非常抽象，在之后的实验中，必须要多读源码，在理解的基础上逐步实现我们的mos</h4><h4 id="2-对于mos的makefile并不太熟悉，课下要多下功夫，多读源码。实验的整体难度尚可。">2.对于mos的makefile并不太熟悉，课下要多下功夫，多读源码。实验的整体难度尚可。</h4>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>lab1</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-lab0</title>
    <link href="/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<hr><h1>实验报告</h1><h2 id="lab0思考题">lab0思考题</h2><h3 id="thinking0-1">thinking0.1</h3><pre><code class="hljs">不一样，在新建README.txt时候，处于Untracked状态，文件第二行显示&quot;Untracked files&quot;。当add 追踪再修改处于已修改状态,Modified.txt显示&quot;Changes not staged for commit&quot;，此时使用add命令进入Stage区。这两次add的功能并不相同，第一次是追踪，第二次是提交修改。</code></pre><h3 id="thinking0-2">thinking0.2</h3><img src="/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/Git.png" class><pre><code class="hljs">Add the file --&gt; git addStage the file --&gt; git addcommit --&gt; git commit</code></pre><h3 id="thinking0-3">thinking0.3</h3><pre><code class="hljs">1.git checkout -- print.c2.git reset HEAD print.c3.git rm --cached print.c</code></pre><h3 id="thinking0-4">thinking0.4</h3><img src="/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/thinking0.4.png" class><pre><code class="hljs">3 hashcode:d5b5d0e2008b045060fc390388ed88519e3378572 hashcode:3afeaf4e09d5ebb5a811f24dfd9e8357b47d021b1 hashcode:8e72b92edb7dd5370ab5ce48d270a9a32ebf78aagit reset --hard HEAD^ 显示当前在版本2git reset --hard 8e72b92edb7dd5370ab5ce48d270a9a32ebf78aa显示在版本1git reset --hard d5b5d0e2008b045060fc390388ed88519e337857又返回到版本3</code></pre><h3 id="thinking0-5">thinking0.5</h3><pre><code class="hljs">echo first直接在shell输出firstecho second &gt; output.txt 将second输出到output中，若文件已存在并替换原来的内容echo third &gt; output.txt 同理，output中只有thirdecho forth &gt;&gt; output.txt 将forth写到output原有内容之后，此时文件中显示thirdforth</code></pre><h3 id="thinking0-6">thinking0.6</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>：<br> 1 <span class="hljs-built_in">echo</span> Shell Start<br>  2 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> a = 1<br>  3 a=1<br>  4 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> b = 2<br>  5 b=2<br>  6 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> c = a+b<br>  7 c=$[<span class="hljs-variable">$a</span>+<span class="hljs-variable">$b</span>]<br>  8 <span class="hljs-built_in">echo</span> c = <span class="hljs-variable">$c</span><br>  9 <span class="hljs-built_in">echo</span> save c to ./file1<br> 10 <span class="hljs-built_in">echo</span> <span class="hljs-variable">$c</span>&gt;file1<br> 11 <span class="hljs-built_in">echo</span> save b to ./file2<br> 12 <span class="hljs-built_in">echo</span> <span class="hljs-variable">$b</span>&gt;file2<br> 13 <span class="hljs-built_in">echo</span> save a to ./file3<br> 14 <span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span>&gt;file3<br> 15 <span class="hljs-built_in">echo</span> save file1 file2 file3 to file4<br> 16 <span class="hljs-built_in">cat</span> file1&gt;file4<br> 17 <span class="hljs-built_in">cat</span> file2&gt;&gt;file4<br> 18 <span class="hljs-built_in">cat</span> file3&gt;&gt;file4<br> 19 <span class="hljs-built_in">echo</span> save file4 to ./result<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span>：<br>  1 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> Shell Start &gt; <span class="hljs-built_in">test</span><br>  2 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> a = 1 &gt;&gt; <span class="hljs-built_in">test</span><br>  3 <span class="hljs-built_in">echo</span> a=1 &gt;&gt; <span class="hljs-built_in">test</span><br>  4 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> b = 2 &gt;&gt; <span class="hljs-built_in">test</span><br>  5 <span class="hljs-built_in">echo</span> b=2 &gt;&gt; <span class="hljs-built_in">test</span><br>  6 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> c = a+b &gt;&gt;<span class="hljs-built_in">test</span><br>  7 <span class="hljs-built_in">echo</span> c=<span class="hljs-string">&#x27;$[$a+$b]&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br>  8 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> c = <span class="hljs-string">&#x27;$c&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br>  9 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save c to ./file1 &gt;&gt; <span class="hljs-built_in">test</span><br> 10 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$c&gt;&#x27;</span>file1 &gt;&gt;<span class="hljs-built_in">test</span><br> 11 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save b to ./file2 &gt;&gt; <span class="hljs-built_in">test</span><br> 12 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$b&gt;&#x27;</span>file2 &gt;&gt;<span class="hljs-built_in">test</span><br> 13 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save a to ./file3 &gt;&gt; <span class="hljs-built_in">test</span><br> 14 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$a&gt;&#x27;</span>file3 &gt;&gt;<span class="hljs-built_in">test</span><br> 15 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save file1 file2 file3 to file4 &gt;&gt; <span class="hljs-built_in">test</span><br> 16 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">cat</span> file1<span class="hljs-string">&#x27;&gt;&#x27;</span>file4  &gt;&gt; <span class="hljs-built_in">test</span><br> 17 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">cat</span> file2<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>file4 &gt;&gt; <span class="hljs-built_in">test</span><br> 18 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">cat</span> file3<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>file4 &gt;&gt;<span class="hljs-built_in">test</span><br> 19 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save file4 to ./result &gt;&gt;<span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><hr><h2 id="难点分析">难点分析</h2><h3 id="Exercise0-1">Exercise0.1</h3><pre><code class="hljs">sed -n（安静模式）即只输出经过sed修改后的内容</code></pre><h3 id="Exercise0-2">Exercise0.2</h3><pre><code class="hljs">在bash可执行文件中，熟悉文法结构，每一条都是命令，所以if while中的参数也是命令，-ne，-eq等命令，且须注意在关系成立时返回0，与常规语言不同。</code></pre><h3 id="Exercise0-3">Exercise0.3</h3><pre><code class="hljs">使用grep和awk指令结合使用，可以使用创建中间文件然后再删除，也可以使用管道重定向即一行写完：grep -n $2 $1 | awk -F: '&#123;print $1&#125;' &gt; $3</code></pre><h3 id="Exercise0-4">Exercise0.4</h3><pre><code class="hljs">2.1存在一个调用子目录的Makefile：cd  childDir &amp;&amp; $(MAKE)2.2链接操作：gcc code/fibo.o code/main.o -o fibo2.3头文件不在当前目录gcc -c fibo.c -o fibo.o -I ../include 使用-I参数（预处理过程中需要替换#include中文件头）所以在汇编的第一步预处理过程中也是需要fibo.h头文件</code></pre><hr><h2 id="实验体会">实验体会</h2><h3 id="实验的基本要求与目的：">实验的基本要求与目的：</h3><pre><code class="hljs">1.lab0主要是对一些工具使用的熟悉，文本编辑三剑客grep awk sed最基本的功能2.对Git的简单原理和拓展指令熟悉使用3.命令行运用，可执行文件边写</code></pre><h3 id="实验感受">实验感受</h3><pre><code class="hljs">1.使用命令行虽不及图形操作直观方便，但是更加简洁，对git版本控制的理解也会进一步加深，需要在抽象能力与文件管理能力2.对c语言文件一步一步成为可执行文件的理解进一步加深，比如在预处理的时候也是需要头文件的，这是只是声明，在链接的过程中才会定义。3.使用命令行处理文本时也会更加方便简洁，是一个很好使用的工具。4.无论是编程还是都要保证每一个字符每一条命令的正确性。</code></pre>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OO第一单元总结</title>
    <link href="/2023/03/18/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/2023/03/18/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<hr><h1>OO 第一单元总结</h1><hr><p>本文为OO第一单元总结，本单元主要任务是表达式的展开与化简。核心思想是递归下降法，主要分为预处理、解析、多项式生成、化简四个个核心步骤。三次作业增量迭代的要求如下</p><ul><li><p>第一次作业</p><ul><li>去括号<ul><li>一层括号</li></ul></li><li>多项式化简</li></ul></li><li><p>第二次作业</p><ul><li>括号嵌套</li><li>自定义函数<ul><li>无递归定义，有递归调用</li></ul></li><li>新增三角函数因子</li></ul></li><li><p>第三次作业</p><ul><li><p>自定义函数</p><ul><li>递归声明与调用</li></ul></li><li><p>新增求导因子</p><ul><li>仅出现一次</li></ul></li></ul></li></ul><h2 id="一、程序结构">一、程序结构</h2><h3 id="1-类图-第三次作业">1.类图(第三次作业)</h3><pre><code class=" mermaid">classDiagramMain --&gt; StrHandler : preprocess the input by the method&quot;strHandler&quot;Main --&gt; Parser : parse the input by the method&quot;parseExpr&quot;Main --&gt; Poly : print the result by the method&quot;getPrint&quot;StrHandler --&gt; Func : replace the input&#x27;s functions with exprclass Main&#123;      +main()$&#125;class StrHandler&#123;      +strHandler()$ String      +parseFunc()$ String      +funcHandle()$ String      +findBracket()$ int      +remZero()$ String      +noSignNum()$ String      +noBracket()$ boolean      +isNum()$ boolean      +isTurnNeg()$ boolean&#125;class Func &#123;      -String content      -int sum      -HashMap~Integer, String~ parameters      +getSum() int      +funcStruct() coid      +getContent() String&#125;Parser --&gt; Factor : Parse the factor(Expr/Term/Factor)by LexerParser ..&gt; Lexer : contains Poly ..&gt; Mono : containsFactor --&gt; Poly : turn to Poly from Factor by the method &quot;getPoly()&quot;class Poly &#123;      -int sign      -ArrayList~Mono~ monos      +turnNeg() void      +addPoly() void      +addMono() void      +multPoly() Poly      +getPrint() String&#125;class Mono &#123;      -int sign      -BigInteger con      -BigInteger xin      -BigInteger yin      -BigInteger zin      -HashMap~String,BigInteger~ sins      -HashMap~String,BigInteger~ coss      +setMono() void      +clearHash() void      +turnNeg() void      +addSame() void      +mulMono() Mono      +addTris() void      +addSin() void      +addCos() void      +isSame() boolean      +isSameFang() boolean      +getPrint() String      +printTri() String      +compareTo() int            &#125;class Parser&#123;      -Lexer lexer      +parseExpr() Expr      +parseTerm() Term      +parseFac() Factor      +parseDer() Deri      +parseSin() Sin      +parseCos() Cos&#125;Factor &lt;|-- ExprFactor &lt;|-- TermFactor &lt;|-- CosFactor &lt;|-- SinFactor &lt;|-- NumFactor &lt;|-- VarFactor &lt;|-- DeriFactor &lt;|-- Powerclass Factor&#123;      -int sign      +getSign() int      +setSign() void      +getPoly() Poly      +derivation() Poly&#125;class Lexer&#123;      -String input      -int pos      -String curToken      +next() void      +getNum String      +getCurToken() String      &#125;class Expr&#123;      -int sign      -ArrayList~Term~ terms      +addTerm() void      +getPoly() Poly      +derivation() Poly&#125;class Term&#123;  -int sign  -ArrayList~Factor~ factors  +addFac void  +getPoly Poly  +derivation() Poly  &#125;class Power &#123;      -Expr base      -BigInteger index      -Poly basePoly      +getPoly() Poly      +derivation() Poly&#125;class Cos&#123;  -int sign  -Factor parameter  -BigInteger index  -Poly selfPoly  -String paraStr  +setIndex() void  +getPoly() Poly  +derivation() Poly  +setParameter void  &#125;class Sin&#123;  -int sign  -Factor parameter  -BigInteger index  -Poly selfPoly  -String paraStr  +setIndex() void  +getPoly() Poly  +derivation() Poly  +setParameter void  &#125;class Num&#123;      -int sign      -BigInteger value      +getPoly() Poly      +derivation() Poly&#125;class Var&#123;      -String name      +getPoly() Poly      +derivation() Poly&#125;class Deri&#123;      -int sign      -String fac      -Expr expr      +setFac() void      +setExp() void      +getPoly() Poly      +derivation() Poly&#125;</code></pre><h2 id="2-代码结构">2.代码结构</h2><h3 id="2-1代码行数">2.1代码行数</h3><table><thead><tr><th>Source File</th><th>Total   Lines</th><th>Source Code Lines</th><th>Source Code Line[%]</th><th>Comment Lines</th><th>Comment Lines[%]</th><th>Blank Lines</th><th>Blank Lines[%]</th></tr></thead><tbody><tr><td>Factor.java</td><td>22</td><td>17</td><td>0.7727272727272727</td><td>0</td><td>0.0</td><td>5</td><td>0.22727272727272727</td></tr><tr><td>Deri.java</td><td>24</td><td>19</td><td>0.7916666666666666</td><td>0</td><td>0.0</td><td>5</td><td>0.20833333333333334</td></tr><tr><td>Main.java</td><td>28</td><td>27</td><td>0.9642857142857143</td><td>0</td><td>0.0</td><td>1</td><td>0.03571428571428571</td></tr><tr><td>Num.java</td><td>32</td><td>27</td><td>0.84375</td><td>0</td><td>0.0</td><td>5</td><td>0.15625</td></tr><tr><td>Expr.java</td><td>39</td><td>32</td><td>0.8205128205128205</td><td>0</td><td>0.0</td><td>7</td><td>0.1794871794871795</td></tr><tr><td>Var.java</td><td>44</td><td>39</td><td>0.8863636363636364</td><td>0</td><td>0.0</td><td>5</td><td>0.11363636363636363</td></tr><tr><td>Func.java</td><td>45</td><td>41</td><td>0.9111111111111111</td><td>0</td><td>0.0</td><td>4</td><td>0.08888888888888889</td></tr><tr><td>Term.java</td><td>48</td><td>42</td><td>0.875</td><td>0</td><td>0.0</td><td>6</td><td>0.125</td></tr><tr><td>Power.java</td><td>54</td><td>47</td><td>0.8703703703703703</td><td>0</td><td>0.0</td><td>7</td><td>0.12962962962962962</td></tr><tr><td>Lexer.java</td><td>66</td><td>58</td><td>0.8787878787878788</td><td>0</td><td>0.0</td><td>8</td><td>0.12121212121212122</td></tr><tr><td>Poly.java</td><td>77</td><td>69</td><td>0.8961038961038961</td><td>0</td><td>0.0</td><td>8</td><td>0.1038961038961039</td></tr><tr><td>Cos.java</td><td>98</td><td>90</td><td>0.9183673469387755</td><td>0</td><td>0.0</td><td>8</td><td>0.08163265306122448</td></tr><tr><td>Sin.java</td><td>102</td><td>95</td><td>0.9313725490196079</td><td>0</td><td>0.0</td><td>7</td><td>0.06862745098039216</td></tr><tr><td>Parser.java</td><td>151</td><td>140</td><td>0.9271523178807947</td><td>0</td><td>0.0</td><td>11</td><td>0.0728476821192053</td></tr><tr><td>StrHandler.java</td><td>245</td><td>228</td><td>0.9306122448979591</td><td>1</td><td>0.004081632653061225</td><td>16</td><td>0.0653061224489796</td></tr><tr><td>Mono.java</td><td>315</td><td>295</td><td>0.9365079365079365</td><td>0</td><td>0.0</td><td>20</td><td>0.06349206349206349</td></tr></tbody></table><p>###2.2方法</p><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Cos.Cos()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Cos.derivation(String)</td><td>5</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Cos.getIndex()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Cos.getPoly()</td><td>8</td><td>1</td><td>6</td><td>6</td></tr><tr><td>Cos.setIndex(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Cos.setParameter(Factor)</td><td>4</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Deri.derivation(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Deri.getPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Deri.setExp(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Deri.setFac(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.Expr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Expr.addTerm(Term, int)”</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.derivation(String)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Expr.getPoly()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Factor.derivation(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Factor.getPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Factor.getSign()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Factor.setSign(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Func.funcStruct(String, HashMap&lt;String, Func&gt;)”</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Func.getContent(String[])</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Func.getSum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.Lexer(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getCurToken()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getNum()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Lexer.getPos()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.isSign()</td><td>4</td><td>3</td><td>3</td><td>5</td></tr><tr><td>Lexer.next()</td><td>9</td><td>2</td><td>3</td><td>8</td></tr><tr><td>Main.main(String[])</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Mono.Mono()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mono.Mono(Mono)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Mono.addCos(String, BigInteger)”</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Mono.addSame(Mono)</td><td>6</td><td>1</td><td>7</td><td>7</td></tr><tr><td>“Mono.addSin(String, BigInteger)”</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Mono.addTris(Mono)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Mono.clearHash()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mono.compareTo(Mono)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Mono.getPrint(int, int)”</td><td>28</td><td>3</td><td>20</td><td>22</td></tr><tr><td>Mono.isFang(Mono)</td><td>34</td><td>9</td><td>15</td><td>15</td></tr><tr><td>Mono.isSame(Mono)</td><td>4</td><td>3</td><td>2</td><td>4</td></tr><tr><td>Mono.isSameFang(Mono)</td><td>2</td><td>2</td><td>1</td><td>2</td></tr><tr><td>Mono.mulMono(Mono)</td><td>8</td><td>1</td><td>7</td><td>7</td></tr><tr><td>Mono.printTri(int)</td><td>47</td><td>1</td><td>17</td><td>17</td></tr><tr><td>“Mono.setMono(BigInteger, BigInteger, BigInteger, BigInteger, int)”</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mono.turnNeg()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Num.Num(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Num.derivation(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Num.getPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.Parser(Lexer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.paresDer(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.paresSin(int)</td><td>1</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Parser.parseCos(int)</td><td>1</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Parser.parseExpr()</td><td>7</td><td>1</td><td>4</td><td>5</td></tr><tr><td>Parser.parseFac()</td><td>15</td><td>8</td><td>11</td><td>11</td></tr><tr><td>Parser.parseTerm()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Poly.Poly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.addMono(Mono)</td><td>10</td><td>5</td><td>5</td><td>6</td></tr><tr><td>Poly.addPoly(Poly)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Poly.getPrint()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Poly.mulPoly(Poly)</td><td>3</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.turnNeg()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>“Power.Power(Factor, String)”</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Power.derivation(String)</td><td>4</td><td>2</td><td>3</td><td>3</td></tr><tr><td>Power.getPoly()</td><td>2</td><td>2</td><td>2</td><td>3</td></tr><tr><td>Sin.Sin()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Sin.derivation(String)</td><td>5</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Sin.getIndex()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Sin.getPoly()</td><td>8</td><td>1</td><td>6</td><td>6</td></tr><tr><td>Sin.setIndex(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Sin.setParameter(Factor)</td><td>9</td><td>1</td><td>6</td><td>6</td></tr><tr><td>StrHandler.findBracket(String)</td><td>7</td><td>5</td><td>1</td><td>5</td></tr><tr><td>“StrHandler.funcHandle(String, HashMap&lt;String, Func&gt;)”</td><td>5</td><td>1</td><td>3</td><td>5</td></tr><tr><td>StrHandler.isNum(String)</td><td>5</td><td>4</td><td>1</td><td>5</td></tr><tr><td>StrHandler.isTurnNeg(String)</td><td>9</td><td>1</td><td>1</td><td>9</td></tr><tr><td>StrHandler.noBracket(String)</td><td>12</td><td>2</td><td>1</td><td>9</td></tr><tr><td>StrHandler.noSign(String)</td><td>3</td><td>3</td><td>3</td><td>4</td></tr><tr><td>StrHandler.noSignNum(String)</td><td>8</td><td>4</td><td>3</td><td>8</td></tr><tr><td>StrHandler.noZero(String)</td><td>3</td><td>2</td><td>2</td><td>4</td></tr><tr><td>“StrHandler.parseFunc(String, HashMap&lt;String, Func&gt;)”</td><td>12</td><td>1</td><td>5</td><td>7</td></tr><tr><td>StrHandler.strHandler(String)</td><td>17</td><td>1</td><td>4</td><td>8</td></tr><tr><td>“StrHandler.strHandler(String, HashMap&lt;String, Func&gt;)”</td><td>17</td><td>1</td><td>4</td><td>8</td></tr><tr><td>Term.Term()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.addFac(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.derivation(String)</td><td>7</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Term.getPoly()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Var.Var(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.derivation(String)</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Var.getPoly()</td><td>3</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Total</td><td>359</td><td>136</td><td>247</td><td>307</td></tr><tr><td>Average</td><td>4.13</td><td>1.56</td><td>2.84</td><td>3.53</td></tr></tbody></table><p>###2.3类</p><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Cos</td><td>2.83</td><td>6</td><td>17</td></tr><tr><td>Deri</td><td>1.00</td><td>1</td><td>4</td></tr><tr><td>Expr</td><td>2.00</td><td>3</td><td>8</td></tr><tr><td>Factor</td><td>1.00</td><td>1</td><td>4</td></tr><tr><td>Func</td><td>2.00</td><td>3</td><td>6</td></tr><tr><td>Lexer</td><td>2.50</td><td>7</td><td>15</td></tr><tr><td>Main</td><td>3.00</td><td>3</td><td>3</td></tr><tr><td>Mono</td><td>4.50</td><td>17</td><td>72</td></tr><tr><td>Num</td><td>1.00</td><td>1</td><td>3</td></tr><tr><td>Parser</td><td>3.00</td><td>9</td><td>21</td></tr><tr><td>Poly</td><td>2.83</td><td>6</td><td>17</td></tr><tr><td>Power</td><td>2.33</td><td>3</td><td>7</td></tr><tr><td>Sin</td><td>3.17</td><td>6</td><td>19</td></tr><tr><td>StrHandler</td><td>5.18</td><td>7</td><td>57</td></tr><tr><td>Term</td><td>2.50</td><td>5</td><td>10</td></tr><tr><td>Var</td><td>2.33</td><td>4</td><td>7</td></tr><tr><td>Total</td><td></td><td></td><td>270</td></tr><tr><td>Average</td><td>3.10</td><td>5.12</td><td>16.88</td></tr></tbody></table><h2 id="二、核心架构">二、核心架构</h2><h3 id="1-表达式">1.表达式</h3><pre><code class=" mermaid">graph TBExpr --&gt; Term_1Expr --&gt; Term_2Expr --&gt; Term_nTerm_1 --&gt; Factor_1Term_1 --&gt; Factor_2Term_1 --&gt; Factor_3Term_1 --&gt; Factor_4Term_1 --&gt; Factor_5Term_1 --&gt; Factor_6Term_1 --&gt; Factor_7Factor_2 --&gt; p_exprFactor_2 --&gt; p_numFactor_3 --&gt; d_exprFactor_3 --&gt; d_varFactor_4 --&gt; s_facFactor_4 --&gt; s_indexFactor_5 --&gt; c_facFactor_5 --&gt; c_indexExpr((Expr))Term_1((Term_1))Term_2((Term_2))Term_n((Term_n))Factor_1((Expr))Factor_2((Power))Factor_3((Deri))Factor_4((Sin))Factor_5((Cos))Factor_6((Var))Factor_7((Num))p_expr((Expr))p_num((index))d_expr((Expr))d_var((var))s_fac((Factor))s_index((index))c_fac((Factor))c_index((index))</code></pre><h3 id="2-多项式">2.多项式</h3><pre><code class=" mermaid">graph LRExpr((Expr))Term1((Term_1))Term2((Term_2))Termn((Term_n))Factor1((Factor_1))Factor2((Factor_2))Factorn((Factor_n))Expr --&gt; Term1Expr --&gt; Term2Expr --&gt; TermnTerm1 --&gt; Factor1Term1 --&gt; Factor2Term1 --&gt; FactornFactor1 --getPoly--&gt; fp1((Poly1))Factor2 --getPoly--&gt; fp2((Poly2))Factorn --getPoly--&gt; fpn((Polyn))tp1((newPoly1))tp2((newPoly2))tpn((newPolyn))fp1 --multPoly--&gt; tp1fp2 --multPoly--&gt; tp1fpn --multPoly--&gt; tp1Term2 --Factors getPoly multPoly--&gt;tp2Termn --Factors getPoly multPoly--&gt;tpnep1((resultPoly))tp1 --&gt; ep1tp2 --&gt; ep1tpn --&gt; ep1</code></pre><h3 id="3-数学公式">3.数学公式</h3><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>P</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><mi>f</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>P</mi><mi>o</mi><mi>l</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">resultPoly = \sum_{i=0}^n \prod_{j=0}^m factorPoly</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">res</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.13889em;">ltP</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0652em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span></p><h3 id="4-架构设计体验">4.架构设计体验</h3><h4 id="第一次作业">第一次作业</h4><pre><code class="hljs">    第一次作业比较简单，但由于考虑到之后的迭代开发，还是选择了递归下降，此时的代码可以处理括号嵌套的表达式。预处理包括：去除多余的正负号仅保留必要的符号、去除空白符和制表符、将**替换为^；词法语法解析的整体思路参考了练习作业提供的代码；化简在计算的过程中进行，Mono的标准形式为 Mono = ax^i^y^j^z^k^，在单项式计算的时候采用深克隆</code></pre><h4 id="第二次作业">第二次作业</h4><pre><code class="hljs">     第二次迭代增加了括号嵌套、自定义函数、三角函数因子。递归下降已经解决括号嵌套；对于自定义函数将其放到预处理中，也用递归下降先对自定义函数进行表达式化简，之后替换；在Mono中添加两个HashMap&lt;String, index&gt;分别记录三角函数的参数与指数，Mono的标准形式变为：$Mono = ax^i^y^j^z^k^ \prod^&#123;i=0&#125; sin \prod^&#123;i=0&#125; cos$。判断同列项（除了常数）去掉常数项后的字符串比较，为了保证sin（x+y）和sin（y+x）能够化简，在Poly的getPrint方法中，需要先对mono实现comparable接口重写比较方法。</code></pre><h4 id="第三次作业">第三次作业</h4><pre><code class="hljs">     第三次迭代增加了自定义函数的递归调用、求导因子。自定义函数只需要在预处理的过程中像处理第二次表达式的方式处理即可；求导因子我们就当做新加因子，在表达式getPoly的时候处理，利用求导法则分别写出Expr、Term、其他因子的求导方法即可。    由于第二次优化没有做多少，所以第三次最主要是两个优化，sin（y-x）+sin（x-y）和sin^2^+cos^2^。第一个比较好做，只需要在打印三角函数参数的时候依据正负号的数量和字符串比较来实现；第二个优化类似同列项判断，在Mono相加的时候遍历两个三角函数HashMap，判断另一个Mono中去掉相应的项之后的是否为同类项。此时便会出现新情况，例如：sin(x)*cos(x)+sin(x)^3^*cos(x)+cos(x)^3^*sin(x) 化简时出现新的同类项，对此我的做法是递归化简（乱起的名），以上述为例，先将后两项相加得到Mono：sin(x)*cos(x)，之后在Poly中删除刚刚化简得到的Mono，再将该Mono加入Poly中，发现同类项合并得到2*sin(x)*cos(x), 重复上述过程，删除2*sin(x)*cos(x)，再加到Poly中发现没有同类项，到此合并完成。</code></pre><h3 id="5-架构的优缺点">5.架构的优缺点</h3><ul><li><p>优点</p><ul><li>求导因子，在求导因子生成多项式的时候再处理，可以复用之前的Poly相乘和相加的方法，且不会涉及深浅克隆问题</li><li>三角函数存储方式为String，这样优点很明显，比如仅需要调用一次内层因子的打印函数</li><li>边计算边化简，递归化简会比单独写一个化简函数方便，也更符合程序的流程</li><li>可以处理求导因子的嵌套</li></ul></li><li><p>缺点</p><ul><li>对于自定义函数应该也当做因子处理，在解析的过程中替换，而不是在预处理中替换</li><li>由于父类Factor拥有属性sign，但是在解析中真正有正负的只有Num和Term，其他的都默认为符号为1。在我的架构中埋下了隐患，这会在下面谈到</li></ul></li></ul><h3 id="三、Bug">三、Bug</h3><ul><li>第一次<ul><li>互测竟然没有挨刀，在系数为1的时候，特判条件太多，造成漏洞，1 * y * z输出yz</li><li>0-x+x没有输出，这是因为-x+x合并完之后产生新的同类项，但是这个在互测和强测都没有测出来，自己也没注意到</li></ul></li><li>第二次<ul><li>1-x+x，哎，第一次作业埋的雷</li><li>sin(0) ** 0=0  在判断的时候先判断了sin参数是否为0</li><li>x**21 输出为x* * x1  直接对Mono输出的字符串直接进行替换</li></ul></li><li>第三次<ul><li>dx(sin((-x))) 输出cos(x)  承接上文我的架构，由于我的sin因子里有Factor属性，Poly属性（Factor生成），在提负号到外面的时候只改变了Poly的符号（将所有Mono变号），但是没有把Factor变号。就算变号，由于（-x）是表达式因子，而在我的架构中表达式默认符号为正</li></ul></li><li>总结出现的bug<ul><li>if特判条件，能否把所有的情况都考虑到，是否会漏到一些情况，应该优点判断那些情况</li><li>直接对字符串处理是一件愚蠢至极的方法</li><li>迭代产生的bug，大多数都是复用之前的方法导致错误</li></ul></li></ul><h2 id="四、Hack策略">四、Hack策略</h2><p>列举一些hack成功的例子</p><ul><li><p>边界条件</p><ul><li><p>sin((-x)) --&gt; sin(-x)</p></li><li><pre><code class="hljs">1f(x)=cos(cos(cos(cos(x))))sin(sin(cos(cos(cos(cos(cos(cos(dx(f(x)))))))))) --&gt; TLE                 利用cost条件实现TLE<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br><span class="hljs-comment">*  求导因子出现的位置，对特殊的因子求导</span><br><br><span class="hljs-comment">  * ```</span><br>    1<br>    <span class="hljs-built_in">f</span>(x,y) = ((+x))**2+y<br>    -dx(<span class="hljs-built_in">f</span>(y,0))+y<br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="hljs">2f(x,y,z)=x-(y+z)g(x,z,y)=-dz((y-z)**2)-(f(0,-1,+1)-g(x**+0,x**+2,x**01))<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><br>* ```<br>  <span class="hljs-number">2</span><br>  <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-variable">x</span>) = <span class="hljs-title">sin</span>(<span class="hljs-title">cos</span>(<span class="hljs-variable">x</span>))</span><br>  <span class="hljs-function"><span class="hljs-title">g</span>(<span class="hljs-variable">y</span> ) = <span class="hljs-title">dy</span>(<span class="hljs-title">f</span>(<span class="hljs-variable">y</span>))</span><br>  <span class="hljs-function"><span class="hljs-title">g</span>(<span class="hljs-variable">y</span>)</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h2 id="五、心得体会">五、心得体会</h2><pre><code class="hljs">  在第一次和第二次我几乎都没怎么做测试，第三次测试也只是把第二次数据改了改添加了求导因子，然后和室友python对拍，结果就是三次作业都有bug，下周说什么也得把评测机写出来。在写代码的时候尽量保证程序正义性，再结合随机测试数据和评测机才是正道！！   复用之前的方法很容易出bug，接口的实现尤为重要，对于每个方法都需要清楚知道输入限制及方法的作用，迭代之后是否还能接着用。慢工出细活，写OO还是得抽出连续大量的时间，且要长时间专注。递归下降确实好用，但就是感觉缺少了一点面向对象的思想，第一单元感觉就像是数据结构哈哈哈哈。感觉评测没有上学期的OOpre覆盖性强，一个点就好几千上万条数据，bug还得靠互测。</code></pre><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OO</tag>
      
      <tag>总结</tag>
      
      <tag>递归下降</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
