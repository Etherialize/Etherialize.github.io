<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OS lab0实验报告</title>
    <link href="/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<hr><p>#实验报告</p><p>##lab0思考题</p><p>###thinking0.1</p><pre><code class="hljs">不一样，在新建README.txt时候，处于Untracked状态，文件第二行显示&quot;Untracked files&quot;。当add 追踪再修改处于已修改状态,Modified.txt显示&quot;Changes not staged for commit&quot;，此时使用add命令进入Stage区。这两次add的功能并不相同，第一次是追踪，第二次是提交修改。</code></pre><p>###thinking0.2</p><img src="/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/Git.png" class><pre><code class="hljs">Add the file --&gt; git addStage the file --&gt; git addcommit --&gt; git commit</code></pre><p>###thinking0.3</p><pre><code class="hljs">1.git checkout -- print.c2.git reset HEAD print.c3.git rm --cached print.c</code></pre><p>###thinking0.4</p><img src="/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/thinking0.4.png" class><pre><code class="hljs">3 hashcode:d5b5d0e2008b045060fc390388ed88519e3378572 hashcode:3afeaf4e09d5ebb5a811f24dfd9e8357b47d021b1 hashcode:8e72b92edb7dd5370ab5ce48d270a9a32ebf78aagit reset --hard HEAD^ 显示当前在版本2git reset --hard 8e72b92edb7dd5370ab5ce48d270a9a32ebf78aa显示在版本1git reset --hard d5b5d0e2008b045060fc390388ed88519e337857又返回到版本3</code></pre><p>###thinking0.5</p><pre><code class="hljs">echo first直接在shell输出firstecho second &gt; output.txt 将second输出到output中，若文件已存在并替换原来的内容echo third &gt; output.txt 同理，output中只有thirdecho forth &gt;&gt; output.txt 将forth写到output原有内容之后，此时文件中显示thirdforth</code></pre><p>###thinking0.6</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>：<br>1 <span class="hljs-built_in">echo</span> Shell Start<br>  2 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> a = 1<br>  3 a=1<br>  4 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> b = 2<br>  5 b=2<br>  6 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> c = a+b<br>  7 c=$[<span class="hljs-variable">$a</span>+<span class="hljs-variable">$b</span>]<br>  8 <span class="hljs-built_in">echo</span> c = <span class="hljs-variable">$c</span><br>  9 <span class="hljs-built_in">echo</span> save c to ./file1<br> 10 <span class="hljs-built_in">echo</span> <span class="hljs-variable">$c</span>&gt;file1<br> 11 <span class="hljs-built_in">echo</span> save b to ./file2<br> 12 <span class="hljs-built_in">echo</span> <span class="hljs-variable">$b</span>&gt;file2<br> 13 <span class="hljs-built_in">echo</span> save a to ./file3<br> 14 <span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span>&gt;file3<br> 15 <span class="hljs-built_in">echo</span> save file1 file2 file3 to file4<br> 16 <span class="hljs-built_in">cat</span> file1&gt;file4<br> 17 <span class="hljs-built_in">cat</span> file2&gt;&gt;file4<br> 18 <span class="hljs-built_in">cat</span> file3&gt;&gt;file4<br> 19 <span class="hljs-built_in">echo</span> save file4 to ./result<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span>：<br>1 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> Shell Start &gt; <span class="hljs-built_in">test</span><br>  2 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> a = 1 &gt;&gt; <span class="hljs-built_in">test</span><br>  3 <span class="hljs-built_in">echo</span> a=1 &gt;&gt; <span class="hljs-built_in">test</span><br>  4 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> b = 2 &gt;&gt; <span class="hljs-built_in">test</span><br>  5 <span class="hljs-built_in">echo</span> b=2 &gt;&gt; <span class="hljs-built_in">test</span><br>  6 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> c = a+b &gt;&gt;<span class="hljs-built_in">test</span><br>  7 <span class="hljs-built_in">echo</span> c=<span class="hljs-string">&#x27;$[$a+$b]&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br>  8 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> c = <span class="hljs-string">&#x27;$c&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br>  9 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save c to ./file1 &gt;&gt; <span class="hljs-built_in">test</span><br> 10 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$c&gt;&#x27;</span>file1 &gt;&gt;<span class="hljs-built_in">test</span><br> 11 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save b to ./file2 &gt;&gt; <span class="hljs-built_in">test</span><br> 12 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$b&gt;&#x27;</span>file2 &gt;&gt;<span class="hljs-built_in">test</span><br> 13 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save a to ./file3 &gt;&gt; <span class="hljs-built_in">test</span><br> 14 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$a&gt;&#x27;</span>file3 &gt;&gt;<span class="hljs-built_in">test</span><br> 15 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save file1 file2 file3 to file4 &gt;&gt; <span class="hljs-built_in">test</span><br> 16 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">cat</span> file1<span class="hljs-string">&#x27;&gt;&#x27;</span>file4  &gt;&gt; <span class="hljs-built_in">test</span><br> 17 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">cat</span> file2<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>file4 &gt;&gt; <span class="hljs-built_in">test</span><br> 18 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">cat</span> file3<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>file4 &gt;&gt;<span class="hljs-built_in">test</span><br> 19 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save file4 to ./result &gt;&gt;<span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><hr><p>##难点分析</p><p>###Exercise0.1</p><pre><code class="hljs">sed -n（安静模式）即只输出经过sed修改后的内容</code></pre><p>###Exercise0.2</p><pre><code class="hljs">在bash可执行文件中，熟悉文法结构，每一条都是命令，所以if while中的参数也是命令，-ne，-eq等命令，且须注意在关系成立时返回0，与常规语言不同。</code></pre><p>###Exercise0.3</p><pre><code class="hljs">使用grep和awk指令结合使用，可以使用创建中间文件然后再删除，也可以使用管道重定向即一行写完：grep -n $2 $1 | awk -F: '&#123;print $1&#125;' &gt; $3</code></pre><p>###Exercise0.4</p><pre><code class="hljs">2.1存在一个调用子目录的Makefile：cd  childDir &amp;&amp; $(MAKE)2.2链接操作：gcc code/fibo.o code/main.o -o fibo2.3头文件不在当前目录gcc -c fibo.c -o fibo.o -I ../include 使用-I参数（预处理过程中需要替换#include中文件头）所以在汇编的第一步预处理过程中也是需要fibo.h头文件</code></pre><hr><p>##实验体会</p><p>###实验的基本要求与目的：</p><pre><code class="hljs">1.lab0主要是对一些工具使用的熟悉，文本编辑三剑客grep awk sed最基本的功能2.对Git的简单原理和拓展指令熟悉使用3.命令行运用，可执行文件边写</code></pre><p>###实验感受</p><pre><code class="hljs">1.使用命令行虽不及图形操作直观方便，但是更加简洁，对git版本控制的理解也会进一步加深，需要在抽象能力与文件管理能力2.对c语言文件一步一步成为可执行文件的理解进一步加深，比如在预处理的时候也是需要头文件的，这是只是声明，在链接的过程中才会定义。3.使用命令行处理文本时也会更加方便简洁，是一个很好使用的工具。4.无论是编程还是都要保证每一个字符每一条命令的正确性。</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OO第一单元总结</title>
    <link href="/2023/03/18/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/2023/03/18/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<hr><p>#OO 第一单元总结</p><hr><p>本文为OO第一单元总结，本单元主要任务是表达式的展开与化简。核心思想是递归下降法，主要分为预处理、解析、多项式生成、化简四个个核心步骤。三次作业增量迭代的要求如下</p><ul><li><p>第一次作业</p><ul><li>去括号<ul><li>一层括号</li></ul></li><li>多项式化简</li></ul></li><li><p>第二次作业</p><ul><li>括号嵌套</li><li>自定义函数<ul><li>无递归定义，有递归调用</li></ul></li><li>新增三角函数因子</li></ul></li><li><p>第三次作业</p><ul><li><p>自定义函数</p><ul><li>递归声明与调用</li></ul></li><li><p>新增求导因子</p><ul><li>仅出现一次</li></ul></li></ul></li></ul><h2 id="一、程序结构">一、程序结构</h2><h3 id="1-类图-第三次作业">1.类图(第三次作业)</h3><pre><code class=" mermaid">classDiagramMain --&gt; StrHandler : preprocess the input by the method&quot;strHandler&quot;Main --&gt; Parser : parse the input by the method&quot;parseExpr&quot;Main --&gt; Poly : print the result by the method&quot;getPrint&quot;StrHandler --&gt; Func : replace the input&#x27;s functions with exprclass Main&#123;      +main()$&#125;class StrHandler&#123;      +strHandler()$ String      +parseFunc()$ String      +funcHandle()$ String      +findBracket()$ int      +remZero()$ String      +noSignNum()$ String      +noBracket()$ boolean      +isNum()$ boolean      +isTurnNeg()$ boolean&#125;class Func &#123;      -String content      -int sum      -HashMap~Integer, String~ parameters      +getSum() int      +funcStruct() coid      +getContent() String&#125;Parser --&gt; Factor : Parse the factor(Expr/Term/Factor)by LexerParser ..&gt; Lexer : contains Poly ..&gt; Mono : containsFactor --&gt; Poly : turn to Poly from Factor by the method &quot;getPoly()&quot;class Poly &#123;      -int sign      -ArrayList~Mono~ monos      +turnNeg() void      +addPoly() void      +addMono() void      +multPoly() Poly      +getPrint() String&#125;class Mono &#123;      -int sign      -BigInteger con      -BigInteger xin      -BigInteger yin      -BigInteger zin      -HashMap~String,BigInteger~ sins      -HashMap~String,BigInteger~ coss      +setMono() void      +clearHash() void      +turnNeg() void      +addSame() void      +mulMono() Mono      +addTris() void      +addSin() void      +addCos() void      +isSame() boolean      +isSameFang() boolean      +getPrint() String      +printTri() String      +compareTo() int            &#125;class Parser&#123;      -Lexer lexer      +parseExpr() Expr      +parseTerm() Term      +parseFac() Factor      +parseDer() Deri      +parseSin() Sin      +parseCos() Cos&#125;Factor &lt;|-- ExprFactor &lt;|-- TermFactor &lt;|-- CosFactor &lt;|-- SinFactor &lt;|-- NumFactor &lt;|-- VarFactor &lt;|-- DeriFactor &lt;|-- Powerclass Factor&#123;      -int sign      +getSign() int      +setSign() void      +getPoly() Poly      +derivation() Poly&#125;class Lexer&#123;      -String input      -int pos      -String curToken      +next() void      +getNum String      +getCurToken() String      &#125;class Expr&#123;      -int sign      -ArrayList~Term~ terms      +addTerm() void      +getPoly() Poly      +derivation() Poly&#125;class Term&#123;  -int sign  -ArrayList~Factor~ factors  +addFac void  +getPoly Poly  +derivation() Poly  &#125;class Power &#123;      -Expr base      -BigInteger index      -Poly basePoly      +getPoly() Poly      +derivation() Poly&#125;class Cos&#123;  -int sign  -Factor parameter  -BigInteger index  -Poly selfPoly  -String paraStr  +setIndex() void  +getPoly() Poly  +derivation() Poly  +setParameter void  &#125;class Sin&#123;  -int sign  -Factor parameter  -BigInteger index  -Poly selfPoly  -String paraStr  +setIndex() void  +getPoly() Poly  +derivation() Poly  +setParameter void  &#125;class Num&#123;      -int sign      -BigInteger value      +getPoly() Poly      +derivation() Poly&#125;class Var&#123;      -String name      +getPoly() Poly      +derivation() Poly&#125;class Deri&#123;      -int sign      -String fac      -Expr expr      +setFac() void      +setExp() void      +getPoly() Poly      +derivation() Poly&#125;</code></pre><h2 id="2-代码结构">2.代码结构</h2><h3 id="2-1代码行数">2.1代码行数</h3><table><thead><tr><th>Source File</th><th>Total   Lines</th><th>Source Code Lines</th><th>Source Code Line[%]</th><th>Comment Lines</th><th>Comment Lines[%]</th><th>Blank Lines</th><th>Blank Lines[%]</th></tr></thead><tbody><tr><td>Factor.java</td><td>22</td><td>17</td><td>0.7727272727272727</td><td>0</td><td>0.0</td><td>5</td><td>0.22727272727272727</td></tr><tr><td>Deri.java</td><td>24</td><td>19</td><td>0.7916666666666666</td><td>0</td><td>0.0</td><td>5</td><td>0.20833333333333334</td></tr><tr><td>Main.java</td><td>28</td><td>27</td><td>0.9642857142857143</td><td>0</td><td>0.0</td><td>1</td><td>0.03571428571428571</td></tr><tr><td>Num.java</td><td>32</td><td>27</td><td>0.84375</td><td>0</td><td>0.0</td><td>5</td><td>0.15625</td></tr><tr><td>Expr.java</td><td>39</td><td>32</td><td>0.8205128205128205</td><td>0</td><td>0.0</td><td>7</td><td>0.1794871794871795</td></tr><tr><td>Var.java</td><td>44</td><td>39</td><td>0.8863636363636364</td><td>0</td><td>0.0</td><td>5</td><td>0.11363636363636363</td></tr><tr><td>Func.java</td><td>45</td><td>41</td><td>0.9111111111111111</td><td>0</td><td>0.0</td><td>4</td><td>0.08888888888888889</td></tr><tr><td>Term.java</td><td>48</td><td>42</td><td>0.875</td><td>0</td><td>0.0</td><td>6</td><td>0.125</td></tr><tr><td>Power.java</td><td>54</td><td>47</td><td>0.8703703703703703</td><td>0</td><td>0.0</td><td>7</td><td>0.12962962962962962</td></tr><tr><td>Lexer.java</td><td>66</td><td>58</td><td>0.8787878787878788</td><td>0</td><td>0.0</td><td>8</td><td>0.12121212121212122</td></tr><tr><td>Poly.java</td><td>77</td><td>69</td><td>0.8961038961038961</td><td>0</td><td>0.0</td><td>8</td><td>0.1038961038961039</td></tr><tr><td>Cos.java</td><td>98</td><td>90</td><td>0.9183673469387755</td><td>0</td><td>0.0</td><td>8</td><td>0.08163265306122448</td></tr><tr><td>Sin.java</td><td>102</td><td>95</td><td>0.9313725490196079</td><td>0</td><td>0.0</td><td>7</td><td>0.06862745098039216</td></tr><tr><td>Parser.java</td><td>151</td><td>140</td><td>0.9271523178807947</td><td>0</td><td>0.0</td><td>11</td><td>0.0728476821192053</td></tr><tr><td>StrHandler.java</td><td>245</td><td>228</td><td>0.9306122448979591</td><td>1</td><td>0.004081632653061225</td><td>16</td><td>0.0653061224489796</td></tr><tr><td>Mono.java</td><td>315</td><td>295</td><td>0.9365079365079365</td><td>0</td><td>0.0</td><td>20</td><td>0.06349206349206349</td></tr></tbody></table><p>###2.2方法</p><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Cos.Cos()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Cos.derivation(String)</td><td>5</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Cos.getIndex()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Cos.getPoly()</td><td>8</td><td>1</td><td>6</td><td>6</td></tr><tr><td>Cos.setIndex(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Cos.setParameter(Factor)</td><td>4</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Deri.derivation(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Deri.getPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Deri.setExp(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Deri.setFac(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.Expr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Expr.addTerm(Term, int)”</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.derivation(String)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Expr.getPoly()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Factor.derivation(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Factor.getPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Factor.getSign()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Factor.setSign(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Func.funcStruct(String, HashMap&lt;String, Func&gt;)”</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Func.getContent(String[])</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Func.getSum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.Lexer(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getCurToken()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getNum()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Lexer.getPos()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.isSign()</td><td>4</td><td>3</td><td>3</td><td>5</td></tr><tr><td>Lexer.next()</td><td>9</td><td>2</td><td>3</td><td>8</td></tr><tr><td>Main.main(String[])</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Mono.Mono()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mono.Mono(Mono)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Mono.addCos(String, BigInteger)”</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Mono.addSame(Mono)</td><td>6</td><td>1</td><td>7</td><td>7</td></tr><tr><td>“Mono.addSin(String, BigInteger)”</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Mono.addTris(Mono)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Mono.clearHash()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mono.compareTo(Mono)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Mono.getPrint(int, int)”</td><td>28</td><td>3</td><td>20</td><td>22</td></tr><tr><td>Mono.isFang(Mono)</td><td>34</td><td>9</td><td>15</td><td>15</td></tr><tr><td>Mono.isSame(Mono)</td><td>4</td><td>3</td><td>2</td><td>4</td></tr><tr><td>Mono.isSameFang(Mono)</td><td>2</td><td>2</td><td>1</td><td>2</td></tr><tr><td>Mono.mulMono(Mono)</td><td>8</td><td>1</td><td>7</td><td>7</td></tr><tr><td>Mono.printTri(int)</td><td>47</td><td>1</td><td>17</td><td>17</td></tr><tr><td>“Mono.setMono(BigInteger, BigInteger, BigInteger, BigInteger, int)”</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mono.turnNeg()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Num.Num(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Num.derivation(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Num.getPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.Parser(Lexer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.paresDer(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.paresSin(int)</td><td>1</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Parser.parseCos(int)</td><td>1</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Parser.parseExpr()</td><td>7</td><td>1</td><td>4</td><td>5</td></tr><tr><td>Parser.parseFac()</td><td>15</td><td>8</td><td>11</td><td>11</td></tr><tr><td>Parser.parseTerm()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Poly.Poly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.addMono(Mono)</td><td>10</td><td>5</td><td>5</td><td>6</td></tr><tr><td>Poly.addPoly(Poly)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Poly.getPrint()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Poly.mulPoly(Poly)</td><td>3</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.turnNeg()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>“Power.Power(Factor, String)”</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Power.derivation(String)</td><td>4</td><td>2</td><td>3</td><td>3</td></tr><tr><td>Power.getPoly()</td><td>2</td><td>2</td><td>2</td><td>3</td></tr><tr><td>Sin.Sin()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Sin.derivation(String)</td><td>5</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Sin.getIndex()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Sin.getPoly()</td><td>8</td><td>1</td><td>6</td><td>6</td></tr><tr><td>Sin.setIndex(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Sin.setParameter(Factor)</td><td>9</td><td>1</td><td>6</td><td>6</td></tr><tr><td>StrHandler.findBracket(String)</td><td>7</td><td>5</td><td>1</td><td>5</td></tr><tr><td>“StrHandler.funcHandle(String, HashMap&lt;String, Func&gt;)”</td><td>5</td><td>1</td><td>3</td><td>5</td></tr><tr><td>StrHandler.isNum(String)</td><td>5</td><td>4</td><td>1</td><td>5</td></tr><tr><td>StrHandler.isTurnNeg(String)</td><td>9</td><td>1</td><td>1</td><td>9</td></tr><tr><td>StrHandler.noBracket(String)</td><td>12</td><td>2</td><td>1</td><td>9</td></tr><tr><td>StrHandler.noSign(String)</td><td>3</td><td>3</td><td>3</td><td>4</td></tr><tr><td>StrHandler.noSignNum(String)</td><td>8</td><td>4</td><td>3</td><td>8</td></tr><tr><td>StrHandler.noZero(String)</td><td>3</td><td>2</td><td>2</td><td>4</td></tr><tr><td>“StrHandler.parseFunc(String, HashMap&lt;String, Func&gt;)”</td><td>12</td><td>1</td><td>5</td><td>7</td></tr><tr><td>StrHandler.strHandler(String)</td><td>17</td><td>1</td><td>4</td><td>8</td></tr><tr><td>“StrHandler.strHandler(String, HashMap&lt;String, Func&gt;)”</td><td>17</td><td>1</td><td>4</td><td>8</td></tr><tr><td>Term.Term()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.addFac(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.derivation(String)</td><td>7</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Term.getPoly()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Var.Var(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.derivation(String)</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Var.getPoly()</td><td>3</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Total</td><td>359</td><td>136</td><td>247</td><td>307</td></tr><tr><td>Average</td><td>4.13</td><td>1.56</td><td>2.84</td><td>3.53</td></tr></tbody></table><p>###2.3类</p><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Cos</td><td>2.83</td><td>6</td><td>17</td></tr><tr><td>Deri</td><td>1.00</td><td>1</td><td>4</td></tr><tr><td>Expr</td><td>2.00</td><td>3</td><td>8</td></tr><tr><td>Factor</td><td>1.00</td><td>1</td><td>4</td></tr><tr><td>Func</td><td>2.00</td><td>3</td><td>6</td></tr><tr><td>Lexer</td><td>2.50</td><td>7</td><td>15</td></tr><tr><td>Main</td><td>3.00</td><td>3</td><td>3</td></tr><tr><td>Mono</td><td>4.50</td><td>17</td><td>72</td></tr><tr><td>Num</td><td>1.00</td><td>1</td><td>3</td></tr><tr><td>Parser</td><td>3.00</td><td>9</td><td>21</td></tr><tr><td>Poly</td><td>2.83</td><td>6</td><td>17</td></tr><tr><td>Power</td><td>2.33</td><td>3</td><td>7</td></tr><tr><td>Sin</td><td>3.17</td><td>6</td><td>19</td></tr><tr><td>StrHandler</td><td>5.18</td><td>7</td><td>57</td></tr><tr><td>Term</td><td>2.50</td><td>5</td><td>10</td></tr><tr><td>Var</td><td>2.33</td><td>4</td><td>7</td></tr><tr><td>Total</td><td></td><td></td><td>270</td></tr><tr><td>Average</td><td>3.10</td><td>5.12</td><td>16.88</td></tr></tbody></table><h2 id="二、核心架构">二、核心架构</h2><h3 id="1-表达式">1.表达式</h3><pre><code class=" mermaid">graph TBExpr --&gt; Term_1Expr --&gt; Term_2Expr --&gt; Term_nTerm_1 --&gt; Factor_1Term_1 --&gt; Factor_2Term_1 --&gt; Factor_3Term_1 --&gt; Factor_4Term_1 --&gt; Factor_5Term_1 --&gt; Factor_6Term_1 --&gt; Factor_7Factor_2 --&gt; p_exprFactor_2 --&gt; p_numFactor_3 --&gt; d_exprFactor_3 --&gt; d_varFactor_4 --&gt; s_facFactor_4 --&gt; s_indexFactor_5 --&gt; c_facFactor_5 --&gt; c_indexExpr((Expr))Term_1((Term_1))Term_2((Term_2))Term_n((Term_n))Factor_1((Expr))Factor_2((Power))Factor_3((Deri))Factor_4((Sin))Factor_5((Cos))Factor_6((Var))Factor_7((Num))p_expr((Expr))p_num((index))d_expr((Expr))d_var((var))s_fac((Factor))s_index((index))c_fac((Factor))c_index((index))</code></pre><h3 id="2-多项式">2.多项式</h3><pre><code class=" mermaid">graph LRExpr((Expr))Term1((Term_1))Term2((Term_2))Termn((Term_n))Factor1((Factor_1))Factor2((Factor_2))Factorn((Factor_n))Expr --&gt; Term1Expr --&gt; Term2Expr --&gt; TermnTerm1 --&gt; Factor1Term1 --&gt; Factor2Term1 --&gt; FactornFactor1 --getPoly--&gt; fp1((Poly1))Factor2 --getPoly--&gt; fp2((Poly2))Factorn --getPoly--&gt; fpn((Polyn))tp1((newPoly1))tp2((newPoly2))tpn((newPolyn))fp1 --multPoly--&gt; tp1fp2 --multPoly--&gt; tp1fpn --multPoly--&gt; tp1Term2 --Factors getPoly multPoly--&gt;tp2Termn --Factors getPoly multPoly--&gt;tpnep1((resultPoly))tp1 --&gt; ep1tp2 --&gt; ep1tpn --&gt; ep1</code></pre><h3 id="3-数学公式">3.数学公式</h3><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>P</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><mi>f</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>P</mi><mi>o</mi><mi>l</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">resultPoly = \sum_{i=0}^n \prod_{j=0}^m factorPoly</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">res</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.13889em;">ltP</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0652em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span></p><h3 id="4-架构设计体验">4.架构设计体验</h3><h4 id="第一次作业">第一次作业</h4><pre><code class="hljs">    第一次作业比较简单，但由于考虑到之后的迭代开发，还是选择了递归下降，此时的代码可以处理括号嵌套的表达式。预处理包括：去除多余的正负号仅保留必要的符号、去除空白符和制表符、将**替换为^；词法语法解析的整体思路参考了练习作业提供的代码；化简在计算的过程中进行，Mono的标准形式为 Mono = ax^i^y^j^z^k^，在单项式计算的时候采用深克隆</code></pre><h4 id="第二次作业">第二次作业</h4><pre><code class="hljs">     第二次迭代增加了括号嵌套、自定义函数、三角函数因子。递归下降已经解决括号嵌套；对于自定义函数将其放到预处理中，也用递归下降先对自定义函数进行表达式化简，之后替换；在Mono中添加两个HashMap&lt;String, index&gt;分别记录三角函数的参数与指数，Mono的标准形式变为：$Mono = ax^i^y^j^z^k^ \prod^&#123;i=0&#125; sin \prod^&#123;i=0&#125; cos$。判断同列项（除了常数）去掉常数项后的字符串比较，为了保证sin（x+y）和sin（y+x）能够化简，在Poly的getPrint方法中，需要先对mono实现comparable接口重写比较方法。</code></pre><h4 id="第三次作业">第三次作业</h4><pre><code class="hljs">     第三次迭代增加了自定义函数的递归调用、求导因子。自定义函数只需要在预处理的过程中像处理第二次表达式的方式处理即可；求导因子我们就当做新加因子，在表达式getPoly的时候处理，利用求导法则分别写出Expr、Term、其他因子的求导方法即可。    由于第二次优化没有做多少，所以第三次最主要是两个优化，sin（y-x）+sin（x-y）和sin^2^+cos^2^。第一个比较好做，只需要在打印三角函数参数的时候依据正负号的数量和字符串比较来实现；第二个优化类似同列项判断，在Mono相加的时候遍历两个三角函数HashMap，判断另一个Mono中去掉相应的项之后的是否为同类项。此时便会出现新情况，例如：sin(x)*cos(x)+sin(x)^3^*cos(x)+cos(x)^3^*sin(x) 化简时出现新的同类项，对此我的做法是递归化简（乱起的名），以上述为例，先将后两项相加得到Mono：sin(x)*cos(x)，之后在Poly中删除刚刚化简得到的Mono，再将该Mono加入Poly中，发现同类项合并得到2*sin(x)*cos(x), 重复上述过程，删除2*sin(x)*cos(x)，再加到Poly中发现没有同类项，到此合并完成。</code></pre><h3 id="5-架构的优缺点">5.架构的优缺点</h3><ul><li><p>优点</p><ul><li>求导因子，在求导因子生成多项式的时候再处理，可以复用之前的Poly相乘和相加的方法，且不会涉及深浅克隆问题</li><li>三角函数存储方式为String，这样优点很明显，比如仅需要调用一次内层因子的打印函数</li><li>边计算边化简，递归化简会比单独写一个化简函数方便，也更符合程序的流程</li><li>可以处理求导因子的嵌套</li></ul></li><li><p>缺点</p><ul><li>对于自定义函数应该也当做因子处理，在解析的过程中替换，而不是在预处理中替换</li><li>由于父类Factor拥有属性sign，但是在解析中真正有正负的只有Num和Term，其他的都默认为符号为1。在我的架构中埋下了隐患，这会在下面谈到</li></ul></li></ul><h3 id="三、Bug">三、Bug</h3><ul><li>第一次<ul><li>互测竟然没有挨刀，在系数为1的时候，特判条件太多，造成漏洞，1 * y * z输出yz</li><li>0-x+x没有输出，这是因为-x+x合并完之后产生新的同类项，但是这个在互测和强测都没有测出来，自己也没注意到</li></ul></li><li>第二次<ul><li>1-x+x，哎，第一次作业埋的雷</li><li>sin(0) ** 0=0  在判断的时候先判断了sin参数是否为0</li><li>x**21 输出为x* * x1  直接对Mono输出的字符串直接进行替换</li></ul></li><li>第三次<ul><li>dx(sin((-x))) 输出cos(x)  承接上文我的架构，由于我的sin因子里有Factor属性，Poly属性（Factor生成），在提负号到外面的时候只改变了Poly的符号（将所有Mono变号），但是没有把Factor变号。就算变号，由于（-x）是表达式因子，而在我的架构中表达式默认符号为正</li></ul></li><li>总结出现的bug<ul><li>if特判条件，能否把所有的情况都考虑到，是否会漏到一些情况，应该优点判断那些情况</li><li>直接对字符串处理是一件愚蠢至极的方法</li><li>迭代产生的bug，大多数都是复用之前的方法导致错误</li></ul></li></ul><h2 id="四、Hack策略">四、Hack策略</h2><p>列举一些hack成功的例子</p><ul><li><p>边界条件</p><ul><li><p>sin((-x)) --&gt; sin(-x)</p></li><li><pre><code class="hljs">1f(x)=cos(cos(cos(cos(x))))sin(sin(cos(cos(cos(cos(cos(cos(dx(f(x)))))))))) --&gt; TLE                 利用cost条件实现TLE<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br><span class="hljs-comment">*  求导因子出现的位置，对特殊的因子求导</span><br><br><span class="hljs-comment">  * ```</span><br>    1<br>    <span class="hljs-built_in">f</span>(x,y) = ((+x))**2+y<br>    -dx(<span class="hljs-built_in">f</span>(y,0))+y<br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="hljs">2f(x,y,z)=x-(y+z)g(x,z,y)=-dz((y-z)**2)-(f(0,-1,+1)-g(x**+0,x**+2,x**01))<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><br>* ```<br>  <span class="hljs-number">2</span><br>  <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-variable">x</span>) = <span class="hljs-title">sin</span>(<span class="hljs-title">cos</span>(<span class="hljs-variable">x</span>))</span><br>  <span class="hljs-function"><span class="hljs-title">g</span>(<span class="hljs-variable">y</span> ) = <span class="hljs-title">dy</span>(<span class="hljs-title">f</span>(<span class="hljs-variable">y</span>))</span><br>  <span class="hljs-function"><span class="hljs-title">g</span>(<span class="hljs-variable">y</span>)</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h2 id="五、心得体会">五、心得体会</h2><pre><code class="hljs">  在第一次和第二次我几乎都没怎么做测试，第三次测试也只是把第二次数据改了改添加了求导因子，然后和室友python对拍，结果就是三次作业都有bug，下周说什么也得把评测机写出来。在写代码的时候尽量保证程序正义性，再结合随机测试数据和评测机才是正道！！   复用之前的方法很容易出bug，接口的实现尤为重要，对于每个方法都需要清楚知道输入限制及方法的作用，迭代之后是否还能接着用。慢工出细活，写OO还是得抽出连续大量的时间，且要长时间专注。递归下降确实好用，但就是感觉缺少了一点面向对象的思想，第一单元感觉就像是数据结构哈哈哈哈。感觉评测没有上学期的OOpre覆盖性强，一个点就好几千上万条数据，bug还得靠互测。</code></pre><p>​</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
