<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OS-lab5</title>
    <link href="/2023/05/22/OS-lab5/"/>
    <url>/2023/05/22/OS-lab5/</url>
    
    <content type="html"><![CDATA[<h1>OS-lab5</h1><p>写在前面，往年的上机实验都是60分就给满，去年因为疫情转为线上，实验总分还送了10分。就是说大佬甚至不用申优就能拿99分。今年exam和extra都是按百分比算分，1分的extra得了80相当于0.8。所以不能完全实现，实现一部分骗个样例分也不错。OS上机终于结束，在之后打算再好好理解一下MOS，内存管理，进程管理，文件系统，Shell和管道都有不太清楚的地，感觉OS一路下来每次都跟CO P7一样抽象。</p><h2 id="上机">上机</h2><h3 id="lab5-1">lab5-1</h3><h4 id="exam">exam</h4><p>lab5-1这部分涉及到读取外设，不用管文件系统。在完成此部分之前建议学习如何从控制台轮询读取输入，如何关闭控制台。</p><p>这次exam还是比较简单，就是读取时钟外设，实现两个函数</p><ul><li>u_int get_time(u_int *us), 返回秒数，微秒通过指针返回</li><li>void usleep(u_int us)，调用此函数实现：读取当前时间，然后休眠至少us微秒。</li></ul><p>需要注意返回的都是无符号数，计算休眠时间时先转换成有符号数（因为涉及到减法）：</p><p>​    int s = (ys2 - ys1) * 1000000;<br>​    int uus = yus2 - yus1<br>​    s + uus 即为休眠时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">u_int <span class="hljs-title function_">get_time</span><span class="hljs-params">(u_int *us)</span><br>&#123;<br>  <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>  u_int rtc = <span class="hljs-number">0x15000000</span>;<br>  u_int time;<br>  syscall_write_dev(&amp;temp, rtc, <span class="hljs-number">4</span>);<br>  syscall_read_dev(&amp;time, rtc + <span class="hljs-number">0x0010</span>, <span class="hljs-number">4</span>);         <span class="hljs-comment">//读取秒</span><br>  syscall_read_dev(us, rtc + <span class="hljs-number">0x0020</span>, <span class="hljs-number">4</span>);            <span class="hljs-comment">//读取微秒</span><br>  <span class="hljs-keyword">return</span> time;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">usleep</span><span class="hljs-params">(u_int us)</span><br>&#123;<br>  <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>  u_int us1;<br>  u_int us2;<br>  u_int s1;<br>  s1 = get_time(&amp;us1);<br>  <span class="hljs-type">int</span> ys1 = (<span class="hljs-type">int</span>)(s1);<br>  <span class="hljs-type">int</span> yus1 = (<span class="hljs-type">int</span>)(us1);<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>  &#123;<br>    u_int s2 = get_time(&amp;us2);<br>    <span class="hljs-type">int</span> ys2 = (<span class="hljs-type">int</span>)(s2);<br>    <span class="hljs-type">int</span> yus2 = (<span class="hljs-type">int</span>)(us2);<br>    <span class="hljs-type">int</span> yus = (<span class="hljs-type">int</span>)(us);<br>    <span class="hljs-type">int</span> s = (ys2 - ys1) * <span class="hljs-number">1000000</span>;<br>    <span class="hljs-type">int</span> uus = yus2 - yus1 - yus;<br>    <span class="hljs-keyword">if</span> ((s + uus) &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br><br>      syscall_yield();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="extra">extra</h4><p>实现一个固态硬盘，普通磁盘如果要覆盖写直接写就可以，但固态硬盘需要先擦除再写，频繁擦除会降低硬盘寿命，这也是为什么固态硬盘寿命较短的原因。为保证各个硬盘块擦除均匀，我们要实现分配系统。（具体题面忘了）,extra只得了80分，没找见bug。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> yinshe[<span class="hljs-number">32</span>];<br><span class="hljs-type">int</span> phmap[<span class="hljs-number">32</span>];<br><span class="hljs-type">int</span> phca[<span class="hljs-number">32</span>];<br><span class="hljs-type">char</span> s[<span class="hljs-number">520</span>];<br><span class="hljs-type">int</span> <span class="hljs-title function_">getlogno</span><span class="hljs-params">(<span class="hljs-type">int</span> phno)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (yinshe[i] == phno)<br>&#123;<br><br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fen</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> min = <span class="hljs-number">114514</span>;<br><span class="hljs-type">int</span> flag = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (phmap[i] == <span class="hljs-number">0</span> &amp;&amp; phca[i] &lt; min)<br>&#123;<br>min = phca[i];<br>flag = i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (min &lt; <span class="hljs-number">5</span>)<br>&#123;<br><span class="hljs-keyword">return</span> flag;<br>&#125;<br><br><span class="hljs-type">int</span> a = flag;<br>flag = <span class="hljs-number">-1</span>;<br>min = <span class="hljs-number">114514</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (phmap[i] == <span class="hljs-number">1</span> &amp;&amp; phca[i] &lt; min)<br>&#123;<br>min = phca[i];<br>flag = i;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> b = flag;<br><span class="hljs-type">void</span> *temp;<br>ide_read(<span class="hljs-number">0</span>, b, temp, <span class="hljs-number">1</span>);<br>ide_write(<span class="hljs-number">0</span>, a, temp, <span class="hljs-number">1</span>);<br>phmap[a] = <span class="hljs-number">1</span>;<br>yinshe[getlogno(b)] = a;<br>ide_write(<span class="hljs-number">0</span>, b, s, <span class="hljs-number">1</span>);<br>phca[b]++;<br>phmap[b] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ssd_init</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>&#123;<br>yinshe[i] = <span class="hljs-number">-1</span>;<br>phmap[i] = <span class="hljs-number">0</span>;<br>phca[i] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">ssd_read</span><span class="hljs-params">(u_int logic_no, <span class="hljs-type">void</span> *dst)</span><br>&#123;<br><span class="hljs-keyword">if</span> (yinshe[logic_no] == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ide_read(<span class="hljs-number">0</span>, yinshe[logic_no], dst, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ssd_write</span><span class="hljs-params">(u_int logic_no, <span class="hljs-type">void</span> *src)</span><br>&#123;<br><span class="hljs-type">int</span> phno;<br><span class="hljs-keyword">if</span> (yinshe[logic_no] == <span class="hljs-number">-1</span>)<br>&#123;<br>phno = fen();<br>yinshe[logic_no] = phno;<br>phmap[phno] = <span class="hljs-number">1</span>;<br>ide_write(<span class="hljs-number">0</span>, phno, src, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><br>phno = yinshe[logic_no];<br>ide_write(<span class="hljs-number">0</span>, phno, s, <span class="hljs-number">1</span>);<br>phca[phno]++;<br>yinshe[logic_no] = <span class="hljs-number">-1</span>;<br>phmap[phno] = <span class="hljs-number">0</span>;<br>phno = fen();<br>yinshe[logic_no] = phno;<br>phmap[phno] = <span class="hljs-number">1</span>;<br>ide_write(<span class="hljs-number">0</span>, phno, src, <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ssd_erase</span><span class="hljs-params">(u_int logic_no)</span><br>&#123;<br><span class="hljs-keyword">if</span> (yinshe[logic_no] == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> phno = yinshe[logic_no];<br>ide_write(<span class="hljs-number">0</span>, phno, s, <span class="hljs-number">1</span>);<br>phca[phno]++;<br>phmap[phno] = <span class="hljs-number">0</span>;<br>yinshe[logic_no] = <span class="hljs-number">-1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="lab5-2">lab5-2</h3><p>主要考文件系统，说实话课下需要自己完成的只是冰山一角，一定要在完成后好好理解一下。fs是文件服务进程处理文件操作请求的函数都放在这个目录下，user/lib里的file.c和fd.c是其他进程的用户接口。这次extra甚至考了tools里的format.c（课下一眼没看，课上看源码看了将近一个小时）</p><h4 id="exam-2">exam</h4><p>file.c中实现的open函数实现打开绝对路径，我们修改实现openat打开某个目录下的相对路径，具体如下，全部对标open，两者几乎一样</p><p>就是在walk_path传入当前目录，从这开始找而不是从根目录。</p><ul><li>file.c 中实现<code>int openat(int dirfd, const char *path, int mode)</code>实现在当前目录（文件操作符为dirfd）下寻找路径为path的文件</li><li>fsipc.c中实现<code>int fsipc_openat(u_int dir_fileid, const char *path, u_int omode, struct Fd *fd)</code>构建你的<code>struct Fsreq_openat *req</code></li><li>fs/serv.c实现<code>void serve_openat(u_int envid, struct Fsreq_openat *rq)</code>并修改serve函数</li><li>fs/fs.c中实现<code>int file_openat(struct File *dir, char *path, struct File **pfile)</code>和<code>int walk_path_at(struct File *par_dir, char *path, struct File **pdir, struct File **pfile, char *lastelem)</code></li></ul><p>看似很麻烦，但其实大部分就是复制粘贴</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// file.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">openat</span><span class="hljs-params">(<span class="hljs-type">int</span> dirfd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> mode)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> *<span class="hljs-title">dir</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> *<span class="hljs-title">fd</span>;</span><br><span class="hljs-type">int</span> r;<br><span class="hljs-keyword">if</span> ((r = fd_lookup(dirfd, &amp;dir)) &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> *<span class="hljs-title">dirfile</span> =</span> (<span class="hljs-keyword">struct</span> Filefd *)dir;<br><span class="hljs-type">int</span> fileid = dirfile-&gt;f_fileid;                  <span class="hljs-comment">//找到当前目录的fileid</span><br>try(fd_alloc(&amp;fd));<br>try(fsipc_openat(fileid, path, mode, fd));<br><span class="hljs-type">char</span> *va;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> *<span class="hljs-title">ffd</span>;</span><br>u_int size, fileid1;<br>va = fd2data(fd);<br>ffd = (<span class="hljs-keyword">struct</span> Filefd *)fd;<br>size = ffd-&gt;f_file.f_size;<br>fileid1 = ffd-&gt;f_fileid;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i += BY2PG)<br>&#123;<br>try(fsipc_map(fileid1, i, va + i));<br>&#125;<br><span class="hljs-keyword">return</span> fd2num(fd);<br>&#125;<br><br><span class="hljs-comment">//fsipc.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsipc_openat</span><span class="hljs-params">(u_int dir_fileid, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, u_int omode, <span class="hljs-keyword">struct</span> Fd *fd)</span><br>&#123;<br>u_int perm;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsreq_openat</span> *<span class="hljs-title">req</span>;</span><br><br>req = (<span class="hljs-keyword">struct</span> Fsreq_openat *)fsipcbuf;<br><br><span class="hljs-comment">// The path is too long.</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(path) &gt;= MAXPATHLEN)<br>&#123;<br><span class="hljs-keyword">return</span> -E_BAD_PATH;<br>&#125;<br>req-&gt;dir_fileid = dir_fileid;<br><span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span> *)req-&gt;req_path, path);<br>req-&gt;req_omode = omode;<br><span class="hljs-keyword">return</span> fsipc(FSREQ_OPENAT, req, fd, &amp;perm);<br>&#125;<br><br><span class="hljs-comment">//serv.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">serve_openat</span><span class="hljs-params">(u_int envid, <span class="hljs-keyword">struct</span> Fsreq_openat *rq)</span><br>&#123;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Open</span> *<span class="hljs-title">pOpen</span>;</span><br><span class="hljs-type">int</span> r;<br><span class="hljs-keyword">if</span> ((r = open_lookup(envid, rq-&gt;dir_fileid, &amp;pOpen)) &lt; <span class="hljs-number">0</span>)      <span class="hljs-comment">//找到当前目录</span><br>&#123;<br>ipc_send(envid, r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">dir</span> =</span> pOpen-&gt;o_file;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> *<span class="hljs-title">ff</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Open</span> *<span class="hljs-title">o</span>;</span><br><br><span class="hljs-comment">// Find a file id.</span><br><span class="hljs-keyword">if</span> ((r = open_alloc(&amp;o)) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>ipc_send(envid, r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// Open the file.</span><br><span class="hljs-keyword">if</span> ((r = file_openat(dir, rq-&gt;req_path, &amp;f)) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>ipc_send(envid, r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// Save the file pointer.</span><br>o-&gt;o_file = f;<br><br><span class="hljs-comment">// Fill out the Filefd structure</span><br>ff = (<span class="hljs-keyword">struct</span> Filefd *)o-&gt;o_ff;<br>ff-&gt;f_file = *f;<br>ff-&gt;f_fileid = o-&gt;o_fileid;<br>o-&gt;o_mode = rq-&gt;req_omode;<br>ff-&gt;f_fd.fd_omode = o-&gt;o_mode;<br>ff-&gt;f_fd.fd_dev_id = devfile.dev_id;<br><br>ipc_send(envid, <span class="hljs-number">0</span>, o-&gt;o_ff, PTE_D | PTE_LIBRARY);<br>&#125;<br><br><span class="hljs-comment">// fs.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">walk_path_at</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *par_dir, <span class="hljs-type">char</span> *path, <span class="hljs-keyword">struct</span> File **pdir, <span class="hljs-keyword">struct</span> File **pfile, <span class="hljs-type">char</span> *lastelem)</span>&#123;<br>     <span class="hljs-type">char</span> *p;<br><span class="hljs-type">char</span> name[MAXNAMELEN];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">dir</span>, *<span class="hljs-title">file</span>;</span><br><span class="hljs-type">int</span> r;<br><br><span class="hljs-comment">// start at the root.</span><br>path = skip_slash(path);<br>file = par_dir;                                         <span class="hljs-comment">//最关键一步</span><br>dir = <span class="hljs-number">0</span>;<br>name[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (pdir) &#123;<br>*pdir = <span class="hljs-number">0</span>;<br>&#125;<br><br>*pfile = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// find the target file by name recursively.</span><br><span class="hljs-keyword">while</span> (*path != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>dir = file;<br>p = path;<br><br><span class="hljs-keyword">while</span> (*path != <span class="hljs-string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>path++;<br>&#125;<br><br><span class="hljs-keyword">if</span> (path - p &gt;= MAXNAMELEN) &#123;<br><span class="hljs-keyword">return</span> -E_BAD_PATH;<br>&#125;<br><br><span class="hljs-built_in">memcpy</span>(name, p, path - p);<br>name[path - p] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>path = skip_slash(path);<br><span class="hljs-keyword">if</span> (dir-&gt;f_type != FTYPE_DIR) &#123;<br><span class="hljs-keyword">return</span> -E_NOT_FOUND;<br>&#125;<br><br><span class="hljs-keyword">if</span> ((r = dir_lookup(dir, name, &amp;file)) &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (r == -E_NOT_FOUND &amp;&amp; *path == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br><span class="hljs-keyword">if</span> (pdir) &#123;<br>*pdir = dir;<br>&#125;<br><br><span class="hljs-keyword">if</span> (lastelem) &#123;<br><span class="hljs-built_in">strcpy</span>(lastelem, name);<br>&#125;<br><br>*pfile = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> r;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (pdir) &#123;<br>*pdir = dir;<br>&#125;<br><br>*pfile = file;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="extra-2">extra</h4><p>实现新的一种文件类型，即链接文件，可以看做是Windows的快捷方式，只不过这种文件内容存的是其指向文件的绝对路径，其指向文件可能还是一个链接文件，但保证最终指向一个普通文件</p><ul><li>修改format.c<ul><li>增加<code>void write_symlink(struct File *dirf, const char *path)</code></li><li>修改主函数，增加分支</li><li>修改write_directory，增加分支</li></ul></li><li>修改open，实现如果当前文件是链接文件，最终要返回最终指向的普通文件</li></ul><p>使用memcpy时一定要注意，目标缓冲区一定要初始化</p><p>即<code>char nextpath[1024] = &quot;\0&quot;;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> mode)</span> &#123;<br><span class="hljs-type">int</span> r;<br><br><span class="hljs-comment">// Step 1: Alloc a new &#x27;Fd&#x27; using &#x27;fd_alloc&#x27; in fd.c.</span><br><span class="hljs-comment">// Hint: return the error code if failed.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> *<span class="hljs-title">fd</span>;</span><br><span class="hljs-comment">/* Exercise 5.9: Your code here. (1/5) */</span><br>    try(fd_alloc(&amp;fd));<br><span class="hljs-comment">// Step 2: Prepare the &#x27;fd&#x27; using &#x27;fsipc_open&#x27; in fsipc.c.</span><br><span class="hljs-comment">/* Exercise 5.9: Your code here. (2/5) */</span><br>    try(fsipc_open(path, mode, fd));<br><span class="hljs-comment">// Step 3: Set &#x27;va&#x27; to the address of the page where the &#x27;fd&#x27;&#x27;s data is cached, using</span><br><span class="hljs-comment">// &#x27;fd2data&#x27;. Set &#x27;size&#x27; and &#x27;fileid&#x27; correctly with the value in &#x27;fd&#x27; as a &#x27;Filefd&#x27;.</span><br><span class="hljs-type">char</span> *va;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> *<span class="hljs-title">ffd</span>;</span><br>u_int size, fileid;<br><span class="hljs-comment">/* Exercise 5.9: Your code here. (3/5) */</span><br>    va = fd2data(fd);<br>    ffd = (<span class="hljs-keyword">struct</span> Filefd *)fd;<br>size = ffd-&gt;f_file.f_size;<br>fileid = ffd-&gt;f_fileid;<br><span class="hljs-comment">// Step 4: Alloc pages and map the file content using &#x27;fsipc_map&#x27;.</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i += BY2PG) &#123;<br><span class="hljs-comment">/* Exercise 5.9: Your code here. (4/5) */</span><br>        try(fsipc_map(fileid,i,va + i));<br>&#125;<br><br><span class="hljs-comment">// Step 5: Return the number of file descriptor using &#x27;fd2num&#x27;.</span><br><span class="hljs-comment">/* Exercise 5.9: Your code here. (5/5) */</span><br><span class="hljs-keyword">while</span>(ffd-&gt;f_file.f_type == <span class="hljs-number">2</span>)&#123;<br>           <span class="hljs-type">char</span> next[<span class="hljs-number">1024</span>] = <span class="hljs-string">&quot;\0&quot;</span>;<br>   file_read(fd, next, ffd-&gt;f_file.f_size, <span class="hljs-number">0</span>);<br>   <span class="hljs-keyword">return</span> open(next, mode);<br>&#125;<br>    <span class="hljs-keyword">return</span> fd2num(fd);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">write_symlink</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *dirf, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">target</span> =</span> create_file(dirf);<br><span class="hljs-comment">// Your code here: 使用 readlink() 函数读取链接文件指向的路径，将其写入到下一个可用的磁盘块</span><br><span class="hljs-type">char</span> nextlink[<span class="hljs-number">1024</span>] = <span class="hljs-string">&quot;\0&quot;</span>;<br>readlink(path, nextlink, <span class="hljs-number">1024</span>);<br><span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span> *)disk[nextbno].data, nextlink, <span class="hljs-built_in">strlen</span>(nextlink));<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *fname = <span class="hljs-built_in">strrchr</span>(path, <span class="hljs-string">&#x27;/&#x27;</span>);<br><span class="hljs-keyword">if</span> (fname)<br>&#123;<br>fname++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>fname = path;<br>&#125;<br><span class="hljs-comment">// Your code here: 设置链接文件的文件名、大小（指向路径的字符串的长度）、类型属性</span><br>target-&gt;f_size = <span class="hljs-built_in">strlen</span>(nextlink);<br><span class="hljs-built_in">strcpy</span>(target-&gt;f_name, fname);<br>target-&gt;f_type = FTYPE_LNK;<br>save_block_link(target, <span class="hljs-number">0</span>, next_block(BLOCK_DATA));<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-keyword">static_assert</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> File) == BY2FILE);<br>init_disk();<br><br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>)<br>&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: fsformat &lt;img-file&gt; [files or directories]...\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; argc; i++)<br>&#123;<br><span class="hljs-type">char</span> *name = argv[i];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">stat_buf</span>;</span><br><span class="hljs-type">int</span> r = lstat(name, &amp;stat_buf);<br>assert(r == <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (S_ISDIR(stat_buf.st_mode))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;writing directory &#x27;%s&#x27; recursively into disk\n&quot;</span>, name);<br>write_directory(&amp;super.s_root, name);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISREG(stat_buf.st_mode))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;writing regular file &#x27;%s&#x27; into disk\n&quot;</span>, name);<br>write_file(&amp;super.s_root, name);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISLNK(stat_buf.st_mode))                     <span class="hljs-comment">//增加的分支</span><br>&#123;<br>write_symlink(&amp;super.s_root, name);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;&#x27;%s&#x27; has illegal file mode %o\n&quot;</span>, name, stat_buf.st_mode);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br><br>flush_bitmap();<br>finish_fs(argv[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">write_directory</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *dirf, <span class="hljs-type">char</span> *path)</span><br>&#123;<br>DIR *dir = opendir(path);<br><span class="hljs-keyword">if</span> (dir == <span class="hljs-literal">NULL</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;opendir&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">pdir</span> =</span> create_file(dirf);<br><span class="hljs-built_in">strncpy</span>(pdir-&gt;f_name, basename(path), MAXNAMELEN - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (pdir-&gt;f_name[MAXNAMELEN - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;file name is too long: %s\n&quot;</span>, path);<br><span class="hljs-comment">// File already created, no way back from here.</span><br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>pdir-&gt;f_type = FTYPE_DIR;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> dirent *e; (e = readdir(dir)) != <span class="hljs-literal">NULL</span>;)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(e-&gt;d_name, <span class="hljs-string">&quot;.&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(e-&gt;d_name, <span class="hljs-string">&quot;..&quot;</span>) != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">char</span> *buf = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-built_in">strlen</span>(e-&gt;d_name) + <span class="hljs-number">2</span>);<br><span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%s/%s&quot;</span>, path, e-&gt;d_name);<br><span class="hljs-keyword">if</span> (e-&gt;d_type == DT_DIR)<br>&#123;<br>write_directory(pdir, buf);<br>&#125; <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e-&gt;d_type == DT_LNK)                      <span class="hljs-comment">//增加的分支</span><br>&#123;<br>write_symlink(pdir, buf);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>write_file(pdir, buf);<br>&#125;<br><span class="hljs-built_in">free</span>(buf);<br>&#125;<br>&#125;<br>closedir(dir);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="实验报告">实验报告</h2><h3 id="一、Thinking">一、Thinking</h3><h4 id="Thinking-5-1-如果通过-kseg0-读写设备，那么对于设备的写入会缓存到-Cache-中。这是-一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做-这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和-IDE-磁盘）的操作会-有差异吗？可以从缓存的性质和缓存更新的策略来考虑。">Thinking 5.1 如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是 一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做 这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会 有差异吗？可以从缓存的性质和缓存更新的策略来考虑。</h4><p>举个例子，比如往控制台写入0123，此时0123会缓存到控制台，此时从控制台读入字符串，就会读到0123。不同类型设备的错误可能不一样。这是因为cache中存储的内容只有被替换时，才会写回到设备。</p><h4 id="Thinking-5-2-查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制-块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？">Thinking 5.2 查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制 块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？</h4><p>每个磁盘块大小为4KB，而每个文件控制块被char f_pad对齐为256B，所以可以存储16个文件控制块</p><p>可看做一个磁盘块都用来存储文件磁盘块号，最多有1024个磁盘块，大小为1024 * 4KB = 4MB</p><p>一个目录最多有1024个磁盘块，+最多有1024 * 16 = 16384个文件</p><h4 id="Thinking-5-3-请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最-大磁盘大小是多少？">Thinking 5.3 请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最 大磁盘大小是多少？</h4><p>DISKMAX为0x40000000，所以满足最大的磁盘大小为1GB</p><h4 id="Thinking-5-4-在本实验中，fs-serv-h、user-include-fs-h-等文件中出现了许多宏定义，-试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。">Thinking 5.4 在本实验中，fs/serv.h、user/include/fs.h 等文件中出现了许多宏定义， 试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。</h4><p><strong>serv.h</strong></p><p>PTE_DIRTY，内存可以看做CPU和disk之间的cache，所以PTE_DIRTY代表物理页所对应的磁盘块内容是否被更改了</p><p><strong>fs.h</strong></p><p>NDIRECT 10 ，直接索引的数量</p><p>NINDIRECT (BY2BLK / 4) 间接索引的数量</p><p>MAXFILESIZE (NINDIRECT * BY2BLK) 文件最大大小</p><p>BY2FILE 256  文件控制块大小</p><h4 id="Thinking-5-5-在-Lab4“系统调用与-fork”的实验中我们实现了极为重要的-fork-函数。那-么-fork-前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上-编写一个程序进行验证。">Thinking 5.5 在 Lab4“系统调用与 fork”的实验中我们实现了极为重要的 fork 函数。那 么 fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上 编写一个程序进行验证。</h4><p>会共享，fork时，会把文件操作符复制过去。但是并不共享，相当于父子进程分别打开同一个文件，可以独立修改文件内容。</p><h4 id="Thinking-5-6-请解释-File-Fd-Filefd-结构体及其各个域的作用。比如各个结构体会在哪-些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要-求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。">Thinking 5.6 请解释 File, Fd, Filefd 结构体及其各个域的作用。比如各个结构体会在哪 些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要 求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。</h4><ul><li>Fd当从文件服务进程传回时，其可被强制转换类型，得到文件控制块</li><li>f_fileid对应着文件服务进程中一个open结构体，得到对应关系</li><li>File对应的是磁盘上的物理实体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> &#123;</span> u_int fd_dev_id;  <span class="hljs-comment">//设备id</span><br>​           u_int fd_offset;  <span class="hljs-comment">//fd所指向地址</span><br>            u_int fd_omode;   <span class="hljs-comment">//文件操作类型</span><br>            &#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> &#123;</span><br>               <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> <span class="hljs-title">f_fd</span>;</span>      <span class="hljs-comment">//文件操作符</span><br>               u_int f_fileid;      <span class="hljs-comment">//文件id</span><br>               <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">f_file</span>;</span>  <span class="hljs-comment">//文件控制块</span><br> &#125;;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> &#123;</span><br><span class="hljs-type">char</span> f_name[MAXNAMELEN]; <span class="hljs-comment">// filename</span><br><span class="hljs-type">uint32_t</span> f_size; <span class="hljs-comment">// file size in bytes</span><br><span class="hljs-type">uint32_t</span> f_type; <span class="hljs-comment">// file type</span><br><span class="hljs-type">uint32_t</span> f_direct[NDIRECT];<br><span class="hljs-type">uint32_t</span> f_indirect;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f_dir</span>;</span> <span class="hljs-comment">// the pointer to the dir where this file is in, valid only in memory.</span><br><span class="hljs-type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="hljs-number">3</span> + NDIRECT) * <span class="hljs-number">4</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)];<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h4 id="Thinking-5-7-图5-7中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们-的操作系统是如何实现对应类型的进程间通信的。">Thinking 5.7 图5.7中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们 的操作系统是如何实现对应类型的进程间通信的。</h4><img src="/2023/05/22/OS-lab5/%E6%97%B6%E5%BA%8F%E5%9B%BE.png" class><p>实线箭头为同步消息</p><p>虚线箭头为同步返回消息</p><p>首先操作系统创建用户进程和文件服务进程，文件服务进程完成初始化可以工作，开始轮询不断接受用户进程的文件请求。用户进程不同操作，通过发送信息到文件服务进程，请求服务，等待文件服务进程完成相应操作并返回结果。</p><h3 id="二、实验难点">二、实验难点</h3><h4 id="虚拟地址">虚拟地址</h4><p>外设对应的地址属于kesg1的地址，当用户进程需要读写外设时，需要通过系统调用来完成。内核态访问用户空间的地址会通过当前进程的标识符访问TLB进而得到物理地址。而在之前的lab3-extra中，之所以需要通过用户虚拟地址转换为内核态虚拟地址是因为指令所在的页面权限没有可写权限。并且用户地址范围可能是跨页的，并且可能是缺页的，所以不能通过内核态地址访问。</p><h4 id="文件操作">文件操作</h4><p>我们可以把内存看做磁盘和CPU之间的cache，是通过将要访问的文件映射到内存中，修改内存，最终修改结果又会返回到磁盘中。处理文件操作是由文件服务进程和用户进程之间的通信完成的，用户进程将需要进行的操作的信息发送到文件服务进程，并将文件映射到用户进程的地址中。如果修改文件内容，对应内存页面会有PTE_DIRTY标志，会把修改写入磁盘。</p><h4 id="Fd，-FileFd等对应的结构体">Fd， FileFd等对应的结构体</h4><p>在思考题已给出解释</p><h3 id="三、实验体会">三、实验体会</h3><p>lab5在代码提示下补全还是很容易的。但文件操作具体的实现却很复杂，从5.9到5.13用户接口的实现，我们仅仅完成很小的一部分。具体过程需要自己看源码理解。在最初拉取分支的时候看到fs目录甚是困惑，管理文件为什么放到了用户态中，其实这符合微内核的思想。但同时也有疑问，是否应该给用户进程这么大的权限。从打开一个文件到更改并保存关闭，这之间各个函数的调用和进程之间的通信非常复杂，需要理解清楚。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OO第三单元总结</title>
    <link href="/2023/05/21/OO%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/2023/05/21/OO%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1>OO第三单元总结</h1><h2 id="一、测试">一、测试</h2><p>本单元基于JML进行规格化设计，并且针对实现的代码进行测试。由于每个要实现的功能和方法的规格和作用都已明确给出，所以在具体实现方面着重考虑数据结构和方法复杂度。众所周知，中测就是闹着玩的，真测试还得靠自己。</p><h3 id="黑箱、白箱测试">黑箱、白箱测试</h3><ol><li><p>黑箱测试，着重测试软件的功能需求，是在程序接口上进行的测试。对于每次作业，就是评测机通过大量测试数据力求达到高覆盖性的测试。由于只能看到输入与输出，其内部运行结构我们并不关心，所以是黑箱测试。</p></li><li><p>白箱测试，逻辑测试，穷举路径测试。</p></li></ol><ul><li>针对模块中所有的方法路径都需要进行测试</li><li>所有逻辑值true和flase都需要进行测试</li><li>数据结构的测试</li><li>测试数据在合法范围内都需要覆盖测试</li></ul><p>比如我们三次作业中都有针对特定方法的OKTest，在验证OKTest的正确性时，对于每一个逻辑值都要测试true和flase，基于此生成的         测试数据就是白盒测试。</p><ol start="3"><li>此外单元测试是指对软件中最小的可测试单元的测试，在作业中OKTest就是单元测试；将多个模块耦合进行集成测试，例如作业中类之间方法调用测试；针对性能进行压力测试，在作业中CPU时间要求在15s内；当优化或修改代码后，要进行回归测试保证修改没有带来新的错误。</li></ol><h3 id="测试数据构造">测试数据构造</h3><ul><li>通过缩小id范围，增加数据数量来保证每个异常都能被触发</li><li>对边界数据的测试，比如测试group的人数</li><li>对于涉及到动态维护且复杂度较大的指令，加强测试。比如mr操作可能涉及到并查集的更改，可以先ap500条，然后10000条mr，测试CPU运行时间。</li></ul><h2 id="二、架构设计">二、架构设计</h2><h3 id="类图（以第三次作业为例）">类图（以第三次作业为例）</h3><pre><code class=" mermaid">classDiagramclass MyPerson&#123;      -int id      -String name      -int age      -ArrayList&lt;Message&gt; messages      -HashMap&lt;Integer, Integer&gt; value      -Integer bestAcqId      -Integer bestAcq      -int money      -int socialValue      +MyPerson()      +int getId()      +String getName()      +int getAge()      +boolean equals()      +boolean isLinked()      +int queryValue()      +void setValue()      +void addSocialValue()      +int getSocialValue()      +List&lt;Message&gt; getMessages()      +List&lt;Message&gt;getReceivedMessages()      +void clerNotices()      +void removeAcq()      +void addMessage()      +Integer getBestAcqId()      +int compareTo()      +void addMoney()      +int getMoney()      -void updateBest()&#125;class MyNetwork&#123;      -HashMap&lt;Integer, Person&gt; people      -HashMap&lt;Integer, Group&gt; groups      -HashMap&lt;Integer, Message&gt; messages      -HashMap&lt;Integer, Integer&gt; emojis      -Graph graph      +MyNetwork()      +boolean contains()      +Person getPerson()      +void addPerson()      +void addRelation()      +void modifyRelation()      +void modifyGroupRelation()      +void removeRelation()      +int queryValue()      +boolean isCircle()      +int queryBlockSum()      +int queryTripleSum()      +void addGroup()      +Group getGroup()      +void addToGroup()      +int queryGroupValueSum()      +int queryGroupAgeVar()      +void delFromGroup()      +boolean containsMessage()      +void addMessage()      +Message getMessage()      +void sendMessage()      +int querySocialValue()      +List&lt;Message&gt; queryReceiveMessages()      +int queryBestAcquaintance()      +int queryCoupleSum()      +void storeEmojiId()      +boolean containsEmojiId()      +int queryMoney()      +int queryPopularity()      +void deleteColdEmoji()      +void clearNotices()      +int queryLeastMoments()      +int deleteColdEmojiOKTest()&#125;class MyMessage&#123;      -int id      -int socialValue      -int type      -Person person1      -Person person2      -Group group      +MyMessage()      +int getType()      +int getSocialValue()      +int getId()      +Person getPerson1()      +Person getPerson2()      +Group getGroup()      +boolean equals()&#125;class MyGroup&#123;      -int id      -int valueSum      -int ageSum      -ArrayList&lt;Person&gt; people      +MyGroup()      +int getId()      +void addAllSocialValue()      +void addAllMoney()      +boolean equals)()      +void addPerson()      +void addValue()      +boolean hasPerson()      +int getValueSum()      +void modifyRelation()      +int getAgeMean()      +int getAgeVar()      +void delPerson()      +int getSize()&#125;class Graph&#123;      -HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; uniComponent      -HashMap&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; triples      -HashMap&lt;Integer, HashMap&lt;Integer, Boolean&gt;&gt; isUsefuls      -int blockSum      +void addPerson()      +void addRelation()      +void modifyRelation()      +void addTri()      +void merge()      +boolean isCircle()      +int queryTriSum()      +int queryBlockSum()      +void removeRel()      +int queryLeastMoments()&#125;class MyEmojiMessage&#123;      -int emojiId      +MyEmojiMessage()&#125;class MyRedEnvelopeMessage&#123;      -int money      +MyRedEnvlopeMessage()&#125;MyNetwork --&gt; MyPerson : containsMyNetwork --&gt; MyMessage : containsMyNetwork --&gt; MyGroup : containsMyNetwork --&gt; Graph : containsMyMessage --&gt; MyEmojiMessage : extendsMyMessage --&gt; MyRedEnvelopeMessage : extends</code></pre><h3 id="图模型数据结构">图模型数据结构</h3><p>本单元涉及较难实现的部分有最大联通块的数量、三元环的数量、循环路径数量，其中最大联通块的数量动态维护。</p><h4 id="并查集实现动态维护最大联通块的数量">并查集实现动态维护最大联通块的数量</h4><p>此部分我没有使用建树的方法，维护策略如下</p><pre><code class=" mermaid">graph TBA1(操作)A1 --加关系--&gt; B1A1 --删关系--&gt; C1subgraph 加关系B1 --- B2B1 --- B3B2 --&gt; B4 B3 --将所在的两个连通块融合--&gt; B5B1&#123;判断两人是否已在同一连通块&#125;B2[在]B3[不在]B4[将此关系标记为无用关系]B5[blockSum--]endsubgraph 删关系C1 --- C2C2 --&gt; C3C1 --&gt; C4C4 --&gt; C5C5 --&gt; C6C6 --&gt; C7C7 --&gt; B1C1&#123;判断此关系类型&#125;C2[无用关系]C3[直接删去]C4[有用关系]C5[记录此联通块的所有边]C6[将联通块的所有边变为孤立点]C7[重新加边]end</code></pre><h4 id="有向图查询三元环数量">有向图查询三元环数量</h4><p>将所有关系记为id较小的人指向id大的人的出边，所有三元环都有如下结构：</p><pre><code class=" mermaid">graph LRid1 --e12--&gt; id2id2 --e23--&gt; id3id1 --e13--&gt; id3id1((p1))id2((p2))id3((p3))</code></pre><p>算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Person p1 : people)&#123;            <span class="hljs-comment">//遍历所有人</span><br>    <span class="hljs-keyword">for</span>(edge e12 : p1.edges)&#123;       <span class="hljs-comment">//遍历所有出边</span><br>        <span class="hljs-keyword">for</span>(edge e23 : p2.edges)&#123;<br>            <span class="hljs-keyword">if</span>(p1.contains(e13))&#123;<br>               tripleSum++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Dijkstra记录最短路径和次短路径维护循环路径">Dijkstra记录最短路径和次短路径维护循环路径</h4><p>借鉴评论区大佬的算法，感觉很巧妙，只需要一次Dijkstra就可以得到答案。</p><h2 id="三、性能问题">三、性能问题</h2><h4 id="并查集性能">并查集性能</h4><p>由于我使用HashSet存储一个联通块中的所有人的id，当merge联通块的时候需要操作很多次，远不如建树方便。最初删关系的时候由于直接将所有边（除删去的边）重新加入。在本地对拍的时候，我的运行时间常常是同学的10倍。<strong>解决方法</strong>：在加关系的时候标记边的类型</p><ul><li>两个点已经联通，删去此边没有影响，所以标记为无用边</li><li>没有联通，将次边记为有用边</li></ul><p>所以只有有用边才需要重新加边操作，无用边可直接删去。优化完运行时间变为建树的两倍</p><h4 id="循环路径">循环路径</h4><p>第三次作业qlm强测CTLE，主要是mr性能一般，并且Dijkstra没有用优先队列优化。</p><h4 id="规格与实现分离">规格与实现分离</h4><p>在第一次作业实现过程中，我总是被JML的规格所束缚。但在后续过程中我逐渐认识到，JML只是一个约束条件，在满足规格的条件下，具体实现越简洁越好。比如在MyPerson中JML维护了Persons和Values两个数组分别存放熟人和熟人的亲密度，但其实一个HashMap就够了。所以总结下来，JML就像是规则，在不违背规则的情况下，任何实现方法都是正确的。除此之外，JML就像是项目的维护手册，具体实现千差万别，理解起来很难，但阅读JML能很清晰的理解这部分功能是什么，使用了什么数据结构，以及在后续优化维护中要遵守哪些规则。</p><p>在具体实现的过程中，首先将JML翻译为自然语言，然后选择合适的数据结构和算法去实现。</p><h2 id="四、OK测试">四、OK测试</h2><p>对于OK测试，我认为是在复杂方法中验证正确性的办法，对于我们作业中的OKTest也只能保证调用方法前后保证约束条件。但是对于invariant和constraint等约束，就会变得相当复杂。而且就第二次、第三次作业的OKTest实现起来并不比测试的方法好实现多少。以至于还要对OKTest再进行测试。但不可否认，OKTest可以保证方法严格符合JML的规格。</p><p>对于这方面的建议，我觉得可以真正让OKTest去测试我们实现的方法，每次调用该方法时都会自动进行OKTest，达到自检的效果。</p><h2 id="五、体会">五、体会</h2><p>本单元中最困难的部分不是根据JML规格去实现方法，而是对于数据结构和算法的选择，所谓1000个读者心中有1000个哈莫雷特。很多时候好不容易实现自己的算法，一跑起来发现好慢，又懒得不想重构，只能小修小改结果杯水车薪。其次对于JML，有些方面它能很精确精准的去约束，但有些时候却比自然语言繁琐很多很多，明明一句话就能讲清楚的事情，却要花上很大篇幅的JML去实现。可能在最新的JML中有更高级更简洁的表达吧。总体上来说通过这三次作业，对于如何根据规格进行实现有了很好的理解，掌握了一些算法。但是毕竟不是站在架构师的角度去想，所以在如何在宏观上去实现规格，进行设计还有很长的路要走。有的时候我们不能只闷头实现，也要抬头去想想如何设计吧。</p>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OO</tag>
      
      <tag>总结</tag>
      
      <tag>JML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-lab4</title>
    <link href="/2023/05/13/OS-lab4/"/>
    <url>/2023/05/13/OS-lab4/</url>
    
    <content type="html"><![CDATA[<h1>OS-lab4</h1><h2 id="上机">上机</h2><h3 id="lab4-1">lab4-1</h3><h4 id="exam">exam</h4><p>发现这届课程组确实很贴心，担心大家过不了exam，每次都给伪代码。lab3上机要自己实现异常处理函数，lab4是实现系统调用。这次exam特别特别简单（尤其还给伪代码，想错都难），实现进程组通讯。</p><h4 id="extra">extra</h4><p>实现父进程给所有的后代进程（子进程、子子进程、…），可以在用户态实现，也可以写新的系统调用。</p><p>要遍历所有的后代进程可以用dfs，我是在用户态实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ipc_broadcast</span><span class="hljs-params">(u_int val, <span class="hljs-type">void</span> *srcva, u_int perm)</span><br>&#123;<br>dfs(syscall_getenvid(), val, srcva, perm);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(u_int id, u_int val, <span class="hljs-type">void</span> *srcva, u_int perm)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (envs[i].env_status != ENV_FREE &amp;&amp; envs[i].env_parent_id == id &amp;&amp; envs[i].env_parent_id!=<span class="hljs-number">0</span>)<br>&#123;   debugf(<span class="hljs-string">&quot;i&#x27;m in\n&quot;</span>);<br>dfs(envs[i].env_id, val, srcva, perm);<br>ipc_send(envs[i].env_id, val, srcva, perm);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>md气死我了，我 <code>dfs(syscall_getenvid(), val, srcva, perm);</code>调用syscall_getenvid的时候没加括号，结果相当于传的是syscall_getenvid这个函数的地址，气死了，气死了，到最后也没找出来bug</p><h3 id="lab4-2">lab4-2</h3><h4 id="exam-2">exam</h4><p>实现父进程，阻塞所有的后代进程。准确来说，父进程申请一个信号量，可以最多阻塞n个进程，然后后代进程会阻塞，当阻塞的进程数达到n的时候，解除阻塞，同时信号量失效。</p><p>保证</p><ul><li>只有一个根进程，其他都是后代进程，所以我们的信号量可以直接定义一个全局变量，但如果有多个父进程，就需要把信号量设成进程的属性，在fork的时候父进程把它传给子进程</li><li>只会进行一次申请信号量，保证先申请，才会fork</li></ul><p>我的阻塞实现在用户态，首先在ipc.c中定义<code>void barrier_alloc(int n) </code>,<code>void barrier_wait(void)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">barrier_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>       syscall_barrier(<span class="hljs-number">0</span>, n);<br><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">barrier_wait</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>        <span class="hljs-type">int</span> r;<br>syscall_barrier(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">while</span>((r = syscall_barrier(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;<br>            syscall_yield();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_barrier</span><span class="hljs-params">(<span class="hljs-type">int</span> op, <span class="hljs-type">int</span> sum)</span><br>&#123;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">0</span>)             <span class="hljs-comment">// 申请</span><br>&#123;<br>ba = sum;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>)            <span class="hljs-comment">//try_wait</span><br>&#123;<br>ba--;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)            <span class="hljs-comment">// 查询</span><br>&#123;<br><span class="hljs-keyword">if</span> (ba &lt;= <span class="hljs-number">0</span>)<br>&#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但其实我的实现是错的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">barrier_wait</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>        <span class="hljs-type">int</span> r;<br>syscall_barrier(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);          <span class="hljs-comment">//如果执行完这一句之后时间片用完了，切换下一个进程，会出问题</span><br><span class="hljs-keyword">while</span>((r = syscall_barrier(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;<br>            syscall_yield();<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">barrier_wait</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>        <span class="hljs-type">int</span> r;        <br><span class="hljs-keyword">while</span>((r = syscall_barrier()) != <span class="hljs-number">0</span>)&#123;      <span class="hljs-comment">//这样才是正确的</span><br>            syscall_yield();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实验报告">实验报告</h2><h3 id="一、thinking">一、thinking</h3><h3 id="thinking-4-1">thinking 4.1</h3><ul><li>k0寄存器在MIPS规范中是留给内核操作的，保存现场的时候，对于状态寄存器可以用k0寄存器做最中介进行传递</li><li>如果切换内核态的时候没有修改a0-a3应该是可以访问的，但do_syscall传递了tf这个参数，会修改寄存器的值，所以不能</li><li>do_syscall 的时候我们保存了系统调用前的现场，按照SAVEALL的规格，便可以找到传递的参数</li><li>4<ul><li>EPC+=4，返回到系统调用的下一条指令</li><li>如果系统调用号不存在，通过修改v0返回错误值</li></ul></li></ul><h3 id="thinking-4-2">thinking 4.2</h3><p>进程号是独一无二的，801和001返回的是同一个进程块，而001是非法的，所以必须判断一下</p><h3 id="thinking-4-3">thinking 4.3</h3><p>envid2env函数中，如果进程号为0，则返回当前进程块</p><h3 id="thinking-4-4">thinking 4.4</h3><p>C，子进程并没有调用fork，但其调度时返回的现场和父进程相同，除了返回值是0</p><h3 id="thinking-4-5">thinking 4.5</h3><p>USTACKTOP以上的用户空间不能映射，包括每个进程的页表和页目录，每个进程都不一样。</p><p>pages，envs在进程申请的时候进行了映射，也不需要</p><h3 id="thinking-4-6">thinking 4.6</h3><ul><li>vpd和vpt是页目录和页表的基地址，我们取某个页表项的时候可以vpt[index]即可</li><li>进程申请的时候完成了页表的自映射</li><li>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V;</li><li>由上述自映射我们发现，我们只有有效位，并没有PTE_D，所以不能修改</li></ul><h3 id="thinking-4-7">thinking 4.7</h3><p>真正的异常处理函数在用户空间，我们必须保证在异常处理完之后回到异常发生的现场</p><p>如果有多个异常进程，如果保存的现场都在内核态同一个位置，可能会出差错，保存在用户空间解决了这个问题</p><h3 id="thinking-4-8">thinking 4.8</h3><p>更符合微内核的设计，能在用户空间处理的问题就在用户空间处理，但是在COW处理的过程中，进行了多次系统调用，为什么不在一次系统调用中完成呢，切换内核态不是很大的开销吗？</p><h3 id="thinking-4-9">thinking 4.9</h3><p>我们在exofork系统调用中，已经设置了子进程的写入异常函数，所以应在exofork之前就进行set_tlb_mod_entry系统调用</p><h3 id="二、实验难点分析">二、实验难点分析</h3><h3 id="1-系统调用是特殊的异常">1. 系统调用是特殊的异常</h3><p>都是保存现场进入特定的异常处理函数do_syscall，然后根据传进来的系统调用号再进入特定的系统调用函数。除此，系统调用并不会切换进程，可以理解为用户程序执行了一段内核的代码</p><h3 id="2-envid2env">2. envid2env</h3><p>了解创建系统调用号的过程，确保了所有的进程的进程号都不同，所以才有ENVX这个宏。在envid2env中我们特地检查了e的进程id是否和传进来的参数一样，若一样则没问题。如果不一样，确实会有不一样的情况：801和001这两个返回的进程块一样，但001的进程id是非法的。</p><h3 id="3-进程通信">3. 进程通信</h3><p>在try_send系统调用中，我一开始使用了sys_mem_map函数，这样是不对的，因为sys_mem_map中envid2env传入了检查位。</p><h3 id="4-写入异常函数">4. 写入异常函数</h3><p>写入异常的函数在用户空间中，所以处理完异常后需要恢复现场。</p><p>COW机制确保了父子进程能够最大共享数据</p><h3 id="三、实验感想">三、实验感想</h3><ul><li>总的来说，lab4的难度又有提升，工作量很大，需要在内核代码和用户代码来回切换</li><li>初始了进程通信和fork，明白了简化的实现机制，只有先理解了简单的机制，才能有优化提升的空间，在进程尝试发消息的时候一直处于轮询状态，这样很浪费资源</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>lab4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OO第二单元总结</title>
    <link href="/2023/04/17/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/17/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1>OO 第二单元总结</h1><p>本文为OO 第二单元电梯作业总结，本单元主要是掌握多线程和线程安全。三次作业总的架构类似，可分为输入线程、调度线程、电梯线程。三次作业的增量迭代如下</p><ul><li>第五次作业<ul><li>六部电梯</li></ul></li><li>第六次作业<ul><li>可选择增加电梯，电梯的初始属性可变</li><li>维修电梯，将维修电梯的乘客重新安排</li></ul></li><li>第七次作业<ul><li>新增电梯增加可达性、</li><li>信号量的使用</li></ul></li></ul><h2 id="一、同步块和锁">一、同步块和锁</h2><p>由于我的架构还算完善，所以每次增量较为容易，在第五次作业中使用的java语言特性synchronized，所以在后续中并没有使用读写锁等更符合本单元作业的方法。</p><h3 id="1-同步块和锁的选择">1.同步块和锁的选择</h3><p>我选择的是修饰方法，这样避免修饰代码块从而效率更高。同步块出现的原因是因为不同线程可能同时对一个对象进行读写，因此判断哪些代码需要放到同步块中，只需看一下不同线程对哪些共有对象进行了读写。有以下三种情况：</p><ul><li>读读<ul><li>一定不会造成线程安全</li></ul></li><li>读写<ul><li>具体分析<ul><li>调度器线程模拟电梯运行的时候，需要读取电梯当前楼层状态不需要加锁，避免了当前电梯所在线程在sleep从而被阻塞</li><li>总的请求表WaitQueue的getEnd和setEnd是需要加锁的，避免了调度器线程读到没有结束但同时输入线程刚好结束，造成调度器一直等待没有被唤醒</li></ul></li></ul></li><li>写写<ul><li>一定要加锁</li></ul></li></ul><img src="/2023/04/17/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/1.png" class><p>由上图和上述策略，我们知道同步重点在总的请求表和各个电梯的请求表，也就是对象锁</p><h3 id="2-避免死锁、轮询、无效notify">2. 避免死锁、轮询、无效notify</h3><p>死锁的出现是由于下列情况造成，当然在我的架构中只需要判断同步方法中是否又调用了其他对象的同步方法即可（并不存在）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aMethod</span><span class="hljs-params">()</span>&#123;<br>       b.bMethod();<br>   &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bMethod</span><span class="hljs-params">()</span>&#123;<br>       a.aMethod();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在本单元作业中出现CTLE的原因可能是轮询和死循环，要注意线程的终止条件和wait条件，避免出现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a1Method</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">try</span>&#123;<br>          wait();<br>      &#125;<span class="hljs-keyword">catch</span>()&#123;<br>          <br>      &#125;<br>       notifyAll();<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a2Method</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">try</span>&#123;<br>          wait();<br>      &#125;<span class="hljs-keyword">catch</span>()&#123;<br>          <br>      &#125;<br>       notifyAll();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>避免无效notify，例如，WaitQueue在等待时，只有加请求和setEnd的时候notify</p><h2 id="二、调度">二、调度</h2><p>在往届性能评定中并没有电量这一指标，也就是说只要能把人越快送到越好。在考虑到电量之后就需要调度器的设计。以第七次作业为例调度器的中心工作：从总表中读取请求并处理，如果是乘客请求进行模拟，通过策略选择要把此请求放到哪个电梯</p><h3 id="1-调度器模拟">1.调度器模拟</h3><p>对于一个请求，我们把它分别放到每一个电梯中，并模拟这种情况的耗时，只需要把原来电梯中所有的sleep换成time++即可，次过程在NightElelvator类中night方法返回把当前表中所有乘客送完总耗时，假如有6部电梯，我们一共需要模拟12次，6（电梯数量）* 2（加此请求和不加此请求）。</p><p>前两次作业中，为了加快模拟速度，我为每一部电梯模拟加此请求和不加此请求开了一个线程，但是在第七次作业却报了OutOfMeomory线程开太多了，虽然RAM用的远远少于限制，第八次作业我又改成了并行化</p><h3 id="2-调度器策略">2.调度器策略</h3><p>本质都是贪心思想，仅作出在当前情况下的最优解</p><ul><li>第五次作业我用的是电梯运送此乘客所花费的最小值，这样考虑的是用电量和运送时间，即模拟把这个请求加到此电梯队列中所花费的时间减去不加此请求所花费的时间</li><li>第六次第七次我用的是所有电梯结束的最短时间，考虑的是乘客等待时间和电梯总体运行时间，即模拟把此请求放到某一部电梯，它和其他电梯运行的结束时间，然后去最短的结束时间</li><li>第七次中我用了迪杰斯塔拉算法，把11层看成11个点，然后求最短路径，然后从这条路径从后往前找到第一个能从起点直达终点的中间点，用图做的话，可以自定义距离，比如我有一个请求从1楼到4楼，无法直达，可选1-2-4或1-3-4，但1-3和3-4的电梯数量更多，因此选择第二条路径，然后用第二种策略模拟。本次作业距离定义：$ dis = $</li></ul><p>在第五第六次作业性能分中这两种策略差不多，第七次中应该是第二种更好。</p><h2 id="三、架构">三、架构</h2><h3 id="1-UML类图-以第三次为例">1.UML类图(以第三次为例)</h3><pre><code class=" mermaid">classDiagramMain --&gt; InputThread : startMain --&gt; Schedule : startMain --&gt; ElevatorThread : startElevatorThread --&gt; Elevator : runInputThread --&gt; WaitQueue : addRequestSchedule --&gt; WaitQueue : getRequestSchedule --&gt; RequestTable : dispatchElevator --&gt; RequestTable : getRequestRequestTable --&gt; CusRequest : containElevator --&gt; Check : judgeclass Main&#123;      +main()$&#125;class InputThread&#123;      -WaitQueue waitQueue      +run() void&#125;class Schedule&#123;      -WaitQueue waitQueue      -HashMap&lt;Integer,Elevator&gt; elevators      -HashMap&lt;Intrger,RequestTable&gt; outRequestTables      -HashMap&lt;Integer,RequestTable&gt; inRequestTables      -HashMap&lt;Integer,Check&gt; checks      +run() void      +addEage() void      +imitate() int      +dispatch() void&#125;class Elevator&#123;      -int id      -int capacity      -double speed      -int access      -String status      -int floor      -int lastTime      -int direction      -blooean isMaintain      -HashMap&lt;Integer,Check&gt;checks      -RequestTable outRequestTable      -RequestTable inRequestTable      -WaitQueue waitqueue      -int[] accFloor      +getAccess() boolean      +setIsMaintain() void      +getIsMaintain() boolean      +updateDir() void      +getStatus() String      +setStatus() void      +maintainAct() void      +restAct() void      +openAct() void      +closeAct() void      +moveAct() void      +arriveAct() void      +getOff() void      +getOn() void      +clone() NightElevator&#125;class ElevatorThread&#123;      -Elevator elevator      +run() void&#125;class CusRequest&#123;      -int id      -int start      -int destination      -int realDes      +setRealDes() void      +setDestination() void      +getDestination() int      +getStart() int      +getDirection() int&#125;class Check&#123;      -int mx      -int nx      -int nowMx      -int nowNx      +only() void      +other() void      +endOnly() void      +endOther() void&#125;class WaitQueue&#123;      -ArrayList&lt;Request&gt; requests      -boolean isEnd      -HashMap&lt;Integer,Integer&gt; cus      -int maintainSum      +addCus() void      +remCus() void      +isPerEnd() boolean      +addPerRequest() void      +addChange() void      +addEleRequest() void      +addMainRequest() void      +addMaintain() void      +subMaintain() void      +getMaintainSum() int      +getRequest() Rqeuest      +setEnd() void      +isEnd() boolean      +isEmpty() boolean      +getPos() int      +addRequestTable() void&#125;class RequestTable&#123;      -boolean isEnd      -ArrayList&lt;CusRequest&gt; cusRequests      +setEnd() void      +isEnd() boolean      +isEmpty() boolean      +getSize() int      +addInRequest() void      +addOutRequest() void      +getLastRequest() CusRequest      +getOneRequest() CusRequest      +remRequest() void      +outWait() void      +outNotify() void      +isHaveOn() boolean      +isHavaOff() boolean      +getOnRequest() CusRequest      +getOffRequest() CusRequest      +getFetchStart() int      +getInDirection() int      +clone() RequestTable      &#125;</code></pre><h3 id="2-UML协作图-第三次作业">2.UML协作图(第三次作业)</h3><pre><code class=" mermaid">sequenceDiagramparticipant M as Mainparticipant I as InputThreadparticipant S as Scheduleparticipant E as ElevatorM -&gt;&gt; I : startM -&gt;&gt; S : startM -&gt;&gt; E : startI -&gt;&gt;+ S : addRequestalt[is PerRequest]S -&gt;&gt;+ E : dispatch and addRequestE -&gt;&gt; E : not transfer and get offE -&gt;&gt;- S : is tranfer and dispatch againelse[is AddElevator]S -&gt;&gt;+ E : new Elevator and startE --&gt;&gt;- S : ;else[is Maintain]S -&gt;&gt; + E : setIsMaintainE --&gt;&gt;-S : put the passengers to scheduleendS --&gt;&gt;- I: ;I -&gt;&gt;+ S : setEndS -&gt;&gt;+ E : if empty &amp;&amp; end then setEndE -&gt;&gt; E : if empty &amp;&amp; end then turn endE --&gt;&gt;- S : ;S --&gt;&gt;- I : ;</code></pre><h3 id="3-架构与迭代">3.架构与迭代</h3><h4 id="架构">架构</h4><ul><li>第五次作业<ul><li>输入线程将请求传入WaitQueue，Schedule读取并模拟加到电梯表中，电梯采取ALS策略</li><li>电梯有outRequestTable和inRequestTable，分别存放电梯外和电梯内的请求</li><li>电梯运行为有限状态机</li><li>结束条件<ul><li>ThreadInput 当前请求为null</li><li>Schedule <code>waitQueue.isEmpty() &amp;&amp; waitQueue.isEnd()</code></li><li>Elevator <code>outRequestTable.isEmpty() &amp;&amp; inRequestTable.isEmpty() &amp;&amp; outRequestTable.isEnd()</code></li></ul></li></ul></li><li>第六次作业<ul><li>调整电梯参数</li><li>结束条件<ul><li>ThreadInput 当前请求为null</li><li>Schedule <code>waitQueue.isEmpty() &amp;&amp; waitQueue.isEnd()&amp;&amp; waitQueue.getMaintainSum() == 0 </code>即需要判断电梯是否都响应了Maintain</li><li>Elevator <code>outRequestTable.isEmpty() &amp;&amp; inRequestTable.isEmpty() &amp;&amp; outRequestTable.isEnd()</code>或者维修</li></ul></li></ul></li><li>第七次作业<ul><li>可达性在调度器已经谈过</li><li>结束条件 Schedule <code>waitQueue.isEmpty() &amp;&amp; waitQueue.isEnd()&amp;&amp; waitQueue.getMaintainSum() == 0 &amp;&amp; cus.isEmpty()</code>cus是&lt;Integer,Integer&gt; 的hashMap，存放所有乘客的id和目的地，当乘客到站后将其删除</li><li>同一楼层服务数量由Check类执行，实现了类似信号量的方法</li></ul></li></ul><h4 id="电梯状态转换">电梯状态转换</h4><p>参考CO有限状态机，将电梯的行为和状态分为: end, rest, move, arrive, open, close,maintain。这样处理会在电梯线程的run中很清晰，不同状态执行不同操作并进行状态转换。</p><img src="/2023/04/17/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/2.png" class><h3 id="4-作业中稳定的内容和易变的内容">4.作业中稳定的内容和易变的内容</h3><p>整体的框架还是很完整，电梯线程变化的不多，加入了maintain新状态，在乘客下车时判断是否换乘</p><p>调度器变化最大，比如更换了策略类，Add和Maintain请求都是在调度器中处理；在第七次考虑可达性后，需要规划路线等等这些都是在调度器中完成。</p><h2 id="四、bug和debug">四、bug和debug</h2><h3 id="bug">bug</h3><p>由于第五次我就使用了调度器，导致模拟的时候可能会出现真实电梯move状态floor++但是仍在move，导致影子电梯的状态转化出现错误出现了死循环；第六次作业问题是线程资源紧张导致无法申请新的线程，还有问题是应当优先处理maintain请求和addElevator请求，出现了维修后移动超过两层的情况；第七次作业暂时没找到bug</p><h3 id="debug">debug</h3><p>大多数debug都是死循环的bug，这是由于线程一直在run没有结束，我使用JProfiler分析CPU时间从而定位出现问题的线程由于电梯运行是状态转移，因此也能轻松定位到出现问题的状态和方法。除此之外，线程无法结束我一般使用手工打断点，即在特定的语句出输出一些语句，这样可以判断是哪些线程没有结束，之后确定原因。</p><h2 id="五、心得体会">五、心得体会</h2><h3 id="1-线程安全">1. 线程安全</h3><h4 id="如非必要，勿增实体">如非必要，勿增实体</h4><p>线程之间共享的对象实体越少越好，这也就是奥卡姆剃刀的应用</p><h4 id="读写的具体判断">读写的具体判断</h4><p>在上文中已经提到有的读写是必要互斥的，有的则不必要，不能一味synchronized，也不能一律都用读写锁</p><h3 id="2-层次化设计">2.层次化设计</h3><h4 id="电梯线程的run">电梯线程的run</h4><p>这样比写很多的分支语句要清晰的多，也很容易迭代开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">switch</span> (elevator.getStatus()) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;end&quot;</span>:<br>                    <span class="hljs-keyword">return</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;rest&quot;</span>:<br>                    elevator.restAct();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;maintiain&quot;</span>:<br>                    elevator.maintainAct();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;open&quot;</span>:<br>                    elevator.openAct();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;close&quot;</span>:<br>                    elevator.closeAct();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;move&quot;</span>:<br>                    elevator.moveAct();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;arrive&quot;</span>:<br>                    elevator.arriveAct();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>####线程和面向对象</p><p>我将电梯线程和电梯分开，线程只是为其拥有的属性提供了运行的栈空间，因此将线程和具体的事物分离是很正确的，但调取器和调度线程为了简洁合为一个。面向对象的思想进一步加深。</p><h3 id="3-写在最后">3. 写在最后</h3><p>第五次作业为了死循环bug，最终甚至没进互测，无疑是对我的一次重大打击，bug虽小，但造成后果很严重。第五次作业投入的时间超过30小时，虽然分数不理想，但我对多线程的理解在其中也得到强化，第五次作业留下的良好架构让之后的作业少走了很多弯路（虽然之后两次还是有很长时间debug）。除此之外，debug能力也得到很大提升，通过错误数据以及断点设置，结合工具能够快速定位到问题代码，分析原因并修改。</p><p>还有一个很重要的问题，太过于依赖讨论区的评测机，在之后单元中，还是要自己写一些简易的评测机。软件的开发和测试都是尤为重要的环节，即使在未来不会从事软件行业，但测试还是一项很重要的内容。</p><p>体验失败，并战胜失败，愉快的面对每次作业</p>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OO</tag>
      
      <tag>总结</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-lab3</title>
    <link href="/2023/04/17/OS-lab3/"/>
    <url>/2023/04/17/OS-lab3/</url>
    
    <content type="html"><![CDATA[<h1>OS-lab3</h1><h2 id="上机">上机</h2><h3 id="exam">exam</h3><p>我们要修改调度函数，实现多用户的（公平）进程调度，就是在Env结构体了新加一个属性：u_int env_user（[0,4]）（测试程序会给你赋值），最多不超过5名用户。简言之，在需要调度新的进程的时候你需要统计每个用户的总时间片选，总时间片选保存static int[] 数组中，然后你需要选出当前有进程的用户并且总时间片选最少的（相同则id最小）的用户，然后选出遍历队列选出第一个当前用户的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">(<span class="hljs-type">int</span> yield)</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// remaining time slices of current env</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span> =</span> curenv;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> user_time[<span class="hljs-number">5</span>];             <span class="hljs-comment">//总时间片选</span><br><span class="hljs-type">int</span> able[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;       <span class="hljs-comment">//记录有进程的用户</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">temp</span>;</span><br>TAILQ_FOREACH(temp, &amp;env_sched_list, env_sched_link)<br>&#123;<br>able[temp-&gt;env_user] = <span class="hljs-number">1</span>;            <span class="hljs-comment">//循环队列，搜索所有有进程的用户</span><br>&#125;<br><span class="hljs-comment">/* We always decrease the &#x27;count&#x27; by 1.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If &#x27;yield&#x27; is set, or &#x27;count&#x27; has been decreased to 0, or &#x27;e&#x27; (previous &#x27;curenv&#x27;) is</span><br><span class="hljs-comment"> * &#x27;NULL&#x27;, or &#x27;e&#x27; is not runnable, then we pick up a new env from &#x27;env_sched_list&#x27; (list of</span><br><span class="hljs-comment"> * all runnable envs), set &#x27;count&#x27; to its priority, and schedule it with &#x27;env_run&#x27;. **Panic</span><br><span class="hljs-comment"> * if that list is empty**.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (Note that if &#x27;e&#x27; is still a runnable env, we should move it to the tail of</span><br><span class="hljs-comment"> * &#x27;env_sched_list&#x27; before picking up another env from its head, or we will schedule the</span><br><span class="hljs-comment"> * head env repeatedly.)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Otherwise, we simply schedule &#x27;e&#x27; again.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * You may want to use macros below:</span><br><span class="hljs-comment"> *   &#x27;TAILQ_FIRST&#x27;, &#x27;TAILQ_REMOVE&#x27;, &#x27;TAILQ_INSERT_TAIL&#x27;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Exercise 3.12: Your code here. */</span><br><span class="hljs-keyword">if</span> (yield || !e || !count || e-&gt;env_status != ENV_RUNNABLE)<br>&#123;<br><span class="hljs-keyword">if</span> (e != <span class="hljs-literal">NULL</span> &amp;&amp; e-&gt;env_status == ENV_RUNNABLE)<br>&#123;<br>TAILQ_REMOVE(&amp;env_sched_list, e, env_sched_link);<br>TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);<br>user_time[e-&gt;env_user] += e-&gt;env_pri;                <span class="hljs-comment">// 时间片选+=env_pri</span><br>&#125;<br><span class="hljs-keyword">if</span> (TAILQ_EMPTY(&amp;env_sched_list))<br>&#123;<br>panic(<span class="hljs-string">&quot;no runnable envs&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> flag = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> min = <span class="hljs-number">114514</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)                 <span class="hljs-comment">//遍历找到时间片最小的用户</span><br>&#123;<br><span class="hljs-keyword">if</span> (able[i] &amp;&amp; user_time[i] &lt; min)<br>&#123;<br>min = user_time[i];<br>flag = i;<br>&#125;<br>&#125;<br>TAILQ_FOREACH(temp, &amp;env_sched_list, env_sched_link)   <span class="hljs-comment">//找到当前用户队列中第一个进程，并run</span><br>&#123;<br><span class="hljs-keyword">if</span> (temp-&gt;env_user == flag)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>e = temp;<br>count = e-&gt;env_pri;<br>&#125;<br>&#125;<br>count--;<br>env_run(e);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="extra">extra</h3><p>完成overflow的异常处理</p><ul><li>请在完成异常处理函数后修改 lib/traps.c ，将你自己编写的异常处理函数加入异常向量组 中的对应位置。</li><li>大家可以使用 lib/genex.S 中定义的 BUILD_HANDLER 宏来构建自己的异常处理函数，构建方法可以参考已有的 handle_tlb 等处理函数。</li><li>异常处理（对应指令有三个add，sub，addi）<ul><li>对于addi，addi $t, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>i</mi><mi>m</mi><mi>m</mi><mo>:</mo><mtext>处理为</mtext></mrow><annotation encoding="application/x-tex">s, imm  : 处理为</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">imm</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">处理为</span></span></span></span>s = $t/2 + imm/2;  epc += 4；</li><li>add和sub，转换成addu和subu指令</li></ul></li></ul><p>难点是怎么从进程空间中取出指令，我们知道代码段对应页权限肯定没有PTE_D,因此在用户空间tlb访问就会异常，合理的方法是在内核态中异常处理函数，将进程中的env_va转换成物理地址，并将物理地址转换为kseg0地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_ov</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>u_long env_va = tf-&gt;cp0_epc;            <br>Pde *cpgdir = curenv-&gt;env_pgdir;<br>curenv-&gt;env_ov_cnt++;<br>Pte *pte;<br>pgdir_walk(cpgdir, env_va, <span class="hljs-number">0</span>, &amp;pte);         <span class="hljs-comment">//找到二级页表项</span><br>u_long va = KADDR((*pte &amp; ~(<span class="hljs-number">0xFFF</span>)) + (env_va &amp; <span class="hljs-number">0xFFF</span>));   <span class="hljs-comment">//转换为kseg0虚拟地址，记着*pte一定要取高20位，或者用宏PTE_ADDR,还要加上页内偏移</span><br>u_int ins = *(<span class="hljs-type">int</span> *)va;                   <span class="hljs-comment">//取指令</span><br><span class="hljs-keyword">if</span> (ins &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">29</span>))                 <br>&#123;                                           <span class="hljs-comment">// addi</span><br><span class="hljs-type">int</span> s = (ins &amp; (<span class="hljs-number">31</span> &lt;&lt; <span class="hljs-number">21</span>)) &gt;&gt; <span class="hljs-number">21</span>;         <span class="hljs-comment">//取s寄存器</span><br><span class="hljs-type">int</span> t = (ins &amp; (<span class="hljs-number">31</span> &lt;&lt; <span class="hljs-number">16</span>)) &gt;&gt; <span class="hljs-number">16</span>;          <span class="hljs-comment">//取t寄存器</span><br><span class="hljs-type">int</span> imm = ins &amp; (<span class="hljs-number">0xFFFF</span>);                  <span class="hljs-comment">//立即数</span><br>tf-&gt;regs[t] = tf-&gt;regs[s] / <span class="hljs-number">2</span> + imm / <span class="hljs-number">2</span>; <br>tf-&gt;cp0_epc += <span class="hljs-number">4</span>;<br>printk(<span class="hljs-string">&quot;addi ov handled\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ins &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>))<br>&#123;                                          <span class="hljs-comment">// sub</span><br>printk(<span class="hljs-string">&quot;sub ov handled\n&quot;</span>);<br>*(<span class="hljs-type">int</span> *)va = ins | <span class="hljs-number">1</span>;              <span class="hljs-comment">//指令改为subu</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;                                          <span class="hljs-comment">// add</span><br>printk(<span class="hljs-string">&quot;add ov handled\n&quot;</span>);<br>*(<span class="hljs-type">int</span> *)va = ins | <span class="hljs-number">1</span>;          <span class="hljs-comment">//改为addu</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实验报告">实验报告</h2><h3 id="一、思考题">一、思考题</h3><h4 id="thinking-3-1">thinking 3.1</h4><p>完成进程页目录的自映射，并且将标志位设置为有效</p><h4 id="thinking-3-2">thinking 3.2</h4><p>来自elf_laod_seg函数传入，利用回调函数将程序段加载到进程制定虚拟空间中，data参数是必须的，否则我们无法得到程序段的地址</p><h4 id="thinking-3-3">thinking 3.3</h4><ul><li>va是否是页对齐的</li><li>将全部短内容加载后，实际占用的filesize是否等于memsize，如果不是则需要申请新的页空间</li></ul><h4 id="thinking-3-4">thinking 3.4</h4><p>我们知道，进程切换是需要陷入内核态的，所以epc存储的是虚拟地址</p><h4 id="thinking-3-5">thinking 3.5</h4><p>在genex.S中</p><h4 id="thinking-3-6">thinking 3.6</h4><ul><li>enable_irq 设置cp0状态寄存器允许中断，即项CP0_STATUS写入(STATUS_CU0 | STATUS_IM4 | STATUS_IEc)</li><li>timer_irq  表示响应时钟中断，执行schedule函数</li></ul><h4 id="thinking-3-7">thinking 3.7</h4><p>先初始化时钟并且设置中断可相应，当时间片用完时表示要切换进程，发出中断陷入内核，进入handle_int函数，然后根据识别中断类型，是时钟中断然后跳转到schedule函数</p><h3 id="二、实验难点">二、实验难点</h3><h5 id="回调函数icode-mapper">回调函数icode_mapper</h5><p>根据elf_load_seg需要理解加载段内容到进程中可能碰到的情况，考虑是否也对齐</p><h5 id="env-setup-vm函数实现将envs和pages拷贝到用户空间">env_setup_vm函数实现将envs和pages拷贝到用户空间</h5><p>很抽象，首先pages和evs是放在内核态代码全局变量附近，完成将这两个放到用户态指定位置，我们知道用户态是通过tlb和页表访问的，所以只需要将这两个控制块所在的页映射到用户态能访问到的UTOP到UVPT之间（在map_segment实现）但这只是实现了从内核态到内核态的平移，目的是在进程页表初始化的时候复制到进程页表，这是很巧妙的复制方法，不同虚拟空间的数据拷贝</p><h5 id="schedule">schedule</h5><p>如果要切换进程，需要判断当前队列是否为空，当前进程的状态是否仍是RUNNABLE，如果是的话需要把它放到队尾。并且切换进程是env_run所干的事</p><h3 id="三、实验体会">三、实验体会</h3><p>经过lab0-lab3，发现linux系统实现的很巧妙，如果我们从0搭建一个操作系统真的是难上加难，所以要学习他们的思想，比如将一些很难得任务切分成小任务，然后对函数进行封装，比如加载段内容到进程中。</p><p>OS变得越来越抽象，想要学好必须要真正读懂，如果只是参考往届代码，根据提示补全代码，在上机的时候是肯定做不出来的，对于已经写好的宏和函数，要理解它们的功能和实现，在上机写的时候才能灵活应用</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>lab3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-lab2</title>
    <link href="/2023/04/03/OS-lab2/"/>
    <url>/2023/04/03/OS-lab2/</url>
    
    <content type="html"><![CDATA[<h1>lab2</h1><h2 id="上机">上机</h2><ul><li>lab2-exam 还是比较简单的，认真写肯定能对</li><li>lab2-extra 这是专门给佬出的题，我就只把题面放到这了，造福后人了</li></ul><h3 id="lab2-exam">lab2-exam</h3><ul><li>对于一个页表项，我们知道其存储的31-12位为物理页号，0-11是标志位，我们的任务是遍历整个页表的页表项，如果是有效页并且检查标志位perm_mask（可能是好几个标志位），如果都包含则计数，最后返回数量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">u_int <span class="hljs-title function_">page_perm_stat</span><span class="hljs-params">(Pde *pgdir, <span class="hljs-keyword">struct</span> Page *pp, u_int perm_mask)</span><br>&#123;<br>Pde *pd_entry;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (pd_entry = pgdir; i &lt; <span class="hljs-number">1024</span>; pd_entry++)       <span class="hljs-comment">//一层循环遍历所有的页目录项</span><br>&#123;<br>Pte *pt_entry;<br>i++;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> ((*pd_entry &amp; PTE_V) != <span class="hljs-number">0</span>) <span class="hljs-comment">//你的二级页表必须有效才能接着遍历</span><br>&#123;<br><span class="hljs-keyword">for</span> (pt_entry = (Pte *)KADDR(PTE_ADDR(*pd_entry)); j &lt; <span class="hljs-number">1024</span>; pt_entry++) <span class="hljs-comment">//遍历所有页表项</span><br>&#123;<br>j++;<br><span class="hljs-keyword">if</span> ((*pt_entry &amp; PTE_V) != <span class="hljs-number">0</span>)    <span class="hljs-comment">//有效</span><br>&#123;<br><span class="hljs-keyword">if</span> (((*pt_entry &amp; perm_mask) == perm_mask) &amp;&amp; (PTE_ADDR(*pt_entry) == page2pa(pp)))<br>&#123;                          <span class="hljs-comment">//之前因为PTE_V都是一位，所以直接&amp;运算不等于0就行，但是现在标志位可能有很多，必须是(*pt_entry &amp; perm_mask) == perm_mask才能说明包含给定的标志位</span><br>sum++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lab2-extra">lab2-extra</h3><p>真抽象，我觉得extra确实得有区分度，但是你得保证不能让绝大多数同学坐牢没一点收获吧。用机房的CLI是真难受，课下vscode用的是真爽，一个好的idea是优秀程序员的必备工具，CLI难蚌。</p><h3 id="题目背景">题目背景</h3><p>在理论课程中，我们学习了交换技术。它实现进程在内存与外存之间的交换，因而获得更多的虚拟内存空间。</p><p>简单来说，交换空间（swap）是外存上的一块区域，当系统物理内存不足时，内核会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中。这样相当于我们获得了更多的虚拟存储（通过使用一部分外存）。</p><p>在本题中，我们会实现一个较为简单的交换机制，使得在没有空闲的物理页面时，可以暂时将正在使用的一页内存换出，同时释放出一页物理页面用于使用。</p><p>题目描述<br>我们建立的交换机制可以分为两部分，“换入”部分，以及“换出”部分。</p><p>当我们没有空闲的物理页面时，我们进行“换出”，即申请物理页面时，如果没有可用的页面，我们换出一页正在使用的物理页，供申请者使用。</p><p>当我们需要访问某个 kuseg 段的虚拟地址时，我们会检查这个虚拟地址对应的虚拟页是否已被换出到外存，如果是，则我们将其“换入”。</p><p>虚拟页被换入的物理页可能与其被换出时不同，但需要保证换入后物理页中的数据以及页表项中的权限位与换出时相同。为此，我们需要在换出时利用外存来保存数据。</p><p>题目要求<br>在本题中，你需要使用物理地址属于 [0x3900000, 0x3910000) 的这 16 个物理页以及外存来实现“交换”。</p><p>在本题中我们把这 16 个物理页叫做可交换的物理页。<br>为了区分这些可交换的物理页，我们建立了一个新的空闲可交换页面链表 page_free_swapable_list。<br>同时，我们将提供部分代码（请参看实验提供代码部分），你需要将其粘贴至 kern/pmap.c 之后，并补全或者实现如下几个函数：</p><h3 id="提示">提示</h3><p>我们给出一种可行的设计，当然，你也可以略过本节自己进行设计。</p><p>当没有空闲的物理页时，我们需要进行换出操作。在本设计中，我们在页表项中增加了一个新的标志位 PTE_SWP（在下发的头文件 swap.h 中已有定义）。</p><p>当 PTE_SWP 为 1 且 PTE_V 为 0 时:<br>对应的虚拟地址映射到的物理内存有效但被换出，实际的内容存在外存上，该页表项的高 20 位为内容在外存上的外存页号。<br>软件应保证不会出现 PTE_SWP 为 1 且 PTE_V 为 1 的页表项。<br>当 PTE_SWP 为 0 时，页表项的含义与 Lab2 课下定义的相同。<br>我们可以通过 da / BY2PG 计算 da 对应的外存页号<br>当我们希望将某个虚拟地址对应的物理页从外存中换入内存时：</p><p>使用 swap_alloc 申请一个物理页 p<br>将外存中以 da 起始的一页内容拷贝到该物理页 p 上（da 为换出时内容在外存上的地址）<br>对指定页表中，所有“PTE_SWP 为 1 且 PTE_V 为 0 且高 20 位为 da 对应的外存页号”的页表项，做如下操作：<br>将 PTE_V 置 1<br>将 PTE_SWP 置 0<br>在高 20 位中填入 p 对应的物理页号<br>维持其它权限位不变<br>无效化旧 TLB 表项<br>使用 disk_free 释放 da 起始的一页外存空间<br>当我们需要换出一个内存中的物理页至外存时：</p><p>从 [0x3900000, 0x3910000) 的内存空间中，选择一个物理页 p<br>使用 disk_alloc 申请一页大小的外存空间，记该外存空间的起始地址为 da<br>对指定页表中，所有 PTE_V 为 1 且高 20 位为 p 的物理页号的页表项，做如下操作：<br>将 PTE_V 置 0<br>将 PTE_SWP 置 1<br>在高 20 位中填入 da 对应的外存页号<br>维持其它权限位不变<br>无效化旧 TLB 表项<br>将物理页 p 上的内容拷贝到外存中 da 起始的一页空间上<br>释放物理页 p，也就是将其插回 page_free_swapable_list 链表中<br>任务总结<br>在提交前，你需要完成以下任务：</p><p>换入部分：<br>完成 is_swapped 函数。<br>完成 swap 函数，维护 page_free_swapable_list 链表，适时无效化 TLB 中的旧表项。<br>换出部分：<br>完成 swap_alloc 函数，维护 page_free_swapable_list 链表，适时无效化 TLB 中的旧表项。<br>本题不涉及课下代码的修改。<br>Pte swap_lookup(Pde *pgdir, u_int asid, u_long va) {<br>// Step 1: If corresponding page is swapped out, swap it in<br>if (is_swapped(pgdir, va)) {<br>swap(pgdir, asid, va);<br>}</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;swap.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page_list</span> <span class="hljs-title">page_free_swapable_list</span>;</span><br><span class="hljs-type">static</span> u_char *<span class="hljs-title function_">disk_alloc</span><span class="hljs-params">()</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">disk_free</span><span class="hljs-params">(u_char *pdisk)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap_init</span><span class="hljs-params">()</span> &#123;<br>LIST_INIT(&amp;page_free_swapable_list);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = SWAP_PAGE_BASE; i &lt; SWAP_PAGE_END; i += BY2PG) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">pp</span> =</span> pa2page(i);<br>LIST_REMOVE(pp, pp_link);<br>LIST_INSERT_HEAD(&amp;page_free_swapable_list, pp, pp_link);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Interface for &#x27;Passive Swap Out&#x27;</span><br><span class="hljs-keyword">struct</span> Page *<span class="hljs-title function_">swap_alloc</span><span class="hljs-params">(Pde *pgdir, u_int asid)</span> &#123;<br><span class="hljs-comment">// Step 1: Ensure free page</span><br><span class="hljs-keyword">if</span> (LIST_EMPTY(&amp;page_free_swapable_list)) &#123;<br><span class="hljs-comment">/* Your Code Here (1/3) */</span><br>&#125;<br><br><span class="hljs-comment">// Step 2: Get a free page and clear it</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">pp</span> =</span> LIST_FIRST(&amp;page_free_swapable_list);<br>LIST_REMOVE(pp, pp_link);<br><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)page2kva(pp), <span class="hljs-number">0</span>, BY2PG);<br><br><span class="hljs-keyword">return</span> pp;<br>&#125;<br><br><span class="hljs-comment">// Interfaces for &#x27;Active Swap In&#x27;</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">is_swapped</span><span class="hljs-params">(Pde *pgdir, u_long va)</span> &#123;<br><span class="hljs-comment">/* Your Code Here (2/3) */</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(Pde *pgdir, u_int asid, u_long va)</span> &#123;<br><span class="hljs-comment">/* Your Code Here (3/3) */</span><br>&#125;<br><br>Pte <span class="hljs-title function_">swap_lookup</span><span class="hljs-params">(Pde *pgdir, u_int asid, u_long va)</span> &#123;<br><span class="hljs-comment">// Step 1: If corresponding page is swapped out, swap it in</span><br><span class="hljs-keyword">if</span> (is_swapped(pgdir, va)) &#123;<br>swap(pgdir, asid, va);<br>&#125;<br><br><span class="hljs-comment">// Step 2: Look up page table element.</span><br>Pte *ppte;<br>page_lookup(pgdir, va, &amp;ppte);<br><br><span class="hljs-comment">// Step 3: Return</span><br><span class="hljs-keyword">return</span> ppte == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : *ppte;<br>&#125;<br><br><span class="hljs-comment">// Disk Simulation (Do not modify)</span><br>u_char swap_disk[SWAP_DISK_NPAGE * BY2PG] __attribute__((aligned(BY2PG)));<br>u_char swap_disk_used[SWAP_DISK_NPAGE];<br><br><span class="hljs-type">static</span> u_char *<span class="hljs-title function_">disk_alloc</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> alloc = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (;alloc &lt; SWAP_DISK_NPAGE &amp;&amp; swap_disk_used[alloc]; alloc++) &#123;<br>;<br>&#125;<br>assert(alloc &lt; SWAP_DISK_NPAGE);<br>swap_disk_used[alloc] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> &amp;swap_disk[alloc * BY2PG];<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">disk_free</span><span class="hljs-params">(u_char *pdisk)</span> &#123;<br><span class="hljs-type">int</span> offset = pdisk - swap_disk;<br>assert(offset % BY2PG == <span class="hljs-number">0</span>);<br>swap_disk_used[offset / BY2PG] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="实验报告">实验报告</h2><h3 id="思考题">思考题</h3><h4 id="thinking-2-1">thinking 2.1</h4><p>都是虚拟地址</p><h4 id="thinking-2-2">thinking 2.2</h4><ul><li>复用性好，在之后操作系统中，如果需要建立双向链表，可以直接使用宏定义，对链表的一些操作很方便</li><li>没找见循环链表，除了实验中的双向链表外，还有一个tail queue，其实和双向链表差不多，知识在head维护了链表的首个元素和最后的元素。<ul><li>将元素插入到链表头部的时候，需要注意如果首个元素为NULL，则插入后的elm既是第一个有时第二个元素</li><li>插入链表尾部的时候，维护head中的tqe_last, 但是如果链表为空呢，也得维护tqe_first</li><li>插入到某个元素后面的时候，需要判断当前是不是tail，如果是，更新head的tqe_last</li><li>删除操作也是，判断是不是链表尾部</li></ul></li><li>我们发现这与我们常见的双向链表不一样，因为在filed.le_prev是一个指针的指针，存放的时候上一个元素field.le_next的指针，可能是为了既能做到插入元素，又可以保证访问顺序只能往下而不能往上吧</li></ul><h4 id="thinking-2-3">thinking 2.3</h4><p>c，我们发现head其实只装了链表的首个元素指针</p><h4 id="thinking-2-4">thinking 2.4</h4><ul><li>我们知道操作系统实现了多进程，让每个进程都认为自己独享“物理空间（实际是虚拟空间）”，但TLB只有一个，不同进程从虚拟空间到物理空间的映射不同，所以使用ASID，只有EntryHi中的虚拟页号和ASID与TLB中的KEY都相同才是对应的物理页号。</li><li>6位，对应256个不同地址空间</li></ul><h4 id="thinking-2-5">thinking 2.5</h4><ul><li><p>tlb_invalidate 调用 tlb_out</p></li><li><p>当我们建立页表物理映射时，原本的映射可能存在也可能不存在，如果存在且和要映射的物理页面不同|新申请的页，需要更新TLB，下次加载va所在页时，TLB会重新加载，即用时才加载</p></li><li><pre><code class="hljs">LEAF(tlb_out).set noreordermfc0    t0, CP0_ENTRYHI  //把之前寄存器保存一下mtc0    a0, CP0_ENTRYHI  //将a0即虚拟地址对应的虚拟页号存入到寄存器中nop/* Step 1: Use 'tlbp' to probe TLB entry *//* Exercise 2.8: Your code here. (1/2) */    tlbp                    //根据寄存器的虚拟页号和ASID，来查找TLB，若没找到，则index为负数nop/* Step 2: Fetch the probe result from CP0.Index */mfc0    t1, CP0_INDEX    //去除索引.set reorderbltz    t1, NO_SUCH_ENTRY //如果没找到就直接返回了.set noreordermtc0    zero, CP0_ENTRYHI  //找到的话，那就清空TLB对应项mtc0    zero, CP0_ENTRYLO0nop/* Step 3: Use 'tlbwi' to write CP0.EntryHi/Lo into TLB at CP0.Index  *//* Exercise 2.8: Your code here. (2/2) */    tlbwi                     //根据索引去请0.set reorderNO_SUCH_ENTRY:mtc0    t0, CP0_ENTRYHI   j       ra                //返回END(tlb_out)                 </code></pre></li></ul><h4 id="thinking-2-6">thinking 2.6</h4><img src="/2023/04/03/OS-lab2/x86.jpg" class><p>在x86架构中内存被分为三种形式，分别是<strong>逻辑地址</strong>（Logical Address），<strong>线性地址</strong>（Linear Address）和<strong>物理地址</strong>（Physical Address）。如上图所示，通过分段可以将逻辑地址转换为线性地址，而通过分页可以将线性地址转换为物理地址。逻辑地址由两部分构成，一部分是段选择器（Segment Selector），一部分是偏移（Offset）。段选择符存放在段寄存器中，如CS（存放代码段选择符）、SS（存放堆栈段选择符）、DS（存放数据段选择符）和ES、FS、GS（一般也用来存放数据段选择符）等；偏移与对应段描述符（由段选择符决定）中的基地址相加就是线性地址。全局描述符表（Global Descriptor Table）需要OS在初始化时创建（每个CPU都有一张，基本内容大致相同，除了少数几项如TSS），创建好后将表的地址（这是个线性地址）放到全局描述符寄存器中（GDTR），这通过LGDT和SGDT指令来完成。</p><h4 id="自映射">自映射</h4><p>为方便区分，记三级页表基地址为PTbase2， 二级页表基地址为PTbase1， 页目录基地址为PDbase</p><p>PTbase1 = PTbase2 &gt;&gt; 30 &lt;&lt; 21 + PTbase2 = PTbase2 &gt;&gt; 9 + PTbase2</p><p>PDbae = PTbase2 &gt;&gt; 9 &gt;&gt;21 &lt;&lt; 12 + PTbase1 = PTbase2 &gt;&gt; 18 + PTbase2 &gt;&gt; 9 + PTbase2</p><p>PDE = PTbase &gt;&gt; 27 + PTbase &gt;&gt; 18 + PTbase &gt;&gt; 9 + PTbase</p><hr><h3 id="实验难点">实验难点</h3><h4 id="物理地址和虚拟地址">物理地址和虚拟地址</h4><ul><li>在lab2中我们一直都处于内核态，我觉得这个就很抽象，导致2.1 - 2.5 始终对虚拟地址和物理地址搞不清，我们所写的代码都放在内核态，并不会影响我们对0x80400000之后空间的操作。然后我们时刻保持一个原则，所有的指针都是虚拟地址。比如page_init中，我们pages这个变量保存在内核态中，但所指的地址是在80400000，我们只是用pages来管理所对应的物理页。但是pages所指的地址存放了npage个page结构体，也就是说在前面的物理页中其实存放着page结构体。这样的话page_init就很好补充了</li><li>再如pgdir_walk,  传进来的pgdir是页目录的虚拟地址，我们可以很轻松的找到对应的页表项，如果creat为1，最开始我以为是让页表等于申请到的pp，这个时候就弄错了，页表是虚拟空间中的，所以应该是页目录项地址存储物理页号。先把物理地址转为虚拟地址，并且要按第十二位对齐，再加上二级页号偏移，最终 <code>ppte应该页表项的地址，*ppte = (*Pte)PTE_ADDR(KADDR(*pgdir)) + PTX(va)</code></li></ul><h4 id="双向链表">双向链表</h4><p>空闲链表是双向的，但le_prev确实上一个元素le_next的指针，我们并不能通过le_prev访问上一个元素，这样既可以保证单向性又能保证链表的插入删除操作得以进行。例如我们想把elm插入到list_elm的前面</p><pre><code class=" mermaid">graph LRprev(prev) -- le_next --&gt; now(list_elm)now -- le_next --&gt; next(next)now -- le_prev --&gt; prevnext -- le_pev --&gt; now</code></pre><p>elm-&gt;le_next(没有写pp_link，问题不大) = list_elm</p><p>elm-&gt;le_prev = list_elm-&gt;le_prev</p><p>*(list_elm-&gt;prev) = elm</p><p>list_elm-&gt;prev = &amp;(elm-&gt;le_next)</p><hr><h3 id="实验感受">实验感受</h3><ul><li>我觉得OS不是一蹴而就的写完，是需要大量仔细看实验指导书，然后看源码，2.6我做了看了三遍，做了三遍，每次看都以为自己会了，写完发现不对，然后再看再写。</li><li>复用性高的宏是真的方便，能让代码看的整洁并且结构清楚</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>lab2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯（1）</title>
    <link href="/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%881%EF%BC%89-1/"/>
    <url>/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%881%EF%BC%89-1/</url>
    
    <content type="html"><![CDATA[<h1>蓝桥杯（1）</h1><p>写在前面：去年裸考，想着今年好好准备一下，这几周天天被OS和OO折磨，一直拖到现在。看了一下往年题，填空题只要时间复杂度不是特别离谱，直接暴力模拟就行，编程题我主要总结一下常考的算法，由于现在还没上过算法课，好多东西也都不会，写这篇博客就当边学习边总结了。</p><h3 id="最短路径-Floyd算法和Dijkstra算法">最短路径 Floyd算法和Dijkstra算法</h3><img src="/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%881%EF%BC%89-1/path.jpg" class><p>Dijkstra主要用于求两点最短距离和最短路径，而且只能求出一条最短路径。</p><ul><li>首先初始化，我们用edge [2022] [2022]二维数组存储边的权值，本题中无边则权值为一个较大数；定义dis[2022]存储第一个点到各个点的最短距离，初始化为edge[1]；haveFind [2022] 记录是否找到从1到i的最短路径；path[2022]记录从1到此点的前一点</li><li>遍历dis从当前尚未找到最短路径的点中找到最小值，记此点为index，更新haveFind[index] = 1。</li><li>以flag为中间点，遍历如果(dis[index] + edge [index] [i] &lt;= dis[i])那么记dis[i] = dis[index] + edge [index] [i], 并且更新前继节点path[i] = index</li><li>直到index为路径终点结束循环</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> edge[<span class="hljs-number">2022</span>][<span class="hljs-number">2022</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">if</span> (a &lt; b) &#123;<br><span class="hljs-type">int</span> c = a;<br>a = b;<br>b = c;<br>&#125;<br><span class="hljs-keyword">return</span> (b == <span class="hljs-number">0</span>) ? a : gcd(b, a % b);<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> dis[<span class="hljs-number">2022</span>];       <span class="hljs-comment">// 存储着1到各个点最小距离</span><br><span class="hljs-type">int</span> haveFind[<span class="hljs-number">2022</span>];       <span class="hljs-comment">//如果找到了1到某个点的最小距离则该点记为1</span><br><span class="hljs-type">int</span> path[<span class="hljs-number">2022</span>];        <span class="hljs-comment">//比如path[2] = 3,那么改最短路径的前继节点为3</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> flag)</span> &#123;    <span class="hljs-comment">//打印路径</span><br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> lastFlag = path[flag];<br>printPath(lastFlag);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-%d&quot;</span>, flag);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;        <span class="hljs-comment">//初始化edge  </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2021</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(i - j) &gt; <span class="hljs-number">21</span>) &#123;<br>edge[i][j] = edge[j][i] = <span class="hljs-number">1145140000</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j) &#123;<br>edge[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>edge[i][j] = edge[j][i] = i * j / gcd(i, j);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;          <span class="hljs-comment">//初始化dis</span><br>dis[i] = edge[<span class="hljs-number">1</span>][i];<br>&#125;<br><span class="hljs-type">int</span> nowNode = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (nowNode != <span class="hljs-number">2021</span>) &#123;<br><span class="hljs-type">int</span> minDis = <span class="hljs-number">1145140000</span>;<br><span class="hljs-type">int</span> index = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (haveFind[i] != <span class="hljs-number">1</span> &amp;&amp; dis[i] &lt;= minDis) &#123;<br>minDis = dis[i];<br>index = i;<br>&#125;<br>&#125;<br>nowNode = index;<br>haveFind[index] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (haveFind[i] != <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (dis[index] + edge[index][i] &lt;= dis[i]) &#123;<br>dis[i] = dis[index] + edge[index][i];<br>path[i] = index;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, dis[<span class="hljs-number">2021</span>]);<br>printPath(<span class="hljs-number">2021</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Floyd算法更加暴力，可以求任意两点最短距离和路径</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> edge[<span class="hljs-number">2022</span>][<span class="hljs-number">2022</span>];<br><span class="hljs-type">int</span> path[<span class="hljs-number">2022</span>][<span class="hljs-number">2022</span>];<br><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">if</span> (a &lt; b) &#123;<br><span class="hljs-type">int</span> c = a;<br>a = b;<br>b = c;<br>&#125;<br><span class="hljs-keyword">return</span> (b == <span class="hljs-number">0</span>) ? a : gcd(b, a % b);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2021</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(i - j) &gt; <span class="hljs-number">21</span>) &#123;<br>edge[i][j] = edge[j][i] = <span class="hljs-number">1145140000</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j) &#123;<br>edge[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>edge[i][j] = edge[j][i] = i * j / gcd(i, j);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2021</span>; j++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">2021</span>; k++) &#123;<br><span class="hljs-keyword">if</span> (edge[j][i] + edge[i][k] &lt;= edge[j][k]) &#123;<br>edge[j][k] = edge[j][i] + edge[i][k];<br>path[j][k] = path[k][j] = i;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, edge[<span class="hljs-number">1</span>][<span class="hljs-number">2021</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DFS深度搜索">DFS深度搜索</h3><h4 id="例题一">例题一</h4><img src="/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%881%EF%BC%89-1/tree.jpg" class><p>其中N&lt;=100000</p><p>题中认为子节点是无序的，因此才有得到的二叉树不同，例如2放到左边和右边</p><pre><code class=" mermaid">graph TBsubgraph 二叉树2 left1a((1))1a--&gt;2a((2))2a--&gt;5a((5))2a--&gt;3a((3))3a--&gt;4a((4))endsubgraph 多叉树2 left1((1))1--&gt;2((2))1--&gt;3((3))1--&gt;4((4))2--&gt;5((5))endsubgraph 二叉树2 right1d((1))1d--&gt;3d((3))3d--&gt;4d((4))4d--&gt;2d((2))2d--&gt;5d((5))endsubgraph 多叉树2 right1b((1))1b--&gt;3b((3))1b--&gt;4b((4))1b--&gt;2b((2))2b--&gt;5b((5))end</code></pre><p>得到规律，在第二层中，如题中共有2,3,4三个子节点，只要让贡献高度最大的即2排在最右边，此时第二层子节点值为3（子节点个数）+1（第二层子节点各自下一层子节点的最大值）。我们用vector的二维数组，其中tree[i]  中存放着以i节点为父节点的节点标号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 1e6+5</span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; tree[(<span class="hljs-type">int</span>)maxn];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> &#123;<br><span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tree[node].size(); i++) &#123;<br><span class="hljs-type">int</span> value = dfs(tree[node][i]);<br>max = (max &lt; value) ? value : max;<br>&#125;<br><span class="hljs-keyword">return</span> max + tree[node].size();<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> n;<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-type">int</span> j;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;j);<br>tree[j].push_back(i);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dfs(<span class="hljs-number">1</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例题二-受伤的皇后">例题二 受伤的皇后</h4><p>有一个 n×n 的国际象棋棋盘（n 行 n 列的方格图），请在棋盘中摆放 n 个受伤的国际象棋皇后，要求：</p><p>任何两个皇后不在同一行。<br>任何两个皇后不在同一列。<br>如果两个皇后在同一条 45 度角的斜线上，这两个皇后之间行号的差值至少为 3 。<br>请问一共有多少种摆放方案。</p><p>输入描述<br>输入的第一行包含一个整数 n。</p><p>其中，1≤n≤10。</p><p>输出描述<br>输出一个整数，表示答案。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> line[<span class="hljs-number">15</span>]; <span class="hljs-comment">//代表某一行在第几列</span><br><span class="hljs-type">int</span> row[<span class="hljs-number">15</span>];  <span class="hljs-comment">// row[i] 代表第i列是否被放置</span><br><span class="hljs-type">int</span> n, sum;<br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> deep)</span> &#123;      <span class="hljs-comment">//deep 代表当前在存第几行</span><br><span class="hljs-keyword">if</span> (deep == n+<span class="hljs-number">1</span>) &#123;<br>sum++;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (row[i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;      <span class="hljs-comment">//第i列已经被放置了</span><br><span class="hljs-keyword">if</span> ((deep &gt;= <span class="hljs-number">2</span> &amp;&amp; line[deep - <span class="hljs-number">1</span>] == i + <span class="hljs-number">1</span>) || (deep &gt;= <span class="hljs-number">3</span> &amp;&amp; line[deep - <span class="hljs-number">2</span>] == i + <span class="hljs-number">2</span>))<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 看一看副对角线（斜率为1的对角线）是否符合条件</span><br><span class="hljs-keyword">if</span> ((deep &gt;= <span class="hljs-number">2</span> &amp;&amp; i &gt;= <span class="hljs-number">2</span> &amp;&amp; line[deep - <span class="hljs-number">1</span>] == i - <span class="hljs-number">1</span>) || (deep &gt;= <span class="hljs-number">3</span> &amp;&amp; i &gt;= <span class="hljs-number">3</span> &amp;&amp; line[deep - <span class="hljs-number">2</span>] == i - <span class="hljs-number">2</span>))<span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 看一看主对角线（斜率为-1的对角线）是否符合条件</span><br>row[i] = <span class="hljs-number">1</span>;    <span class="hljs-comment">//deep行存储到第i列</span><br>line[deep] = i;<br>dfs(deep + <span class="hljs-number">1</span>);<br>row[i] = <span class="hljs-number">0</span>;     <span class="hljs-comment">//还原</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>dfs(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OS-lab1</title>
    <link href="/2023/03/20/OSlab1/"/>
    <url>/2023/03/20/OSlab1/</url>
    
    <content type="html"><![CDATA[<hr><h1>上机</h1><h2 id="1-lab1-exam：">1.lab1-exam：</h2><p>​      在lab1课下分支的基础上，扩展printk函数，增加新的格式字符串&quot;%[flags] [width] [length]R&quot;,从参数表中得到两个参数，两个参数当做“%[flags] [width] [length]d”输出，具体输出形式为&quot;(参数1,参数2)“。例如printk(”%4R&quot;, 2023, 2023); 输出为&quot;(2023,2023)&quot;。只需要switch代码段增加一个case即可，类似两个case：d。<strong>记着输出完第一个参数，要把neg_flag归0。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br>        <span class="hljs-keyword">if</span>(long_flag) &#123;<br>                               num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);          \\第一个参数<br>       nun = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);                      \\第二个参数，记得声明 <span class="hljs-type">long</span> nun<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>                               num = va_arg(ap, <span class="hljs-type">int</span>);<br>       nun = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>                        <span class="hljs-keyword">if</span>(num &lt;<span class="hljs-number">0</span>)&#123;<br>                                 num = -num;<br> neg_flag = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">char</span> kuo1[] = <span class="hljs-string">&quot;(\0&quot;</span>;<br><span class="hljs-type">char</span> kuo2[] = <span class="hljs-string">&quot;)\0&quot;</span>;<br><span class="hljs-type">char</span> dou[] = <span class="hljs-string">&quot;,\0&quot;</span>;<br>                        out(data, kuo1, <span class="hljs-number">1</span>);        <br>print_num(out, data, num, <span class="hljs-number">10</span>, neg_flag,width,ladjust,padc,<span class="hljs-number">0</span>);<br>out(data, dou, <span class="hljs-number">1</span>);<br>neg_flag = <span class="hljs-number">0</span>;            <span class="hljs-comment">//输出完第一个参数，记得初始neg_flag</span><br><span class="hljs-keyword">if</span>(nun &lt;<span class="hljs-number">0</span>)&#123;<br>                              nun = -nun;<br>      neg_flag = <span class="hljs-number">1</span>;<br>&#125;<br>print_num(out, data, nun, <span class="hljs-number">10</span>, neg_flag,width,ladjust,padc,<span class="hljs-number">0</span>);<br>out(data, kuo2, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><h2 id="2-la1-extra">2.la1-extra</h2><p>​         我们在lab1课下实现的printk是把格式字符串输出到终端，extra的目标是实现sprintf函数，把要输出的内容弄到缓冲区（就是到目标字符串buf），printk的原理为：调用vptintfmt解析fmt，真正的输出是把outputk函数（在vprintfmt传入output函数作为一个参数）。注意到vprintfmt第二个参数为NULL，在声明的时候第二个形参为void * data。第一个参数函数称为回调函数，第二个参数称为回调上下文，在printk并没有用到data。我们可以借助vprintfmt函数，第一个参数传入自定义的函数，第二个参数传入buf（当前缓冲区所在的位置）。我们要实现的自定义函数就是类似的outputk，只不过功能不是输出，而是把写入到当前缓冲区的位置，这时候你突然发现当前文件下memcpy函数已经实现了！！！为了可以一直更新data，我们只需要在所有需要缓冲的地方让data加上缓冲的字符串长度。还有一个小问题是，由于在vprintfmt函数中还调用了print_str, print_char, print_num在这三个函数中，为了把更新后的data传回vprintfmt，我把这三个函数的类型改为void*，然后返回值为更新后的data。<strong>需要注意在vprintfmt对data更新的时候，要先判断data是不是NULL，因为printk也会调用vprintfmt，但传入的data为NULL。其实要写的东西不多，仔细一点就好</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * fmt, ...)</span>&#123;<br>     <span class="hljs-type">void</span> *start = buf;<br>      va_list ap;<br>      va_start(ap, fmt);<br>      vprintfmt(memcpy2, buf, fmt,ap );<br>      va_end(ap);<br>      <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <br>     <span class="hljs-keyword">while</span>(*(<span class="hljs-type">char</span> *)start!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;        <br>           i++;<br>   start++;<br>     &#125;<br> <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n)</span> &#123;<br><span class="hljs-type">void</span> *dstaddr = dst;<br><span class="hljs-type">void</span> *max = dst + n;<br><br><span class="hljs-keyword">if</span> (((u_long)src &amp; <span class="hljs-number">3</span>) != ((u_long)dst &amp; <span class="hljs-number">3</span>)) &#123;<br><span class="hljs-keyword">while</span> (dst &lt; max) &#123;<br>*(<span class="hljs-type">char</span> *)dst++ = *(<span class="hljs-type">char</span> *)src++;<br>&#125;<br><span class="hljs-keyword">return</span> dstaddr;<br>&#125;<br><br><span class="hljs-keyword">while</span> (((u_long)dst &amp; <span class="hljs-number">3</span>) &amp;&amp; dst &lt; max) &#123;<br>*(<span class="hljs-type">char</span> *)dst++ = *(<span class="hljs-type">char</span> *)src++;<br>&#125;<br><br><span class="hljs-comment">// copy machine words while possible</span><br><span class="hljs-keyword">while</span> (dst + <span class="hljs-number">4</span> &lt;= max) &#123;<br>*(<span class="hljs-type">uint32_t</span> *)dst = *(<span class="hljs-type">uint32_t</span> *)src;<br>dst += <span class="hljs-number">4</span>;<br>src += <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-comment">// finish the remaining 0-3 bytes</span><br><span class="hljs-keyword">while</span> (dst &lt; max) &#123;<br>*(<span class="hljs-type">char</span> *)dst++ = *(<span class="hljs-type">char</span> *)src++;<br>&#125;<br><span class="hljs-keyword">return</span> dstaddr;<br>&#125;<br><br><br><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vprintfmt</span><span class="hljs-params">(<span class="hljs-type">fmt_callback_t</span> out, <span class="hljs-type">void</span> *data, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, va_list ap)</span> &#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *s;<br><span class="hljs-type">long</span> num;<br><br><span class="hljs-type">int</span> width;<br><span class="hljs-type">int</span> long_flag; <span class="hljs-comment">// output is long (rather than int)</span><br><span class="hljs-type">int</span> neg_flag;  <span class="hljs-comment">// output is negative</span><br><span class="hljs-type">int</span> ladjust;   <span class="hljs-comment">// output is left-aligned</span><br><span class="hljs-type">char</span> padc;     <span class="hljs-comment">// padding char</span><br><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-comment">/* scan for the next &#x27;%&#x27; */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (1/8) */</span><br>        <span class="hljs-keyword">while</span>(*fmt!=<span class="hljs-string">&#x27;%&#x27;</span>&amp;&amp;*fmt!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>out(data,fmt,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(data!=<span class="hljs-literal">NULL</span>)&#123;<br>data++;<br>&#125;<br>fmt++;<br>&#125;<br><span class="hljs-comment">/* flush the string found so far */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (2/8) */</span><br><br><span class="hljs-comment">/* check &quot;are we hitting the end?&quot; */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (3/8) */</span><br>        <span class="hljs-keyword">if</span>(*fmt == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br><span class="hljs-keyword">if</span>(data!=<span class="hljs-literal">NULL</span>)&#123;<br>                      *(<span class="hljs-type">char</span> *)data = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <br>&#125;<br><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">/* we found a &#x27;%&#x27; */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (4/8) */</span><br>fmt++;<br>ladjust = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(*fmt == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            ladjust = <span class="hljs-number">1</span>;<br>fmt++;<br>&#125;<br><span class="hljs-comment">/* check format flag */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (5/8) */</span><br>padc = <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">if</span> (*fmt == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            padc = <span class="hljs-string">&#x27;0&#x27;</span>;<br>fmt++;<br>&#125;<br><span class="hljs-comment">/* get width */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (6/8) */</span><br>width = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(isDigit(*fmt))&#123;<br>            width *= <span class="hljs-number">10</span>;<br>width += cToD(*fmt);<br>fmt++;<br>&#125;<br><br><span class="hljs-comment">/* check for long */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (7/8) */</span><br>long_flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(*fmt == <span class="hljs-string">&#x27;l&#x27;</span>)&#123;<br>long_flag = <span class="hljs-number">1</span>;<br>fmt++;<br>&#125;<br><br>neg_flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">switch</span> (*fmt) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>            <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">0</span>)&#123;<br>num = -num;<br>neg_flag = <span class="hljs-number">1</span>;<br>&#125;<br>data =print_num(out,data,num,<span class="hljs-number">10</span>,neg_flag,width,ladjust,padc,<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Refer to other parts (case &#x27;b&#x27;, case &#x27;o&#x27;, etc.) and func &#x27;print_num&#x27; to</span><br><span class="hljs-comment"> * complete this part. Think the differences between case &#x27;d&#x27; and the</span><br><span class="hljs-comment"> * others. (hint: &#x27;neg_flag&#x27;).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (8/8) */</span><br><br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;O&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;U&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>c = (<span class="hljs-type">char</span>)va_arg(ap, <span class="hljs-type">int</span>);<br>data = print_char(out, data, c, width, ladjust);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>s = (<span class="hljs-type">char</span> *)va_arg(ap, <span class="hljs-type">char</span> *);<br>data =  print_str(out, data, s, width, ladjust);<br><span class="hljs-keyword">break</span>;<br>  <br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\0&#x27;</span>:<br>fmt--;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">/* output this char as it is */</span><br>out(data, fmt, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(data!=<span class="hljs-literal">NULL</span>)&#123;<br>                                data++;<br>&#125;<br>&#125;<br>fmt++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>lab1思考题</h1><hr><h2 id="一、Thinking">一、Thinking</h2><h3 id="thinking1-1">thinking1.1</h3><p>​        x86交叉编译链：解决编译链程序和目标程序运行环境不同的问题，如在x86环境上使用编译工具进行编译汇编链接，而生成的程序需要运行在ARM开发板上</p><p>​         readelf：显示可执行程序的elf文件信息</p><p>​         objdump：显示程序信息，函数汇编等，常用于调试</p><p>​                              objdump -h **.o 可查看目标文件的结构和内容<br>​                              objdump -S      反汇编  -d可以16进制显示</p><p>​         LD（link script）：主要是用来描述输入文件中的节（section）是如何映射到输出文件的，并且控制输出文件的内存布局（memory layout）；源代码会编译成为目标对象文件（object file），每个对象文件中包含一系列的段（section），为LD的输入文件。</p><h3 id="thinking1-2">thinking1.2</h3><img src="/2023/03/20/OSlab1/2.0.png" class><p>发现在编译hello和readelf时的编译选项并不同</p><img src="/2023/03/20/OSlab1/2.1.png" class><img src="/2023/03/20/OSlab1/2.2.png" class><p>1.static：使用自带的readelf工具发现readelf文件类型为 DYN(Position-Independent Executable file),地址独立可执行文件，这是linux的一种保护方式，可以使程序在任意地址装载。hello则为简单的可执行文件，地址固定。</p><p>2.-32m：在我们的环境中，32位的程序运行的速度会更快，加上-32m选项，编译链接生成32位可执行程序，但是我们自己的readelf只能读64位。但是x86自带交叉编译工具readelf则可以读32位。</p><h3 id="thinking1-3">thinking1.3</h3><p>启动分为两过程，硬件启动和软件启动，硬件启动的入口地址是由硬件决定的，之后才是我们内核也即软件启动，将ELF加载到内存中，此时内核入口由我们自定义的链接器决定。两个入口的含义是不一样的。</p><hr><h2 id="二、实验难点">二、实验难点</h2><h3 id="1-理解我们内核镜像的结构">1.理解我们内核镜像的结构</h3><img src="/2023/03/20/OSlab1/3.1.png" class><p>我们的开始是在stage2初始化CPU和内核栈，之后便调到init中的mips_init 函数用于初始化内核，我们在lab1中完成的仅仅是打印</p><h3 id="2-readelf的补充">2.readelf的补充</h3><p>由ELF的文件地址计算节头表的地址时需要用 binary(const void *)如果用ehdr，ehdr + off，得到的是ehdr偏移ehdr大小的地址</p><h3 id="3-源码的阅读">3.源码的阅读</h3><hr><h2 id="三、实验感想">三、实验感想</h2><h4 id="1-我们现在的mos非常简单，操作系统也非常抽象，在之后的实验中，必须要多读源码，在理解的基础上逐步实现我们的mos">1.我们现在的mos非常简单，操作系统也非常抽象，在之后的实验中，必须要多读源码，在理解的基础上逐步实现我们的mos</h4><h4 id="2-对于mos的makefile并不太熟悉，课下要多下功夫，多读源码。实验的整体难度尚可。">2.对于mos的makefile并不太熟悉，课下要多下功夫，多读源码。实验的整体难度尚可。</h4>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>lab1</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-lab0</title>
    <link href="/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<hr><h1>实验报告</h1><h2 id="lab0思考题">lab0思考题</h2><h3 id="thinking0-1">thinking0.1</h3><pre><code class="hljs">不一样，在新建README.txt时候，处于Untracked状态，文件第二行显示&quot;Untracked files&quot;。当add 追踪再修改处于已修改状态,Modified.txt显示&quot;Changes not staged for commit&quot;，此时使用add命令进入Stage区。这两次add的功能并不相同，第一次是追踪，第二次是提交修改。</code></pre><h3 id="thinking0-2">thinking0.2</h3><img src="/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/Git.png" class><pre><code class="hljs">Add the file --&gt; git addStage the file --&gt; git addcommit --&gt; git commit</code></pre><h3 id="thinking0-3">thinking0.3</h3><pre><code class="hljs">1.git checkout -- print.c2.git reset HEAD print.c3.git rm --cached print.c</code></pre><h3 id="thinking0-4">thinking0.4</h3><img src="/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/thinking0.4.png" class><pre><code class="hljs">3 hashcode:d5b5d0e2008b045060fc390388ed88519e3378572 hashcode:3afeaf4e09d5ebb5a811f24dfd9e8357b47d021b1 hashcode:8e72b92edb7dd5370ab5ce48d270a9a32ebf78aagit reset --hard HEAD^ 显示当前在版本2git reset --hard 8e72b92edb7dd5370ab5ce48d270a9a32ebf78aa显示在版本1git reset --hard d5b5d0e2008b045060fc390388ed88519e337857又返回到版本3</code></pre><h3 id="thinking0-5">thinking0.5</h3><pre><code class="hljs">echo first直接在shell输出firstecho second &gt; output.txt 将second输出到output中，若文件已存在并替换原来的内容echo third &gt; output.txt 同理，output中只有thirdecho forth &gt;&gt; output.txt 将forth写到output原有内容之后，此时文件中显示thirdforth</code></pre><h3 id="thinking0-6">thinking0.6</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>：<br> 1 <span class="hljs-built_in">echo</span> Shell Start<br>  2 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> a = 1<br>  3 a=1<br>  4 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> b = 2<br>  5 b=2<br>  6 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> c = a+b<br>  7 c=$[<span class="hljs-variable">$a</span>+<span class="hljs-variable">$b</span>]<br>  8 <span class="hljs-built_in">echo</span> c = <span class="hljs-variable">$c</span><br>  9 <span class="hljs-built_in">echo</span> save c to ./file1<br> 10 <span class="hljs-built_in">echo</span> <span class="hljs-variable">$c</span>&gt;file1<br> 11 <span class="hljs-built_in">echo</span> save b to ./file2<br> 12 <span class="hljs-built_in">echo</span> <span class="hljs-variable">$b</span>&gt;file2<br> 13 <span class="hljs-built_in">echo</span> save a to ./file3<br> 14 <span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span>&gt;file3<br> 15 <span class="hljs-built_in">echo</span> save file1 file2 file3 to file4<br> 16 <span class="hljs-built_in">cat</span> file1&gt;file4<br> 17 <span class="hljs-built_in">cat</span> file2&gt;&gt;file4<br> 18 <span class="hljs-built_in">cat</span> file3&gt;&gt;file4<br> 19 <span class="hljs-built_in">echo</span> save file4 to ./result<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span>：<br>  1 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> Shell Start &gt; <span class="hljs-built_in">test</span><br>  2 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> a = 1 &gt;&gt; <span class="hljs-built_in">test</span><br>  3 <span class="hljs-built_in">echo</span> a=1 &gt;&gt; <span class="hljs-built_in">test</span><br>  4 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> b = 2 &gt;&gt; <span class="hljs-built_in">test</span><br>  5 <span class="hljs-built_in">echo</span> b=2 &gt;&gt; <span class="hljs-built_in">test</span><br>  6 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> c = a+b &gt;&gt;<span class="hljs-built_in">test</span><br>  7 <span class="hljs-built_in">echo</span> c=<span class="hljs-string">&#x27;$[$a+$b]&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br>  8 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> c = <span class="hljs-string">&#x27;$c&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br>  9 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save c to ./file1 &gt;&gt; <span class="hljs-built_in">test</span><br> 10 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$c&gt;&#x27;</span>file1 &gt;&gt;<span class="hljs-built_in">test</span><br> 11 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save b to ./file2 &gt;&gt; <span class="hljs-built_in">test</span><br> 12 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$b&gt;&#x27;</span>file2 &gt;&gt;<span class="hljs-built_in">test</span><br> 13 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save a to ./file3 &gt;&gt; <span class="hljs-built_in">test</span><br> 14 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$a&gt;&#x27;</span>file3 &gt;&gt;<span class="hljs-built_in">test</span><br> 15 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save file1 file2 file3 to file4 &gt;&gt; <span class="hljs-built_in">test</span><br> 16 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">cat</span> file1<span class="hljs-string">&#x27;&gt;&#x27;</span>file4  &gt;&gt; <span class="hljs-built_in">test</span><br> 17 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">cat</span> file2<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>file4 &gt;&gt; <span class="hljs-built_in">test</span><br> 18 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">cat</span> file3<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>file4 &gt;&gt;<span class="hljs-built_in">test</span><br> 19 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save file4 to ./result &gt;&gt;<span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><hr><h2 id="难点分析">难点分析</h2><h3 id="Exercise0-1">Exercise0.1</h3><pre><code class="hljs">sed -n（安静模式）即只输出经过sed修改后的内容</code></pre><h3 id="Exercise0-2">Exercise0.2</h3><pre><code class="hljs">在bash可执行文件中，熟悉文法结构，每一条都是命令，所以if while中的参数也是命令，-ne，-eq等命令，且须注意在关系成立时返回0，与常规语言不同。</code></pre><h3 id="Exercise0-3">Exercise0.3</h3><pre><code class="hljs">使用grep和awk指令结合使用，可以使用创建中间文件然后再删除，也可以使用管道重定向即一行写完：grep -n $2 $1 | awk -F: '&#123;print $1&#125;' &gt; $3</code></pre><h3 id="Exercise0-4">Exercise0.4</h3><pre><code class="hljs">2.1存在一个调用子目录的Makefile：cd  childDir &amp;&amp; $(MAKE)2.2链接操作：gcc code/fibo.o code/main.o -o fibo2.3头文件不在当前目录gcc -c fibo.c -o fibo.o -I ../include 使用-I参数（预处理过程中需要替换#include中文件头）所以在汇编的第一步预处理过程中也是需要fibo.h头文件</code></pre><hr><h2 id="实验体会">实验体会</h2><h3 id="实验的基本要求与目的：">实验的基本要求与目的：</h3><pre><code class="hljs">1.lab0主要是对一些工具使用的熟悉，文本编辑三剑客grep awk sed最基本的功能2.对Git的简单原理和拓展指令熟悉使用3.命令行运用，可执行文件边写</code></pre><h3 id="实验感受">实验感受</h3><pre><code class="hljs">1.使用命令行虽不及图形操作直观方便，但是更加简洁，对git版本控制的理解也会进一步加深，需要在抽象能力与文件管理能力2.对c语言文件一步一步成为可执行文件的理解进一步加深，比如在预处理的时候也是需要头文件的，这是只是声明，在链接的过程中才会定义。3.使用命令行处理文本时也会更加方便简洁，是一个很好使用的工具。4.无论是编程还是都要保证每一个字符每一条命令的正确性。</code></pre>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OO第一单元总结</title>
    <link href="/2023/03/18/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/2023/03/18/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<hr><h1>OO 第一单元总结</h1><hr><p>本文为OO第一单元总结，本单元主要任务是表达式的展开与化简。核心思想是递归下降法，主要分为预处理、解析、多项式生成、化简四个个核心步骤。三次作业增量迭代的要求如下</p><ul><li><p>第一次作业</p><ul><li>去括号<ul><li>一层括号</li></ul></li><li>多项式化简</li></ul></li><li><p>第二次作业</p><ul><li>括号嵌套</li><li>自定义函数<ul><li>无递归定义，有递归调用</li></ul></li><li>新增三角函数因子</li></ul></li><li><p>第三次作业</p><ul><li><p>自定义函数</p><ul><li>递归声明与调用</li></ul></li><li><p>新增求导因子</p><ul><li>仅出现一次</li></ul></li></ul></li></ul><h2 id="一、程序结构">一、程序结构</h2><h3 id="1-类图-第三次作业">1.类图(第三次作业)</h3><pre><code class=" mermaid">classDiagramMain --&gt; StrHandler : preprocess the input by the method&quot;strHandler&quot;Main --&gt; Parser : parse the input by the method&quot;parseExpr&quot;Main --&gt; Poly : print the result by the method&quot;getPrint&quot;StrHandler --&gt; Func : replace the input&#x27;s functions with exprclass Main&#123;      +main()$&#125;class StrHandler&#123;      +strHandler()$ String      +parseFunc()$ String      +funcHandle()$ String      +findBracket()$ int      +remZero()$ String      +noSignNum()$ String      +noBracket()$ boolean      +isNum()$ boolean      +isTurnNeg()$ boolean&#125;class Func &#123;      -String content      -int sum      -HashMap~Integer, String~ parameters      +getSum() int      +funcStruct() coid      +getContent() String&#125;Parser --&gt; Factor : Parse the factor(Expr/Term/Factor)by LexerParser ..&gt; Lexer : contains Poly ..&gt; Mono : containsFactor --&gt; Poly : turn to Poly from Factor by the method &quot;getPoly()&quot;class Poly &#123;      -int sign      -ArrayList~Mono~ monos      +turnNeg() void      +addPoly() void      +addMono() void      +multPoly() Poly      +getPrint() String&#125;class Mono &#123;      -int sign      -BigInteger con      -BigInteger xin      -BigInteger yin      -BigInteger zin      -HashMap~String,BigInteger~ sins      -HashMap~String,BigInteger~ coss      +setMono() void      +clearHash() void      +turnNeg() void      +addSame() void      +mulMono() Mono      +addTris() void      +addSin() void      +addCos() void      +isSame() boolean      +isSameFang() boolean      +getPrint() String      +printTri() String      +compareTo() int            &#125;class Parser&#123;      -Lexer lexer      +parseExpr() Expr      +parseTerm() Term      +parseFac() Factor      +parseDer() Deri      +parseSin() Sin      +parseCos() Cos&#125;Factor &lt;|-- ExprFactor &lt;|-- TermFactor &lt;|-- CosFactor &lt;|-- SinFactor &lt;|-- NumFactor &lt;|-- VarFactor &lt;|-- DeriFactor &lt;|-- Powerclass Factor&#123;      -int sign      +getSign() int      +setSign() void      +getPoly() Poly      +derivation() Poly&#125;class Lexer&#123;      -String input      -int pos      -String curToken      +next() void      +getNum String      +getCurToken() String      &#125;class Expr&#123;      -int sign      -ArrayList~Term~ terms      +addTerm() void      +getPoly() Poly      +derivation() Poly&#125;class Term&#123;  -int sign  -ArrayList~Factor~ factors  +addFac void  +getPoly Poly  +derivation() Poly  &#125;class Power &#123;      -Expr base      -BigInteger index      -Poly basePoly      +getPoly() Poly      +derivation() Poly&#125;class Cos&#123;  -int sign  -Factor parameter  -BigInteger index  -Poly selfPoly  -String paraStr  +setIndex() void  +getPoly() Poly  +derivation() Poly  +setParameter void  &#125;class Sin&#123;  -int sign  -Factor parameter  -BigInteger index  -Poly selfPoly  -String paraStr  +setIndex() void  +getPoly() Poly  +derivation() Poly  +setParameter void  &#125;class Num&#123;      -int sign      -BigInteger value      +getPoly() Poly      +derivation() Poly&#125;class Var&#123;      -String name      +getPoly() Poly      +derivation() Poly&#125;class Deri&#123;      -int sign      -String fac      -Expr expr      +setFac() void      +setExp() void      +getPoly() Poly      +derivation() Poly&#125;</code></pre><h2 id="2-代码结构">2.代码结构</h2><h3 id="2-1代码行数">2.1代码行数</h3><table><thead><tr><th>Source File</th><th>Total   Lines</th><th>Source Code Lines</th><th>Source Code Line[%]</th><th>Comment Lines</th><th>Comment Lines[%]</th><th>Blank Lines</th><th>Blank Lines[%]</th></tr></thead><tbody><tr><td>Factor.java</td><td>22</td><td>17</td><td>0.7727272727272727</td><td>0</td><td>0.0</td><td>5</td><td>0.22727272727272727</td></tr><tr><td>Deri.java</td><td>24</td><td>19</td><td>0.7916666666666666</td><td>0</td><td>0.0</td><td>5</td><td>0.20833333333333334</td></tr><tr><td>Main.java</td><td>28</td><td>27</td><td>0.9642857142857143</td><td>0</td><td>0.0</td><td>1</td><td>0.03571428571428571</td></tr><tr><td>Num.java</td><td>32</td><td>27</td><td>0.84375</td><td>0</td><td>0.0</td><td>5</td><td>0.15625</td></tr><tr><td>Expr.java</td><td>39</td><td>32</td><td>0.8205128205128205</td><td>0</td><td>0.0</td><td>7</td><td>0.1794871794871795</td></tr><tr><td>Var.java</td><td>44</td><td>39</td><td>0.8863636363636364</td><td>0</td><td>0.0</td><td>5</td><td>0.11363636363636363</td></tr><tr><td>Func.java</td><td>45</td><td>41</td><td>0.9111111111111111</td><td>0</td><td>0.0</td><td>4</td><td>0.08888888888888889</td></tr><tr><td>Term.java</td><td>48</td><td>42</td><td>0.875</td><td>0</td><td>0.0</td><td>6</td><td>0.125</td></tr><tr><td>Power.java</td><td>54</td><td>47</td><td>0.8703703703703703</td><td>0</td><td>0.0</td><td>7</td><td>0.12962962962962962</td></tr><tr><td>Lexer.java</td><td>66</td><td>58</td><td>0.8787878787878788</td><td>0</td><td>0.0</td><td>8</td><td>0.12121212121212122</td></tr><tr><td>Poly.java</td><td>77</td><td>69</td><td>0.8961038961038961</td><td>0</td><td>0.0</td><td>8</td><td>0.1038961038961039</td></tr><tr><td>Cos.java</td><td>98</td><td>90</td><td>0.9183673469387755</td><td>0</td><td>0.0</td><td>8</td><td>0.08163265306122448</td></tr><tr><td>Sin.java</td><td>102</td><td>95</td><td>0.9313725490196079</td><td>0</td><td>0.0</td><td>7</td><td>0.06862745098039216</td></tr><tr><td>Parser.java</td><td>151</td><td>140</td><td>0.9271523178807947</td><td>0</td><td>0.0</td><td>11</td><td>0.0728476821192053</td></tr><tr><td>StrHandler.java</td><td>245</td><td>228</td><td>0.9306122448979591</td><td>1</td><td>0.004081632653061225</td><td>16</td><td>0.0653061224489796</td></tr><tr><td>Mono.java</td><td>315</td><td>295</td><td>0.9365079365079365</td><td>0</td><td>0.0</td><td>20</td><td>0.06349206349206349</td></tr></tbody></table><p>###2.2方法</p><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Cos.Cos()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Cos.derivation(String)</td><td>5</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Cos.getIndex()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Cos.getPoly()</td><td>8</td><td>1</td><td>6</td><td>6</td></tr><tr><td>Cos.setIndex(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Cos.setParameter(Factor)</td><td>4</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Deri.derivation(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Deri.getPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Deri.setExp(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Deri.setFac(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.Expr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Expr.addTerm(Term, int)”</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.derivation(String)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Expr.getPoly()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Factor.derivation(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Factor.getPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Factor.getSign()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Factor.setSign(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Func.funcStruct(String, HashMap&lt;String, Func&gt;)”</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Func.getContent(String[])</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Func.getSum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.Lexer(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getCurToken()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getNum()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Lexer.getPos()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.isSign()</td><td>4</td><td>3</td><td>3</td><td>5</td></tr><tr><td>Lexer.next()</td><td>9</td><td>2</td><td>3</td><td>8</td></tr><tr><td>Main.main(String[])</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Mono.Mono()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mono.Mono(Mono)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Mono.addCos(String, BigInteger)”</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Mono.addSame(Mono)</td><td>6</td><td>1</td><td>7</td><td>7</td></tr><tr><td>“Mono.addSin(String, BigInteger)”</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Mono.addTris(Mono)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Mono.clearHash()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mono.compareTo(Mono)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Mono.getPrint(int, int)”</td><td>28</td><td>3</td><td>20</td><td>22</td></tr><tr><td>Mono.isFang(Mono)</td><td>34</td><td>9</td><td>15</td><td>15</td></tr><tr><td>Mono.isSame(Mono)</td><td>4</td><td>3</td><td>2</td><td>4</td></tr><tr><td>Mono.isSameFang(Mono)</td><td>2</td><td>2</td><td>1</td><td>2</td></tr><tr><td>Mono.mulMono(Mono)</td><td>8</td><td>1</td><td>7</td><td>7</td></tr><tr><td>Mono.printTri(int)</td><td>47</td><td>1</td><td>17</td><td>17</td></tr><tr><td>“Mono.setMono(BigInteger, BigInteger, BigInteger, BigInteger, int)”</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mono.turnNeg()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Num.Num(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Num.derivation(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Num.getPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.Parser(Lexer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.paresDer(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.paresSin(int)</td><td>1</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Parser.parseCos(int)</td><td>1</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Parser.parseExpr()</td><td>7</td><td>1</td><td>4</td><td>5</td></tr><tr><td>Parser.parseFac()</td><td>15</td><td>8</td><td>11</td><td>11</td></tr><tr><td>Parser.parseTerm()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Poly.Poly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.addMono(Mono)</td><td>10</td><td>5</td><td>5</td><td>6</td></tr><tr><td>Poly.addPoly(Poly)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Poly.getPrint()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Poly.mulPoly(Poly)</td><td>3</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.turnNeg()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>“Power.Power(Factor, String)”</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Power.derivation(String)</td><td>4</td><td>2</td><td>3</td><td>3</td></tr><tr><td>Power.getPoly()</td><td>2</td><td>2</td><td>2</td><td>3</td></tr><tr><td>Sin.Sin()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Sin.derivation(String)</td><td>5</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Sin.getIndex()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Sin.getPoly()</td><td>8</td><td>1</td><td>6</td><td>6</td></tr><tr><td>Sin.setIndex(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Sin.setParameter(Factor)</td><td>9</td><td>1</td><td>6</td><td>6</td></tr><tr><td>StrHandler.findBracket(String)</td><td>7</td><td>5</td><td>1</td><td>5</td></tr><tr><td>“StrHandler.funcHandle(String, HashMap&lt;String, Func&gt;)”</td><td>5</td><td>1</td><td>3</td><td>5</td></tr><tr><td>StrHandler.isNum(String)</td><td>5</td><td>4</td><td>1</td><td>5</td></tr><tr><td>StrHandler.isTurnNeg(String)</td><td>9</td><td>1</td><td>1</td><td>9</td></tr><tr><td>StrHandler.noBracket(String)</td><td>12</td><td>2</td><td>1</td><td>9</td></tr><tr><td>StrHandler.noSign(String)</td><td>3</td><td>3</td><td>3</td><td>4</td></tr><tr><td>StrHandler.noSignNum(String)</td><td>8</td><td>4</td><td>3</td><td>8</td></tr><tr><td>StrHandler.noZero(String)</td><td>3</td><td>2</td><td>2</td><td>4</td></tr><tr><td>“StrHandler.parseFunc(String, HashMap&lt;String, Func&gt;)”</td><td>12</td><td>1</td><td>5</td><td>7</td></tr><tr><td>StrHandler.strHandler(String)</td><td>17</td><td>1</td><td>4</td><td>8</td></tr><tr><td>“StrHandler.strHandler(String, HashMap&lt;String, Func&gt;)”</td><td>17</td><td>1</td><td>4</td><td>8</td></tr><tr><td>Term.Term()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.addFac(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.derivation(String)</td><td>7</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Term.getPoly()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Var.Var(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.derivation(String)</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Var.getPoly()</td><td>3</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Total</td><td>359</td><td>136</td><td>247</td><td>307</td></tr><tr><td>Average</td><td>4.13</td><td>1.56</td><td>2.84</td><td>3.53</td></tr></tbody></table><p>###2.3类</p><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Cos</td><td>2.83</td><td>6</td><td>17</td></tr><tr><td>Deri</td><td>1.00</td><td>1</td><td>4</td></tr><tr><td>Expr</td><td>2.00</td><td>3</td><td>8</td></tr><tr><td>Factor</td><td>1.00</td><td>1</td><td>4</td></tr><tr><td>Func</td><td>2.00</td><td>3</td><td>6</td></tr><tr><td>Lexer</td><td>2.50</td><td>7</td><td>15</td></tr><tr><td>Main</td><td>3.00</td><td>3</td><td>3</td></tr><tr><td>Mono</td><td>4.50</td><td>17</td><td>72</td></tr><tr><td>Num</td><td>1.00</td><td>1</td><td>3</td></tr><tr><td>Parser</td><td>3.00</td><td>9</td><td>21</td></tr><tr><td>Poly</td><td>2.83</td><td>6</td><td>17</td></tr><tr><td>Power</td><td>2.33</td><td>3</td><td>7</td></tr><tr><td>Sin</td><td>3.17</td><td>6</td><td>19</td></tr><tr><td>StrHandler</td><td>5.18</td><td>7</td><td>57</td></tr><tr><td>Term</td><td>2.50</td><td>5</td><td>10</td></tr><tr><td>Var</td><td>2.33</td><td>4</td><td>7</td></tr><tr><td>Total</td><td></td><td></td><td>270</td></tr><tr><td>Average</td><td>3.10</td><td>5.12</td><td>16.88</td></tr></tbody></table><h2 id="二、核心架构">二、核心架构</h2><h3 id="1-表达式">1.表达式</h3><pre><code class=" mermaid">graph TBExpr --&gt; Term_1Expr --&gt; Term_2Expr --&gt; Term_nTerm_1 --&gt; Factor_1Term_1 --&gt; Factor_2Term_1 --&gt; Factor_3Term_1 --&gt; Factor_4Term_1 --&gt; Factor_5Term_1 --&gt; Factor_6Term_1 --&gt; Factor_7Factor_2 --&gt; p_exprFactor_2 --&gt; p_numFactor_3 --&gt; d_exprFactor_3 --&gt; d_varFactor_4 --&gt; s_facFactor_4 --&gt; s_indexFactor_5 --&gt; c_facFactor_5 --&gt; c_indexExpr((Expr))Term_1((Term_1))Term_2((Term_2))Term_n((Term_n))Factor_1((Expr))Factor_2((Power))Factor_3((Deri))Factor_4((Sin))Factor_5((Cos))Factor_6((Var))Factor_7((Num))p_expr((Expr))p_num((index))d_expr((Expr))d_var((var))s_fac((Factor))s_index((index))c_fac((Factor))c_index((index))</code></pre><h3 id="2-多项式">2.多项式</h3><pre><code class=" mermaid">graph LRExpr((Expr))Term1((Term_1))Term2((Term_2))Termn((Term_n))Factor1((Factor_1))Factor2((Factor_2))Factorn((Factor_n))Expr --&gt; Term1Expr --&gt; Term2Expr --&gt; TermnTerm1 --&gt; Factor1Term1 --&gt; Factor2Term1 --&gt; FactornFactor1 --getPoly--&gt; fp1((Poly1))Factor2 --getPoly--&gt; fp2((Poly2))Factorn --getPoly--&gt; fpn((Polyn))tp1((newPoly1))tp2((newPoly2))tpn((newPolyn))fp1 --multPoly--&gt; tp1fp2 --multPoly--&gt; tp1fpn --multPoly--&gt; tp1Term2 --Factors getPoly multPoly--&gt;tp2Termn --Factors getPoly multPoly--&gt;tpnep1((resultPoly))tp1 --&gt; ep1tp2 --&gt; ep1tpn --&gt; ep1</code></pre><h3 id="3-数学公式">3.数学公式</h3><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>P</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><mi>f</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>P</mi><mi>o</mi><mi>l</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">resultPoly = \sum_{i=0}^n \prod_{j=0}^m factorPoly</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">res</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.13889em;">ltP</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0652em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span></p><h3 id="4-架构设计体验">4.架构设计体验</h3><h4 id="第一次作业">第一次作业</h4><pre><code class="hljs">    第一次作业比较简单，但由于考虑到之后的迭代开发，还是选择了递归下降，此时的代码可以处理括号嵌套的表达式。预处理包括：去除多余的正负号仅保留必要的符号、去除空白符和制表符、将**替换为^；词法语法解析的整体思路参考了练习作业提供的代码；化简在计算的过程中进行，Mono的标准形式为 Mono = ax^i^y^j^z^k^，在单项式计算的时候采用深克隆</code></pre><h4 id="第二次作业">第二次作业</h4><pre><code class="hljs">     第二次迭代增加了括号嵌套、自定义函数、三角函数因子。递归下降已经解决括号嵌套；对于自定义函数将其放到预处理中，也用递归下降先对自定义函数进行表达式化简，之后替换；在Mono中添加两个HashMap&lt;String, index&gt;分别记录三角函数的参数与指数，Mono的标准形式变为：$Mono = ax^i^y^j^z^k^ \prod^&#123;i=0&#125; sin \prod^&#123;i=0&#125; cos$。判断同列项（除了常数）去掉常数项后的字符串比较，为了保证sin（x+y）和sin（y+x）能够化简，在Poly的getPrint方法中，需要先对mono实现comparable接口重写比较方法。</code></pre><h4 id="第三次作业">第三次作业</h4><pre><code class="hljs">     第三次迭代增加了自定义函数的递归调用、求导因子。自定义函数只需要在预处理的过程中像处理第二次表达式的方式处理即可；求导因子我们就当做新加因子，在表达式getPoly的时候处理，利用求导法则分别写出Expr、Term、其他因子的求导方法即可。    由于第二次优化没有做多少，所以第三次最主要是两个优化，sin（y-x）+sin（x-y）和sin^2^+cos^2^。第一个比较好做，只需要在打印三角函数参数的时候依据正负号的数量和字符串比较来实现；第二个优化类似同列项判断，在Mono相加的时候遍历两个三角函数HashMap，判断另一个Mono中去掉相应的项之后的是否为同类项。此时便会出现新情况，例如：sin(x)*cos(x)+sin(x)^3^*cos(x)+cos(x)^3^*sin(x) 化简时出现新的同类项，对此我的做法是递归化简（乱起的名），以上述为例，先将后两项相加得到Mono：sin(x)*cos(x)，之后在Poly中删除刚刚化简得到的Mono，再将该Mono加入Poly中，发现同类项合并得到2*sin(x)*cos(x), 重复上述过程，删除2*sin(x)*cos(x)，再加到Poly中发现没有同类项，到此合并完成。</code></pre><h3 id="5-架构的优缺点">5.架构的优缺点</h3><ul><li><p>优点</p><ul><li>求导因子，在求导因子生成多项式的时候再处理，可以复用之前的Poly相乘和相加的方法，且不会涉及深浅克隆问题</li><li>三角函数存储方式为String，这样优点很明显，比如仅需要调用一次内层因子的打印函数</li><li>边计算边化简，递归化简会比单独写一个化简函数方便，也更符合程序的流程</li><li>可以处理求导因子的嵌套</li></ul></li><li><p>缺点</p><ul><li>对于自定义函数应该也当做因子处理，在解析的过程中替换，而不是在预处理中替换</li><li>由于父类Factor拥有属性sign，但是在解析中真正有正负的只有Num和Term，其他的都默认为符号为1。在我的架构中埋下了隐患，这会在下面谈到</li></ul></li></ul><h3 id="三、Bug">三、Bug</h3><ul><li>第一次<ul><li>互测竟然没有挨刀，在系数为1的时候，特判条件太多，造成漏洞，1 * y * z输出yz</li><li>0-x+x没有输出，这是因为-x+x合并完之后产生新的同类项，但是这个在互测和强测都没有测出来，自己也没注意到</li></ul></li><li>第二次<ul><li>1-x+x，哎，第一次作业埋的雷</li><li>sin(0) ** 0=0  在判断的时候先判断了sin参数是否为0</li><li>x**21 输出为x* * x1  直接对Mono输出的字符串直接进行替换</li></ul></li><li>第三次<ul><li>dx(sin((-x))) 输出cos(x)  承接上文我的架构，由于我的sin因子里有Factor属性，Poly属性（Factor生成），在提负号到外面的时候只改变了Poly的符号（将所有Mono变号），但是没有把Factor变号。就算变号，由于（-x）是表达式因子，而在我的架构中表达式默认符号为正</li></ul></li><li>总结出现的bug<ul><li>if特判条件，能否把所有的情况都考虑到，是否会漏到一些情况，应该优点判断那些情况</li><li>直接对字符串处理是一件愚蠢至极的方法</li><li>迭代产生的bug，大多数都是复用之前的方法导致错误</li></ul></li></ul><h2 id="四、Hack策略">四、Hack策略</h2><p>列举一些hack成功的例子</p><ul><li><p>边界条件</p><ul><li><p>sin((-x)) --&gt; sin(-x)</p></li><li><pre><code class="hljs">1f(x)=cos(cos(cos(cos(x))))sin(sin(cos(cos(cos(cos(cos(cos(dx(f(x)))))))))) --&gt; TLE                 利用cost条件实现TLE<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br><span class="hljs-comment">*  求导因子出现的位置，对特殊的因子求导</span><br><br><span class="hljs-comment">  * ```</span><br>    1<br>    <span class="hljs-built_in">f</span>(x,y) = ((+x))**2+y<br>    -dx(<span class="hljs-built_in">f</span>(y,0))+y<br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="hljs">2f(x,y,z)=x-(y+z)g(x,z,y)=-dz((y-z)**2)-(f(0,-1,+1)-g(x**+0,x**+2,x**01))<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><br>* ```<br>  <span class="hljs-number">2</span><br>  <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-variable">x</span>) = <span class="hljs-title">sin</span>(<span class="hljs-title">cos</span>(<span class="hljs-variable">x</span>))</span><br>  <span class="hljs-function"><span class="hljs-title">g</span>(<span class="hljs-variable">y</span> ) = <span class="hljs-title">dy</span>(<span class="hljs-title">f</span>(<span class="hljs-variable">y</span>))</span><br>  <span class="hljs-function"><span class="hljs-title">g</span>(<span class="hljs-variable">y</span>)</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h2 id="五、心得体会">五、心得体会</h2><pre><code class="hljs">  在第一次和第二次我几乎都没怎么做测试，第三次测试也只是把第二次数据改了改添加了求导因子，然后和室友python对拍，结果就是三次作业都有bug，下周说什么也得把评测机写出来。在写代码的时候尽量保证程序正义性，再结合随机测试数据和评测机才是正道！！   复用之前的方法很容易出bug，接口的实现尤为重要，对于每个方法都需要清楚知道输入限制及方法的作用，迭代之后是否还能接着用。慢工出细活，写OO还是得抽出连续大量的时间，且要长时间专注。递归下降确实好用，但就是感觉缺少了一点面向对象的思想，第一单元感觉就像是数据结构哈哈哈哈。感觉评测没有上学期的OOpre覆盖性强，一个点就好几千上万条数据，bug还得靠互测。</code></pre><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OO</tag>
      
      <tag>总结</tag>
      
      <tag>递归下降</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
