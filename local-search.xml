<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OO第二单元总结</title>
    <link href="/2023/04/17/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/17/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1>OO 第二单元总结</h1><p>本文为OO 第二单元电梯作业总结，本单元主要是掌握多线程和线程安全。三次作业总的架构类似，可分为输入线程、调度线程、电梯线程。三次作业的增量迭代如下</p><ul><li>第五次作业<ul><li>六部电梯</li></ul></li><li>第六次作业<ul><li>可选择增加电梯，电梯的初始属性可变</li><li>维修电梯，将维修电梯的乘客重新安排</li></ul></li><li>第七次作业<ul><li>新增电梯增加可达性、</li><li>信号量的使用</li></ul></li></ul><h2 id="一、同步块和锁">一、同步块和锁</h2><p>由于我的架构还算完善，所以每次增量较为容易，在第五次作业中使用的java语言特性synchronized，所以在后续中并没有使用读写锁等更符合本单元作业的方法。</p><h3 id="1-同步块和锁的选择">1.同步块和锁的选择</h3><p>我选择的是修饰方法，这样避免修饰代码块从而效率更高。同步块出现的原因是因为不同线程可能同时对一个对象进行读写，因此判断哪些代码需要放到同步块中，只需看一下不同线程对哪些共有对象进行了读写。有以下三种情况：</p><ul><li>读读<ul><li>一定不会造成线程安全</li></ul></li><li>读写<ul><li>具体分析<ul><li>调度器线程模拟电梯运行的时候，需要读取电梯当前楼层状态不需要加锁，避免了当前电梯所在线程在sleep从而被阻塞</li><li>总的请求表WaitQueue的getEnd和setEnd是需要加锁的，避免了调度器线程读到没有结束但同时输入线程刚好结束，造成调度器一直等待没有被唤醒</li></ul></li></ul></li><li>写写<ul><li>一定要加锁</li></ul></li></ul><img src="/2023/04/17/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/1.png" class><p>由上图和上述策略，我们知道同步重点在总的请求表和各个电梯的请求表，也就是对象锁</p><h3 id="2-避免死锁、轮询、无效notify">2. 避免死锁、轮询、无效notify</h3><p>死锁的出现是由于下列情况造成，当然在我的架构中只需要判断同步方法中是否又调用了其他对象的同步方法即可（并不存在）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aMethod</span><span class="hljs-params">()</span>&#123;<br>       b.bMethod();<br>   &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bMethod</span><span class="hljs-params">()</span>&#123;<br>       a.aMethod();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在本单元作业中出现CTLE的原因可能是轮询和死循环，要注意线程的终止条件和wait条件，避免出现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a1Method</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">try</span>&#123;<br>          wait();<br>      &#125;<span class="hljs-keyword">catch</span>()&#123;<br>          <br>      &#125;<br>       notifyAll();<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a2Method</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">try</span>&#123;<br>          wait();<br>      &#125;<span class="hljs-keyword">catch</span>()&#123;<br>          <br>      &#125;<br>       notifyAll();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>避免无效notify，例如，WaitQueue在等待时，只有加请求和setEnd的时候notify</p><h2 id="二、调度">二、调度</h2><p>在往届性能评定中并没有电量这一指标，也就是说只要能把人越快送到越好。在考虑到电量之后就需要调度器的设计。以第七次作业为例调度器的中心工作：从总表中读取请求并处理，如果是乘客请求进行模拟，通过策略选择要把此请求放到哪个电梯</p><h3 id="1-调度器模拟">1.调度器模拟</h3><p>对于一个请求，我们把它分别放到每一个电梯中，并模拟这种情况的耗时，只需要把原来电梯中所有的sleep换成time++即可，次过程在NightElelvator类中night方法返回把当前表中所有乘客送完总耗时，假如有6部电梯，我们一共需要模拟12次，6（电梯数量）* 2（加此请求和不加此请求）。</p><p>前两次作业中，为了加快模拟速度，我为每一部电梯模拟加此请求和不加此请求开了一个线程，但是在第七次作业却报了OutOfMeomory线程开太多了，虽然RAM用的远远少于限制，第八次作业我又改成了并行化</p><h3 id="2-调度器策略">2.调度器策略</h3><p>本质都是贪心思想，仅作出在当前情况下的最优解</p><ul><li>第五次作业我用的是电梯运送此乘客所花费的最小值，这样考虑的是用电量和运送时间，即模拟把这个请求加到此电梯队列中所花费的时间减去不加此请求所花费的时间</li><li>第六次第七次我用的是所有电梯结束的最短时间，考虑的是乘客等待时间和电梯总体运行时间，即模拟把此请求放到某一部电梯，它和其他电梯运行的结束时间，然后去最短的结束时间</li><li>第七次中我用了迪杰斯塔拉算法，把11层看成11个点，然后求最短路径，然后从这条路径从后往前找到第一个能从起点直达终点的中间点，用图做的话，可以自定义距离，比如我有一个请求从1楼到4楼，无法直达，可选1-2-4或1-3-4，但1-3和3-4的电梯数量更多，因此选择第二条路径，然后用第二种策略模拟。本次作业距离定义：$ dis = $</li></ul><p>在第五第六次作业性能分中这两种策略差不多，第七次中应该是第二种更好。</p><h2 id="三、架构">三、架构</h2><h3 id="1-UML类图-以第三次为例">1.UML类图(以第三次为例)</h3><pre><code class=" mermaid">classDiagramMain --&gt; InputThread : startMain --&gt; Schedule : startMain --&gt; ElevatorThread : startElevatorThread --&gt; Elevator : runInputThread --&gt; WaitQueue : addRequestSchedule --&gt; WaitQueue : getRequestSchedule --&gt; RequestTable : dispatchElevator --&gt; RequestTable : getRequestRequestTable --&gt; CusRequest : containElevator --&gt; Check : judgeclass Main&#123;      +main()$&#125;class InputThread&#123;      -WaitQueue waitQueue      +run() void&#125;class Schedule&#123;      -WaitQueue waitQueue      -HashMap&lt;Integer,Elevator&gt; elevators      -HashMap&lt;Intrger,RequestTable&gt; outRequestTables      -HashMap&lt;Integer,RequestTable&gt; inRequestTables      -HashMap&lt;Integer,Check&gt; checks      +run() void      +addEage() void      +imitate() int      +dispatch() void&#125;class Elevator&#123;      -int id      -int capacity      -double speed      -int access      -String status      -int floor      -int lastTime      -int direction      -blooean isMaintain      -HashMap&lt;Integer,Check&gt;checks      -RequestTable outRequestTable      -RequestTable inRequestTable      -WaitQueue waitqueue      -int[] accFloor      +getAccess() boolean      +setIsMaintain() void      +getIsMaintain() boolean      +updateDir() void      +getStatus() String      +setStatus() void      +maintainAct() void      +restAct() void      +openAct() void      +closeAct() void      +moveAct() void      +arriveAct() void      +getOff() void      +getOn() void      +clone() NightElevator&#125;class ElevatorThread&#123;      -Elevator elevator      +run() void&#125;class CusRequest&#123;      -int id      -int start      -int destination      -int realDes      +setRealDes() void      +setDestination() void      +getDestination() int      +getStart() int      +getDirection() int&#125;class Check&#123;      -int mx      -int nx      -int nowMx      -int nowNx      +only() void      +other() void      +endOnly() void      +endOther() void&#125;class WaitQueue&#123;      -ArrayList&lt;Request&gt; requests      -boolean isEnd      -HashMap&lt;Integer,Integer&gt; cus      -int maintainSum      +addCus() void      +remCus() void      +isPerEnd() boolean      +addPerRequest() void      +addChange() void      +addEleRequest() void      +addMainRequest() void      +addMaintain() void      +subMaintain() void      +getMaintainSum() int      +getRequest() Rqeuest      +setEnd() void      +isEnd() boolean      +isEmpty() boolean      +getPos() int      +addRequestTable() void&#125;class RequestTable&#123;      -boolean isEnd      -ArrayList&lt;CusRequest&gt; cusRequests      +setEnd() void      +isEnd() boolean      +isEmpty() boolean      +getSize() int      +addInRequest() void      +addOutRequest() void      +getLastRequest() CusRequest      +getOneRequest() CusRequest      +remRequest() void      +outWait() void      +outNotify() void      +isHaveOn() boolean      +isHavaOff() boolean      +getOnRequest() CusRequest      +getOffRequest() CusRequest      +getFetchStart() int      +getInDirection() int      +clone() RequestTable      &#125;</code></pre><h3 id="2-UML协作图-第三次作业">2.UML协作图(第三次作业)</h3><pre><code class=" mermaid">sequenceDiagramparticipant M as Mainparticipant I as InputThreadparticipant S as Scheduleparticipant E as ElevatorM -&gt;&gt; I : startM -&gt;&gt; S : startM -&gt;&gt; E : startI -&gt;&gt;+ S : addRequestalt[is PerRequest]S -&gt;&gt;+ E : dispatch and addRequestE -&gt;&gt; E : not transfer and get offE -&gt;&gt;- S : is tranfer and dispatch againelse[is AddElevator]S -&gt;&gt;+ E : new Elevator and startE --&gt;&gt;- S : ;else[is Maintain]S -&gt;&gt; + E : setIsMaintainE --&gt;&gt;-S : put the passengers to scheduleendS --&gt;&gt;- I: ;I -&gt;&gt;+ S : setEndS -&gt;&gt;+ E : if empty &amp;&amp; end then setEndE -&gt;&gt; E : if empty &amp;&amp; end then turn endE --&gt;&gt;- S : ;S --&gt;&gt;- I : ;</code></pre><h3 id="3-架构与迭代">3.架构与迭代</h3><h4 id="架构">架构</h4><ul><li>第五次作业<ul><li>输入线程将请求传入WaitQueue，Schedule读取并模拟加到电梯表中，电梯采取ALS策略</li><li>电梯有outRequestTable和inRequestTable，分别存放电梯外和电梯内的请求</li><li>电梯运行为有限状态机</li><li>结束条件<ul><li>ThreadInput 当前请求为null</li><li>Schedule <code>waitQueue.isEmpty() &amp;&amp; waitQueue.isEnd()</code></li><li>Elevator <code>outRequestTable.isEmpty() &amp;&amp; inRequestTable.isEmpty() &amp;&amp; outRequestTable.isEnd()</code></li></ul></li></ul></li><li>第六次作业<ul><li>调整电梯参数</li><li>结束条件<ul><li>ThreadInput 当前请求为null</li><li>Schedule <code>waitQueue.isEmpty() &amp;&amp; waitQueue.isEnd()&amp;&amp; waitQueue.getMaintainSum() == 0 </code>即需要判断电梯是否都响应了Maintain</li><li>Elevator <code>outRequestTable.isEmpty() &amp;&amp; inRequestTable.isEmpty() &amp;&amp; outRequestTable.isEnd()</code>或者维修</li></ul></li></ul></li><li>第七次作业<ul><li>可达性在调度器已经谈过</li><li>结束条件 Schedule <code>waitQueue.isEmpty() &amp;&amp; waitQueue.isEnd()&amp;&amp; waitQueue.getMaintainSum() == 0 &amp;&amp; cus.isEmpty()</code>cus是&lt;Integer,Integer&gt; 的hashMap，存放所有乘客的id和目的地，当乘客到站后将其删除</li><li>同一楼层服务数量由Check类执行，实现了类似信号量的方法</li></ul></li></ul><h4 id="电梯状态转换">电梯状态转换</h4><p>参考CO有限状态机，将电梯的行为和状态分为: end, rest, move, arrive, open, close,maintain。这样处理会在电梯线程的run中很清晰，不同状态执行不同操作并进行状态转换。</p><img src="/2023/04/17/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/2.png" class><h3 id="4-作业中稳定的内容和易变的内容">4.作业中稳定的内容和易变的内容</h3><p>整体的框架还是很完整，电梯线程变化的不多，加入了maintain新状态，在乘客下车时判断是否换乘</p><p>调度器变化最大，比如更换了策略类，Add和Maintain请求都是在调度器中处理；在第七次考虑可达性后，需要规划路线等等这些都是在调度器中完成。</p><h2 id="四、bug和debug">四、bug和debug</h2><h3 id="bug">bug</h3><p>由于第五次我就使用了调度器，导致模拟的时候可能会出现真实电梯move状态floor++但是仍在move，导致影子电梯的状态转化出现错误出现了死循环；第六次作业问题是线程资源紧张导致无法申请新的线程，还有问题是应当优先处理maintain请求和addElevator请求，出现了维修后移动超过两层的情况；第七次作业暂时没找到bug</p><h3 id="debug">debug</h3><p>大多数debug都是死循环的bug，这是由于线程一直在run没有结束，我使用JProfiler分析CPU时间从而定位出现问题的线程由于电梯运行是状态转移，因此也能轻松定位到出现问题的状态和方法。除此之外，线程无法结束我一般使用手工打断点，即在特定的语句出输出一些语句，这样可以判断是哪些线程没有结束，之后确定原因。</p><h2 id="五、心得体会">五、心得体会</h2><h3 id="1-线程安全">1. 线程安全</h3><h4 id="如非必要，勿增实体">如非必要，勿增实体</h4><p>线程之间共享的对象实体越少越好，这也就是奥卡姆剃刀的应用</p><h4 id="读写的具体判断">读写的具体判断</h4><p>在上文中已经提到有的读写是必要互斥的，有的则不必要，不能一味synchronized，也不能一律都用读写锁</p><h3 id="2-层次化设计">2.层次化设计</h3><h4 id="电梯线程的run">电梯线程的run</h4><p>这样比写很多的分支语句要清晰的多，也很容易迭代开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">switch</span> (elevator.getStatus()) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;end&quot;</span>:<br>                    <span class="hljs-keyword">return</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;rest&quot;</span>:<br>                    elevator.restAct();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;maintiain&quot;</span>:<br>                    elevator.maintainAct();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;open&quot;</span>:<br>                    elevator.openAct();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;close&quot;</span>:<br>                    elevator.closeAct();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;move&quot;</span>:<br>                    elevator.moveAct();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;arrive&quot;</span>:<br>                    elevator.arriveAct();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>####线程和面向对象</p><p>我将电梯线程和电梯分开，线程只是为其拥有的属性提供了运行的栈空间，因此将线程和具体的事物分离是很正确的，但调取器和调度线程为了简洁合为一个。面向对象的思想进一步加深。</p><h3 id="3-写在最后">3. 写在最后</h3><p>第五次作业为了死循环bug，最终甚至没进互测，无疑是对我的一次重大打击，bug虽小，但造成后果很严重。第五次作业投入的时间超过30小时，虽然分数不理想，但我对多线程的理解在其中也得到强化，第五次作业留下的良好架构让之后的作业少走了很多弯路（虽然之后两次还是有很长时间debug）。除此之外，debug能力也得到很大提升，通过错误数据以及断点设置，结合工具能够快速定位到问题代码，分析原因并修改。</p><p>还有一个很重要的问题，太过于依赖讨论区的评测机，在之后单元中，还是要自己写一些简易的评测机。软件的开发和测试都是尤为重要的环节，即使在未来不会从事软件行业，但测试还是一项很重要的内容。</p><p>体验失败，并战胜失败，愉快的面对每次作业</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OS-lab3</title>
    <link href="/2023/04/17/OS-lab3/"/>
    <url>/2023/04/17/OS-lab3/</url>
    
    <content type="html"><![CDATA[<h1>OS-lab3</h1><h2 id="上机">上机</h2><h3 id="exam">exam</h3><p>我们要修改调度函数，实现多用户的（公平）进程调度，就是在Env结构体了新加一个属性：u_int env_user（[0,4]）（测试程序会给你赋值），最多不超过5名用户。简言之，在需要调度新的进程的时候你需要统计每个用户的总时间片选，总时间片选保存static int[] 数组中，然后你需要选出当前有进程的用户并且总时间片选最少的（相同则id最小）的用户，然后选出遍历队列选出第一个当前用户的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">(<span class="hljs-type">int</span> yield)</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// remaining time slices of current env</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span> =</span> curenv;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> user_time[<span class="hljs-number">5</span>];             <span class="hljs-comment">//总时间片选</span><br><span class="hljs-type">int</span> able[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;       <span class="hljs-comment">//记录有进程的用户</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">temp</span>;</span><br>TAILQ_FOREACH(temp, &amp;env_sched_list, env_sched_link)<br>&#123;<br>able[temp-&gt;env_user] = <span class="hljs-number">1</span>;            <span class="hljs-comment">//循环队列，搜索所有有进程的用户</span><br>&#125;<br><span class="hljs-comment">/* We always decrease the &#x27;count&#x27; by 1.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If &#x27;yield&#x27; is set, or &#x27;count&#x27; has been decreased to 0, or &#x27;e&#x27; (previous &#x27;curenv&#x27;) is</span><br><span class="hljs-comment"> * &#x27;NULL&#x27;, or &#x27;e&#x27; is not runnable, then we pick up a new env from &#x27;env_sched_list&#x27; (list of</span><br><span class="hljs-comment"> * all runnable envs), set &#x27;count&#x27; to its priority, and schedule it with &#x27;env_run&#x27;. **Panic</span><br><span class="hljs-comment"> * if that list is empty**.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (Note that if &#x27;e&#x27; is still a runnable env, we should move it to the tail of</span><br><span class="hljs-comment"> * &#x27;env_sched_list&#x27; before picking up another env from its head, or we will schedule the</span><br><span class="hljs-comment"> * head env repeatedly.)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Otherwise, we simply schedule &#x27;e&#x27; again.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * You may want to use macros below:</span><br><span class="hljs-comment"> *   &#x27;TAILQ_FIRST&#x27;, &#x27;TAILQ_REMOVE&#x27;, &#x27;TAILQ_INSERT_TAIL&#x27;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Exercise 3.12: Your code here. */</span><br><span class="hljs-keyword">if</span> (yield || !e || !count || e-&gt;env_status != ENV_RUNNABLE)<br>&#123;<br><span class="hljs-keyword">if</span> (e != <span class="hljs-literal">NULL</span> &amp;&amp; e-&gt;env_status == ENV_RUNNABLE)<br>&#123;<br>TAILQ_REMOVE(&amp;env_sched_list, e, env_sched_link);<br>TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);<br>user_time[e-&gt;env_user] += e-&gt;env_pri;                <span class="hljs-comment">// 时间片选+=env_pri</span><br>&#125;<br><span class="hljs-keyword">if</span> (TAILQ_EMPTY(&amp;env_sched_list))<br>&#123;<br>panic(<span class="hljs-string">&quot;no runnable envs&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> flag = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> min = <span class="hljs-number">114514</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)                 <span class="hljs-comment">//遍历找到时间片最小的用户</span><br>&#123;<br><span class="hljs-keyword">if</span> (able[i] &amp;&amp; user_time[i] &lt; min)<br>&#123;<br>min = user_time[i];<br>flag = i;<br>&#125;<br>&#125;<br>TAILQ_FOREACH(temp, &amp;env_sched_list, env_sched_link)   <span class="hljs-comment">//找到当前用户队列中第一个进程，并run</span><br>&#123;<br><span class="hljs-keyword">if</span> (temp-&gt;env_user == flag)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>e = temp;<br>count = e-&gt;env_pri;<br>&#125;<br>&#125;<br>count--;<br>env_run(e);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="extra">extra</h3><p>完成overflow的异常处理</p><ul><li>请在完成异常处理函数后修改 lib/traps.c ，将你自己编写的异常处理函数加入异常向量组 中的对应位置。</li><li>大家可以使用 lib/genex.S 中定义的 BUILD_HANDLER 宏来构建自己的异常处理函数，构建方法可以参考已有的 handle_tlb 等处理函数。</li><li>异常处理（对应指令有三个add，sub，addi）<ul><li>对于addi，addi $t, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>i</mi><mi>m</mi><mi>m</mi><mo>:</mo><mtext>处理为</mtext></mrow><annotation encoding="application/x-tex">s, imm  : 处理为</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">imm</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">处理为</span></span></span></span>s = $t/2 + imm/2;  epc += 4；</li><li>add和sub，转换成addu和subu指令</li></ul></li></ul><p>难点是怎么从进程空间中取出指令，我们知道代码段对应页权限肯定没有PTE_D,因此在用户空间tlb访问就会异常，合理的方法是在内核态中异常处理函数，将进程中的env_va转换成物理地址，并将物理地址转换为kseg0地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_ov</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>u_long env_va = tf-&gt;cp0_epc;            <br>Pde *cpgdir = curenv-&gt;env_pgdir;<br>curenv-&gt;env_ov_cnt++;<br>Pte *pte;<br>pgdir_walk(cpgdir, env_va, <span class="hljs-number">0</span>, &amp;pte);         <span class="hljs-comment">//找到二级页表项</span><br>u_long va = KADDR((*pte &amp; ~(<span class="hljs-number">0xFFF</span>)) + (env_va &amp; <span class="hljs-number">0xFFF</span>));   <span class="hljs-comment">//转换为kseg0虚拟地址，记着*pte一定要取高20位，或者用宏PTE_ADDR,还要加上页内偏移</span><br>u_int ins = *(<span class="hljs-type">int</span> *)va;                   <span class="hljs-comment">//取指令</span><br><span class="hljs-keyword">if</span> (ins &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">29</span>))                 <br>&#123;                                           <span class="hljs-comment">// addi</span><br><span class="hljs-type">int</span> s = (ins &amp; (<span class="hljs-number">31</span> &lt;&lt; <span class="hljs-number">21</span>)) &gt;&gt; <span class="hljs-number">21</span>;         <span class="hljs-comment">//取s寄存器</span><br><span class="hljs-type">int</span> t = (ins &amp; (<span class="hljs-number">31</span> &lt;&lt; <span class="hljs-number">16</span>)) &gt;&gt; <span class="hljs-number">16</span>;          <span class="hljs-comment">//取t寄存器</span><br><span class="hljs-type">int</span> imm = ins &amp; (<span class="hljs-number">0xFFFF</span>);                  <span class="hljs-comment">//立即数</span><br>tf-&gt;regs[t] = tf-&gt;regs[s] / <span class="hljs-number">2</span> + imm / <span class="hljs-number">2</span>; <br>tf-&gt;cp0_epc += <span class="hljs-number">4</span>;<br>printk(<span class="hljs-string">&quot;addi ov handled\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ins &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>))<br>&#123;                                          <span class="hljs-comment">// sub</span><br>printk(<span class="hljs-string">&quot;sub ov handled\n&quot;</span>);<br>*(<span class="hljs-type">int</span> *)va = ins | <span class="hljs-number">1</span>;              <span class="hljs-comment">//指令改为subu</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;                                          <span class="hljs-comment">// add</span><br>printk(<span class="hljs-string">&quot;add ov handled\n&quot;</span>);<br>*(<span class="hljs-type">int</span> *)va = ins | <span class="hljs-number">1</span>;          <span class="hljs-comment">//改为addu</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实验报告">实验报告</h2><h3 id="一、思考题">一、思考题</h3><h4 id="thinking-3-1">thinking 3.1</h4><p>完成进程页目录的自映射，并且将标志位设置为有效</p><h4 id="thinking-3-2">thinking 3.2</h4><p>来自elf_laod_seg函数传入，利用回调函数将程序段加载到进程制定虚拟空间中，data参数是必须的，否则我们无法得到程序段的地址</p><h4 id="thinking-3-3">thinking 3.3</h4><ul><li>va是否是页对齐的</li><li>将全部短内容加载后，实际占用的filesize是否等于memsize，如果不是则需要申请新的页空间</li></ul><h4 id="thinking-3-4">thinking 3.4</h4><p>我们知道，进程切换是需要陷入内核态的，所以epc存储的是虚拟地址</p><h4 id="thinking-3-5">thinking 3.5</h4><p>在genex.S中</p><h4 id="thinking-3-6">thinking 3.6</h4><ul><li>enable_irq 设置cp0状态寄存器允许中断，即项CP0_STATUS写入(STATUS_CU0 | STATUS_IM4 | STATUS_IEc)</li><li>timer_irq  表示响应时钟中断，执行schedule函数</li></ul><h4 id="thinking-3-7">thinking 3.7</h4><p>先初始化时钟并且设置中断可相应，当时间片用完时表示要切换进程，发出中断陷入内核，进入handle_int函数，然后根据识别中断类型，是时钟中断然后跳转到schedule函数</p><h3 id="二、实验难点">二、实验难点</h3><h5 id="回调函数icode-mapper">回调函数icode_mapper</h5><p>根据elf_load_seg需要理解加载段内容到进程中可能碰到的情况，考虑是否也对齐</p><h5 id="env-setup-vm函数实现将envs和pages拷贝到用户空间">env_setup_vm函数实现将envs和pages拷贝到用户空间</h5><p>很抽象，首先pages和evs是放在内核态代码全局变量附近，完成将这两个放到用户态指定位置，我们知道用户态是通过tlb和页表访问的，所以只需要将这两个控制块所在的页映射到用户态能访问到的UTOP到UVPT之间（在map_segment实现）但这只是实现了从内核态到内核态的平移，目的是在进程页表初始化的时候复制到进程页表，这是很巧妙的复制方法，不同虚拟空间的数据拷贝</p><h5 id="schedule">schedule</h5><p>如果要切换进程，需要判断当前队列是否为空，当前进程的状态是否仍是RUNNABLE，如果是的话需要把它放到队尾。并且切换进程是env_run所干的事</p><h3 id="三、实验体会">三、实验体会</h3><p>经过lab0-lab3，发现linux系统实现的很巧妙，如果我们从0搭建一个操作系统真的是难上加难，所以要学习他们的思想，比如将一些很难得任务切分成小任务，然后对函数进行封装，比如加载段内容到进程中。</p><p>OS变得越来越抽象，想要学好必须要真正读懂，如果只是参考往届代码，根据提示补全代码，在上机的时候是肯定做不出来的，对于已经写好的宏和函数，要理解它们的功能和实现，在上机写的时候才能灵活应用</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>lab3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-lab2</title>
    <link href="/2023/04/03/OS-lab2/"/>
    <url>/2023/04/03/OS-lab2/</url>
    
    <content type="html"><![CDATA[<h1>lab2</h1><h2 id="上机">上机</h2><ul><li>lab2-exam 还是比较简单的，认真写肯定能对</li><li>lab2-extra 这是专门给佬出的题，我就只把题面放到这了，造福后人了</li></ul><h3 id="lab2-exam">lab2-exam</h3><ul><li>对于一个页表项，我们知道其存储的31-12位为物理页号，0-11是标志位，我们的任务是遍历整个页表的页表项，如果是有效页并且检查标志位perm_mask（可能是好几个标志位），如果都包含则计数，最后返回数量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">u_int <span class="hljs-title function_">page_perm_stat</span><span class="hljs-params">(Pde *pgdir, <span class="hljs-keyword">struct</span> Page *pp, u_int perm_mask)</span><br>&#123;<br>Pde *pd_entry;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (pd_entry = pgdir; i &lt; <span class="hljs-number">1024</span>; pd_entry++)       <span class="hljs-comment">//一层循环遍历所有的页目录项</span><br>&#123;<br>Pte *pt_entry;<br>i++;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> ((*pd_entry &amp; PTE_V) != <span class="hljs-number">0</span>) <span class="hljs-comment">//你的二级页表必须有效才能接着遍历</span><br>&#123;<br><span class="hljs-keyword">for</span> (pt_entry = (Pte *)KADDR(PTE_ADDR(*pd_entry)); j &lt; <span class="hljs-number">1024</span>; pt_entry++) <span class="hljs-comment">//遍历所有页表项</span><br>&#123;<br>j++;<br><span class="hljs-keyword">if</span> ((*pt_entry &amp; PTE_V) != <span class="hljs-number">0</span>)    <span class="hljs-comment">//有效</span><br>&#123;<br><span class="hljs-keyword">if</span> (((*pt_entry &amp; perm_mask) == perm_mask) &amp;&amp; (PTE_ADDR(*pt_entry) == page2pa(pp)))<br>&#123;                          <span class="hljs-comment">//之前因为PTE_V都是一位，所以直接&amp;运算不等于0就行，但是现在标志位可能有很多，必须是(*pt_entry &amp; perm_mask) == perm_mask才能说明包含给定的标志位</span><br>sum++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lab2-extra">lab2-extra</h3><p>真抽象，我觉得extra确实得有区分度，但是你得保证不能让绝大多数同学坐牢没一点收获吧。用机房的CLI是真难受，课下vscode用的是真爽，一个好的idea是优秀程序员的必备工具，CLI难蚌。</p><h3 id="题目背景">题目背景</h3><p>在理论课程中，我们学习了交换技术。它实现进程在内存与外存之间的交换，因而获得更多的虚拟内存空间。</p><p>简单来说，交换空间（swap）是外存上的一块区域，当系统物理内存不足时，内核会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中。这样相当于我们获得了更多的虚拟存储（通过使用一部分外存）。</p><p>在本题中，我们会实现一个较为简单的交换机制，使得在没有空闲的物理页面时，可以暂时将正在使用的一页内存换出，同时释放出一页物理页面用于使用。</p><p>题目描述<br>我们建立的交换机制可以分为两部分，“换入”部分，以及“换出”部分。</p><p>当我们没有空闲的物理页面时，我们进行“换出”，即申请物理页面时，如果没有可用的页面，我们换出一页正在使用的物理页，供申请者使用。</p><p>当我们需要访问某个 kuseg 段的虚拟地址时，我们会检查这个虚拟地址对应的虚拟页是否已被换出到外存，如果是，则我们将其“换入”。</p><p>虚拟页被换入的物理页可能与其被换出时不同，但需要保证换入后物理页中的数据以及页表项中的权限位与换出时相同。为此，我们需要在换出时利用外存来保存数据。</p><p>题目要求<br>在本题中，你需要使用物理地址属于 [0x3900000, 0x3910000) 的这 16 个物理页以及外存来实现“交换”。</p><p>在本题中我们把这 16 个物理页叫做可交换的物理页。<br>为了区分这些可交换的物理页，我们建立了一个新的空闲可交换页面链表 page_free_swapable_list。<br>同时，我们将提供部分代码（请参看实验提供代码部分），你需要将其粘贴至 kern/pmap.c 之后，并补全或者实现如下几个函数：</p><h3 id="提示">提示</h3><p>我们给出一种可行的设计，当然，你也可以略过本节自己进行设计。</p><p>当没有空闲的物理页时，我们需要进行换出操作。在本设计中，我们在页表项中增加了一个新的标志位 PTE_SWP（在下发的头文件 swap.h 中已有定义）。</p><p>当 PTE_SWP 为 1 且 PTE_V 为 0 时:<br>对应的虚拟地址映射到的物理内存有效但被换出，实际的内容存在外存上，该页表项的高 20 位为内容在外存上的外存页号。<br>软件应保证不会出现 PTE_SWP 为 1 且 PTE_V 为 1 的页表项。<br>当 PTE_SWP 为 0 时，页表项的含义与 Lab2 课下定义的相同。<br>我们可以通过 da / BY2PG 计算 da 对应的外存页号<br>当我们希望将某个虚拟地址对应的物理页从外存中换入内存时：</p><p>使用 swap_alloc 申请一个物理页 p<br>将外存中以 da 起始的一页内容拷贝到该物理页 p 上（da 为换出时内容在外存上的地址）<br>对指定页表中，所有“PTE_SWP 为 1 且 PTE_V 为 0 且高 20 位为 da 对应的外存页号”的页表项，做如下操作：<br>将 PTE_V 置 1<br>将 PTE_SWP 置 0<br>在高 20 位中填入 p 对应的物理页号<br>维持其它权限位不变<br>无效化旧 TLB 表项<br>使用 disk_free 释放 da 起始的一页外存空间<br>当我们需要换出一个内存中的物理页至外存时：</p><p>从 [0x3900000, 0x3910000) 的内存空间中，选择一个物理页 p<br>使用 disk_alloc 申请一页大小的外存空间，记该外存空间的起始地址为 da<br>对指定页表中，所有 PTE_V 为 1 且高 20 位为 p 的物理页号的页表项，做如下操作：<br>将 PTE_V 置 0<br>将 PTE_SWP 置 1<br>在高 20 位中填入 da 对应的外存页号<br>维持其它权限位不变<br>无效化旧 TLB 表项<br>将物理页 p 上的内容拷贝到外存中 da 起始的一页空间上<br>释放物理页 p，也就是将其插回 page_free_swapable_list 链表中<br>任务总结<br>在提交前，你需要完成以下任务：</p><p>换入部分：<br>完成 is_swapped 函数。<br>完成 swap 函数，维护 page_free_swapable_list 链表，适时无效化 TLB 中的旧表项。<br>换出部分：<br>完成 swap_alloc 函数，维护 page_free_swapable_list 链表，适时无效化 TLB 中的旧表项。<br>本题不涉及课下代码的修改。<br>Pte swap_lookup(Pde *pgdir, u_int asid, u_long va) {<br>// Step 1: If corresponding page is swapped out, swap it in<br>if (is_swapped(pgdir, va)) {<br>swap(pgdir, asid, va);<br>}</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;swap.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page_list</span> <span class="hljs-title">page_free_swapable_list</span>;</span><br><span class="hljs-type">static</span> u_char *<span class="hljs-title function_">disk_alloc</span><span class="hljs-params">()</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">disk_free</span><span class="hljs-params">(u_char *pdisk)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap_init</span><span class="hljs-params">()</span> &#123;<br>LIST_INIT(&amp;page_free_swapable_list);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = SWAP_PAGE_BASE; i &lt; SWAP_PAGE_END; i += BY2PG) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">pp</span> =</span> pa2page(i);<br>LIST_REMOVE(pp, pp_link);<br>LIST_INSERT_HEAD(&amp;page_free_swapable_list, pp, pp_link);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Interface for &#x27;Passive Swap Out&#x27;</span><br><span class="hljs-keyword">struct</span> Page *<span class="hljs-title function_">swap_alloc</span><span class="hljs-params">(Pde *pgdir, u_int asid)</span> &#123;<br><span class="hljs-comment">// Step 1: Ensure free page</span><br><span class="hljs-keyword">if</span> (LIST_EMPTY(&amp;page_free_swapable_list)) &#123;<br><span class="hljs-comment">/* Your Code Here (1/3) */</span><br>&#125;<br><br><span class="hljs-comment">// Step 2: Get a free page and clear it</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">pp</span> =</span> LIST_FIRST(&amp;page_free_swapable_list);<br>LIST_REMOVE(pp, pp_link);<br><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)page2kva(pp), <span class="hljs-number">0</span>, BY2PG);<br><br><span class="hljs-keyword">return</span> pp;<br>&#125;<br><br><span class="hljs-comment">// Interfaces for &#x27;Active Swap In&#x27;</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">is_swapped</span><span class="hljs-params">(Pde *pgdir, u_long va)</span> &#123;<br><span class="hljs-comment">/* Your Code Here (2/3) */</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(Pde *pgdir, u_int asid, u_long va)</span> &#123;<br><span class="hljs-comment">/* Your Code Here (3/3) */</span><br>&#125;<br><br>Pte <span class="hljs-title function_">swap_lookup</span><span class="hljs-params">(Pde *pgdir, u_int asid, u_long va)</span> &#123;<br><span class="hljs-comment">// Step 1: If corresponding page is swapped out, swap it in</span><br><span class="hljs-keyword">if</span> (is_swapped(pgdir, va)) &#123;<br>swap(pgdir, asid, va);<br>&#125;<br><br><span class="hljs-comment">// Step 2: Look up page table element.</span><br>Pte *ppte;<br>page_lookup(pgdir, va, &amp;ppte);<br><br><span class="hljs-comment">// Step 3: Return</span><br><span class="hljs-keyword">return</span> ppte == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : *ppte;<br>&#125;<br><br><span class="hljs-comment">// Disk Simulation (Do not modify)</span><br>u_char swap_disk[SWAP_DISK_NPAGE * BY2PG] __attribute__((aligned(BY2PG)));<br>u_char swap_disk_used[SWAP_DISK_NPAGE];<br><br><span class="hljs-type">static</span> u_char *<span class="hljs-title function_">disk_alloc</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> alloc = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (;alloc &lt; SWAP_DISK_NPAGE &amp;&amp; swap_disk_used[alloc]; alloc++) &#123;<br>;<br>&#125;<br>assert(alloc &lt; SWAP_DISK_NPAGE);<br>swap_disk_used[alloc] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> &amp;swap_disk[alloc * BY2PG];<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">disk_free</span><span class="hljs-params">(u_char *pdisk)</span> &#123;<br><span class="hljs-type">int</span> offset = pdisk - swap_disk;<br>assert(offset % BY2PG == <span class="hljs-number">0</span>);<br>swap_disk_used[offset / BY2PG] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="实验报告">实验报告</h2><h3 id="思考题">思考题</h3><h4 id="thinking-2-1">thinking 2.1</h4><p>都是虚拟地址</p><h4 id="thinking-2-2">thinking 2.2</h4><ul><li>复用性好，在之后操作系统中，如果需要建立双向链表，可以直接使用宏定义，对链表的一些操作很方便</li><li>没找见循环链表，除了实验中的双向链表外，还有一个tail queue，其实和双向链表差不多，知识在head维护了链表的首个元素和最后的元素。<ul><li>将元素插入到链表头部的时候，需要注意如果首个元素为NULL，则插入后的elm既是第一个有时第二个元素</li><li>插入链表尾部的时候，维护head中的tqe_last, 但是如果链表为空呢，也得维护tqe_first</li><li>插入到某个元素后面的时候，需要判断当前是不是tail，如果是，更新head的tqe_last</li><li>删除操作也是，判断是不是链表尾部</li></ul></li><li>我们发现这与我们常见的双向链表不一样，因为在filed.le_prev是一个指针的指针，存放的时候上一个元素field.le_next的指针，可能是为了既能做到插入元素，又可以保证访问顺序只能往下而不能往上吧</li></ul><h4 id="thinking-2-3">thinking 2.3</h4><p>c，我们发现head其实只装了链表的首个元素指针</p><h4 id="thinking-2-4">thinking 2.4</h4><ul><li>我们知道操作系统实现了多进程，让每个进程都认为自己独享“物理空间（实际是虚拟空间）”，但TLB只有一个，不同进程从虚拟空间到物理空间的映射不同，所以使用ASID，只有EntryHi中的虚拟页号和ASID与TLB中的KEY都相同才是对应的物理页号。</li><li>6位，对应256个不同地址空间</li></ul><h4 id="thinking-2-5">thinking 2.5</h4><ul><li><p>tlb_invalidate 调用 tlb_out</p></li><li><p>当我们建立页表物理映射时，原本的映射可能存在也可能不存在，如果存在且和要映射的物理页面不同|新申请的页，需要更新TLB，下次加载va所在页时，TLB会重新加载，即用时才加载</p></li><li><pre><code class="hljs">LEAF(tlb_out).set noreordermfc0    t0, CP0_ENTRYHI  //把之前寄存器保存一下mtc0    a0, CP0_ENTRYHI  //将a0即虚拟地址对应的虚拟页号存入到寄存器中nop/* Step 1: Use 'tlbp' to probe TLB entry *//* Exercise 2.8: Your code here. (1/2) */    tlbp                    //根据寄存器的虚拟页号和ASID，来查找TLB，若没找到，则index为负数nop/* Step 2: Fetch the probe result from CP0.Index */mfc0    t1, CP0_INDEX    //去除索引.set reorderbltz    t1, NO_SUCH_ENTRY //如果没找到就直接返回了.set noreordermtc0    zero, CP0_ENTRYHI  //找到的话，那就清空TLB对应项mtc0    zero, CP0_ENTRYLO0nop/* Step 3: Use 'tlbwi' to write CP0.EntryHi/Lo into TLB at CP0.Index  *//* Exercise 2.8: Your code here. (2/2) */    tlbwi                     //根据索引去请0.set reorderNO_SUCH_ENTRY:mtc0    t0, CP0_ENTRYHI   j       ra                //返回END(tlb_out)                 </code></pre></li></ul><h4 id="thinking-2-6">thinking 2.6</h4><img src="/2023/04/03/OS-lab2/x86.jpg" class><p>在x86架构中内存被分为三种形式，分别是<strong>逻辑地址</strong>（Logical Address），<strong>线性地址</strong>（Linear Address）和<strong>物理地址</strong>（Physical Address）。如上图所示，通过分段可以将逻辑地址转换为线性地址，而通过分页可以将线性地址转换为物理地址。逻辑地址由两部分构成，一部分是段选择器（Segment Selector），一部分是偏移（Offset）。段选择符存放在段寄存器中，如CS（存放代码段选择符）、SS（存放堆栈段选择符）、DS（存放数据段选择符）和ES、FS、GS（一般也用来存放数据段选择符）等；偏移与对应段描述符（由段选择符决定）中的基地址相加就是线性地址。全局描述符表（Global Descriptor Table）需要OS在初始化时创建（每个CPU都有一张，基本内容大致相同，除了少数几项如TSS），创建好后将表的地址（这是个线性地址）放到全局描述符寄存器中（GDTR），这通过LGDT和SGDT指令来完成。</p><h4 id="自映射">自映射</h4><p>为方便区分，记三级页表基地址为PTbase2， 二级页表基地址为PTbase1， 页目录基地址为PDbase</p><p>PTbase1 = PTbase2 &gt;&gt; 30 &lt;&lt; 21 + PTbase2 = PTbase2 &gt;&gt; 9 + PTbase2</p><p>PDbae = PTbase2 &gt;&gt; 9 &gt;&gt;21 &lt;&lt; 12 + PTbase1 = PTbase2 &gt;&gt; 18 + PTbase2 &gt;&gt; 9 + PTbase2</p><p>PDE = PTbase &gt;&gt; 27 + PTbase &gt;&gt; 18 + PTbase &gt;&gt; 9 + PTbase</p><hr><h3 id="实验难点">实验难点</h3><h4 id="物理地址和虚拟地址">物理地址和虚拟地址</h4><ul><li>在lab2中我们一直都处于内核态，我觉得这个就很抽象，导致2.1 - 2.5 始终对虚拟地址和物理地址搞不清，我们所写的代码都放在内核态，并不会影响我们对0x80400000之后空间的操作。然后我们时刻保持一个原则，所有的指针都是虚拟地址。比如page_init中，我们pages这个变量保存在内核态中，但所指的地址是在80400000，我们只是用pages来管理所对应的物理页。但是pages所指的地址存放了npage个page结构体，也就是说在前面的物理页中其实存放着page结构体。这样的话page_init就很好补充了</li><li>再如pgdir_walk,  传进来的pgdir是页目录的虚拟地址，我们可以很轻松的找到对应的页表项，如果creat为1，最开始我以为是让页表等于申请到的pp，这个时候就弄错了，页表是虚拟空间中的，所以应该是页目录项地址存储物理页号。先把物理地址转为虚拟地址，并且要按第十二位对齐，再加上二级页号偏移，最终 <code>ppte应该页表项的地址，*ppte = (*Pte)PTE_ADDR(KADDR(*pgdir)) + PTX(va)</code></li></ul><h4 id="双向链表">双向链表</h4><p>空闲链表是双向的，但le_prev确实上一个元素le_next的指针，我们并不能通过le_prev访问上一个元素，这样既可以保证单向性又能保证链表的插入删除操作得以进行。例如我们想把elm插入到list_elm的前面</p><pre><code class=" mermaid">graph LRprev(prev) -- le_next --&gt; now(list_elm)now -- le_next --&gt; next(next)now -- le_prev --&gt; prevnext -- le_pev --&gt; now</code></pre><p>elm-&gt;le_next(没有写pp_link，问题不大) = list_elm</p><p>elm-&gt;le_prev = list_elm-&gt;le_prev</p><p>*(list_elm-&gt;prev) = elm</p><p>list_elm-&gt;prev = &amp;(elm-&gt;le_next)</p><hr><h3 id="实验感受">实验感受</h3><ul><li>我觉得OS不是一蹴而就的写完，是需要大量仔细看实验指导书，然后看源码，2.6我做了看了三遍，做了三遍，每次看都以为自己会了，写完发现不对，然后再看再写。</li><li>复用性高的宏是真的方便，能让代码看的整洁并且结构清楚</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>lab2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯（1）</title>
    <link href="/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%881%EF%BC%89-1/"/>
    <url>/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%881%EF%BC%89-1/</url>
    
    <content type="html"><![CDATA[<h1>蓝桥杯（1）</h1><p>写在前面：去年裸考，想着今年好好准备一下，这几周天天被OS和OO折磨，一直拖到现在。看了一下往年题，填空题只要时间复杂度不是特别离谱，直接暴力模拟就行，编程题我主要总结一下常考的算法，由于现在还没上过算法课，好多东西也都不会，写这篇博客就当边学习边总结了。</p><h3 id="最短路径-Floyd算法和Dijkstra算法">最短路径 Floyd算法和Dijkstra算法</h3><img src="/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%881%EF%BC%89-1/path.jpg" class><p>Dijkstra主要用于求两点最短距离和最短路径，而且只能求出一条最短路径。</p><ul><li>首先初始化，我们用edge [2022] [2022]二维数组存储边的权值，本题中无边则权值为一个较大数；定义dis[2022]存储第一个点到各个点的最短距离，初始化为edge[1]；haveFind [2022] 记录是否找到从1到i的最短路径；path[2022]记录从1到此点的前一点</li><li>遍历dis从当前尚未找到最短路径的点中找到最小值，记此点为index，更新haveFind[index] = 1。</li><li>以flag为中间点，遍历如果(dis[index] + edge [index] [i] &lt;= dis[i])那么记dis[i] = dis[index] + edge [index] [i], 并且更新前继节点path[i] = index</li><li>直到index为路径终点结束循环</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> edge[<span class="hljs-number">2022</span>][<span class="hljs-number">2022</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">if</span> (a &lt; b) &#123;<br><span class="hljs-type">int</span> c = a;<br>a = b;<br>b = c;<br>&#125;<br><span class="hljs-keyword">return</span> (b == <span class="hljs-number">0</span>) ? a : gcd(b, a % b);<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> dis[<span class="hljs-number">2022</span>];       <span class="hljs-comment">// 存储着1到各个点最小距离</span><br><span class="hljs-type">int</span> haveFind[<span class="hljs-number">2022</span>];       <span class="hljs-comment">//如果找到了1到某个点的最小距离则该点记为1</span><br><span class="hljs-type">int</span> path[<span class="hljs-number">2022</span>];        <span class="hljs-comment">//比如path[2] = 3,那么改最短路径的前继节点为3</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> flag)</span> &#123;    <span class="hljs-comment">//打印路径</span><br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> lastFlag = path[flag];<br>printPath(lastFlag);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-%d&quot;</span>, flag);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;        <span class="hljs-comment">//初始化edge  </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2021</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(i - j) &gt; <span class="hljs-number">21</span>) &#123;<br>edge[i][j] = edge[j][i] = <span class="hljs-number">1145140000</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j) &#123;<br>edge[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>edge[i][j] = edge[j][i] = i * j / gcd(i, j);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;          <span class="hljs-comment">//初始化dis</span><br>dis[i] = edge[<span class="hljs-number">1</span>][i];<br>&#125;<br><span class="hljs-type">int</span> nowNode = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (nowNode != <span class="hljs-number">2021</span>) &#123;<br><span class="hljs-type">int</span> minDis = <span class="hljs-number">1145140000</span>;<br><span class="hljs-type">int</span> index = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (haveFind[i] != <span class="hljs-number">1</span> &amp;&amp; dis[i] &lt;= minDis) &#123;<br>minDis = dis[i];<br>index = i;<br>&#125;<br>&#125;<br>nowNode = index;<br>haveFind[index] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (haveFind[i] != <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (dis[index] + edge[index][i] &lt;= dis[i]) &#123;<br>dis[i] = dis[index] + edge[index][i];<br>path[i] = index;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, dis[<span class="hljs-number">2021</span>]);<br>printPath(<span class="hljs-number">2021</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Floyd算法更加暴力，可以求任意两点最短距离和路径</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> edge[<span class="hljs-number">2022</span>][<span class="hljs-number">2022</span>];<br><span class="hljs-type">int</span> path[<span class="hljs-number">2022</span>][<span class="hljs-number">2022</span>];<br><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">if</span> (a &lt; b) &#123;<br><span class="hljs-type">int</span> c = a;<br>a = b;<br>b = c;<br>&#125;<br><span class="hljs-keyword">return</span> (b == <span class="hljs-number">0</span>) ? a : gcd(b, a % b);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2021</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(i - j) &gt; <span class="hljs-number">21</span>) &#123;<br>edge[i][j] = edge[j][i] = <span class="hljs-number">1145140000</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j) &#123;<br>edge[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>edge[i][j] = edge[j][i] = i * j / gcd(i, j);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2021</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2021</span>; j++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">2021</span>; k++) &#123;<br><span class="hljs-keyword">if</span> (edge[j][i] + edge[i][k] &lt;= edge[j][k]) &#123;<br>edge[j][k] = edge[j][i] + edge[i][k];<br>path[j][k] = path[k][j] = i;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, edge[<span class="hljs-number">1</span>][<span class="hljs-number">2021</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DFS深度搜索">DFS深度搜索</h3><h4 id="例题一">例题一</h4><img src="/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%881%EF%BC%89-1/tree.jpg" class><p>其中N&lt;=100000</p><p>题中认为子节点是无序的，因此才有得到的二叉树不同，例如2放到左边和右边</p><pre><code class=" mermaid">graph TBsubgraph 二叉树2 left1a((1))1a--&gt;2a((2))2a--&gt;5a((5))2a--&gt;3a((3))3a--&gt;4a((4))endsubgraph 多叉树2 left1((1))1--&gt;2((2))1--&gt;3((3))1--&gt;4((4))2--&gt;5((5))endsubgraph 二叉树2 right1d((1))1d--&gt;3d((3))3d--&gt;4d((4))4d--&gt;2d((2))2d--&gt;5d((5))endsubgraph 多叉树2 right1b((1))1b--&gt;3b((3))1b--&gt;4b((4))1b--&gt;2b((2))2b--&gt;5b((5))end</code></pre><p>得到规律，在第二层中，如题中共有2,3,4三个子节点，只要让贡献高度最大的即2排在最右边，此时第二层子节点值为3（子节点个数）+1（第二层子节点各自下一层子节点的最大值）。我们用vector的二维数组，其中tree[i]  中存放着以i节点为父节点的节点标号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 1e6+5</span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; tree[(<span class="hljs-type">int</span>)maxn];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> &#123;<br><span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tree[node].size(); i++) &#123;<br><span class="hljs-type">int</span> value = dfs(tree[node][i]);<br>max = (max &lt; value) ? value : max;<br>&#125;<br><span class="hljs-keyword">return</span> max + tree[node].size();<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> n;<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-type">int</span> j;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;j);<br>tree[j].push_back(i);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dfs(<span class="hljs-number">1</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例题二-受伤的皇后">例题二 受伤的皇后</h4><p>有一个 n×n 的国际象棋棋盘（n 行 n 列的方格图），请在棋盘中摆放 n 个受伤的国际象棋皇后，要求：</p><p>任何两个皇后不在同一行。<br>任何两个皇后不在同一列。<br>如果两个皇后在同一条 45 度角的斜线上，这两个皇后之间行号的差值至少为 3 。<br>请问一共有多少种摆放方案。</p><p>输入描述<br>输入的第一行包含一个整数 n。</p><p>其中，1≤n≤10。</p><p>输出描述<br>输出一个整数，表示答案。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> line[<span class="hljs-number">15</span>]; <span class="hljs-comment">//代表某一行在第几列</span><br><span class="hljs-type">int</span> row[<span class="hljs-number">15</span>];  <span class="hljs-comment">// row[i] 代表第i列是否被放置</span><br><span class="hljs-type">int</span> n, sum;<br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> deep)</span> &#123;      <span class="hljs-comment">//deep 代表当前在存第几行</span><br><span class="hljs-keyword">if</span> (deep == n+<span class="hljs-number">1</span>) &#123;<br>sum++;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (row[i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;      <span class="hljs-comment">//第i列已经被放置了</span><br><span class="hljs-keyword">if</span> ((deep &gt;= <span class="hljs-number">2</span> &amp;&amp; line[deep - <span class="hljs-number">1</span>] == i + <span class="hljs-number">1</span>) || (deep &gt;= <span class="hljs-number">3</span> &amp;&amp; line[deep - <span class="hljs-number">2</span>] == i + <span class="hljs-number">2</span>))<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 看一看副对角线（斜率为1的对角线）是否符合条件</span><br><span class="hljs-keyword">if</span> ((deep &gt;= <span class="hljs-number">2</span> &amp;&amp; i &gt;= <span class="hljs-number">2</span> &amp;&amp; line[deep - <span class="hljs-number">1</span>] == i - <span class="hljs-number">1</span>) || (deep &gt;= <span class="hljs-number">3</span> &amp;&amp; i &gt;= <span class="hljs-number">3</span> &amp;&amp; line[deep - <span class="hljs-number">2</span>] == i - <span class="hljs-number">2</span>))<span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 看一看主对角线（斜率为-1的对角线）是否符合条件</span><br>row[i] = <span class="hljs-number">1</span>;    <span class="hljs-comment">//deep行存储到第i列</span><br>line[deep] = i;<br>dfs(deep + <span class="hljs-number">1</span>);<br>row[i] = <span class="hljs-number">0</span>;     <span class="hljs-comment">//还原</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>dfs(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OS-lab1</title>
    <link href="/2023/03/20/OSlab1/"/>
    <url>/2023/03/20/OSlab1/</url>
    
    <content type="html"><![CDATA[<hr><h1>上机</h1><h2 id="1-lab1-exam：">1.lab1-exam：</h2><p>​      在lab1课下分支的基础上，扩展printk函数，增加新的格式字符串&quot;%[flags] [width] [length]R&quot;,从参数表中得到两个参数，两个参数当做“%[flags] [width] [length]d”输出，具体输出形式为&quot;(参数1,参数2)“。例如printk(”%4R&quot;, 2023, 2023); 输出为&quot;(2023,2023)&quot;。只需要switch代码段增加一个case即可，类似两个case：d。<strong>记着输出完第一个参数，要把neg_flag归0。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br>        <span class="hljs-keyword">if</span>(long_flag) &#123;<br>                               num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);          \\第一个参数<br>       nun = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);                      \\第二个参数，记得声明 <span class="hljs-type">long</span> nun<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>                               num = va_arg(ap, <span class="hljs-type">int</span>);<br>       nun = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>                        <span class="hljs-keyword">if</span>(num &lt;<span class="hljs-number">0</span>)&#123;<br>                                 num = -num;<br> neg_flag = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">char</span> kuo1[] = <span class="hljs-string">&quot;(\0&quot;</span>;<br><span class="hljs-type">char</span> kuo2[] = <span class="hljs-string">&quot;)\0&quot;</span>;<br><span class="hljs-type">char</span> dou[] = <span class="hljs-string">&quot;,\0&quot;</span>;<br>                        out(data, kuo1, <span class="hljs-number">1</span>);        <br>print_num(out, data, num, <span class="hljs-number">10</span>, neg_flag,width,ladjust,padc,<span class="hljs-number">0</span>);<br>out(data, dou, <span class="hljs-number">1</span>);<br>neg_flag = <span class="hljs-number">0</span>;            <span class="hljs-comment">//输出完第一个参数，记得初始neg_flag</span><br><span class="hljs-keyword">if</span>(nun &lt;<span class="hljs-number">0</span>)&#123;<br>                              nun = -nun;<br>      neg_flag = <span class="hljs-number">1</span>;<br>&#125;<br>print_num(out, data, nun, <span class="hljs-number">10</span>, neg_flag,width,ladjust,padc,<span class="hljs-number">0</span>);<br>out(data, kuo2, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><h2 id="2-la1-extra">2.la1-extra</h2><p>​         我们在lab1课下实现的printk是把格式字符串输出到终端，extra的目标是实现sprintf函数，把要输出的内容弄到缓冲区（就是到目标字符串buf），printk的原理为：调用vptintfmt解析fmt，真正的输出是把outputk函数（在vprintfmt传入output函数作为一个参数）。注意到vprintfmt第二个参数为NULL，在声明的时候第二个形参为void * data。第一个参数函数称为回调函数，第二个参数称为回调上下文，在printk并没有用到data。我们可以借助vprintfmt函数，第一个参数传入自定义的函数，第二个参数传入buf（当前缓冲区所在的位置）。我们要实现的自定义函数就是类似的outputk，只不过功能不是输出，而是把写入到当前缓冲区的位置，这时候你突然发现当前文件下memcpy函数已经实现了！！！为了可以一直更新data，我们只需要在所有需要缓冲的地方让data加上缓冲的字符串长度。还有一个小问题是，由于在vprintfmt函数中还调用了print_str, print_char, print_num在这三个函数中，为了把更新后的data传回vprintfmt，我把这三个函数的类型改为void*，然后返回值为更新后的data。<strong>需要注意在vprintfmt对data更新的时候，要先判断data是不是NULL，因为printk也会调用vprintfmt，但传入的data为NULL。其实要写的东西不多，仔细一点就好</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * fmt, ...)</span>&#123;<br>     <span class="hljs-type">void</span> *start = buf;<br>      va_list ap;<br>      va_start(ap, fmt);<br>      vprintfmt(memcpy2, buf, fmt,ap );<br>      va_end(ap);<br>      <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <br>     <span class="hljs-keyword">while</span>(*(<span class="hljs-type">char</span> *)start!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;        <br>           i++;<br>   start++;<br>     &#125;<br> <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n)</span> &#123;<br><span class="hljs-type">void</span> *dstaddr = dst;<br><span class="hljs-type">void</span> *max = dst + n;<br><br><span class="hljs-keyword">if</span> (((u_long)src &amp; <span class="hljs-number">3</span>) != ((u_long)dst &amp; <span class="hljs-number">3</span>)) &#123;<br><span class="hljs-keyword">while</span> (dst &lt; max) &#123;<br>*(<span class="hljs-type">char</span> *)dst++ = *(<span class="hljs-type">char</span> *)src++;<br>&#125;<br><span class="hljs-keyword">return</span> dstaddr;<br>&#125;<br><br><span class="hljs-keyword">while</span> (((u_long)dst &amp; <span class="hljs-number">3</span>) &amp;&amp; dst &lt; max) &#123;<br>*(<span class="hljs-type">char</span> *)dst++ = *(<span class="hljs-type">char</span> *)src++;<br>&#125;<br><br><span class="hljs-comment">// copy machine words while possible</span><br><span class="hljs-keyword">while</span> (dst + <span class="hljs-number">4</span> &lt;= max) &#123;<br>*(<span class="hljs-type">uint32_t</span> *)dst = *(<span class="hljs-type">uint32_t</span> *)src;<br>dst += <span class="hljs-number">4</span>;<br>src += <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-comment">// finish the remaining 0-3 bytes</span><br><span class="hljs-keyword">while</span> (dst &lt; max) &#123;<br>*(<span class="hljs-type">char</span> *)dst++ = *(<span class="hljs-type">char</span> *)src++;<br>&#125;<br><span class="hljs-keyword">return</span> dstaddr;<br>&#125;<br><br><br><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vprintfmt</span><span class="hljs-params">(<span class="hljs-type">fmt_callback_t</span> out, <span class="hljs-type">void</span> *data, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, va_list ap)</span> &#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *s;<br><span class="hljs-type">long</span> num;<br><br><span class="hljs-type">int</span> width;<br><span class="hljs-type">int</span> long_flag; <span class="hljs-comment">// output is long (rather than int)</span><br><span class="hljs-type">int</span> neg_flag;  <span class="hljs-comment">// output is negative</span><br><span class="hljs-type">int</span> ladjust;   <span class="hljs-comment">// output is left-aligned</span><br><span class="hljs-type">char</span> padc;     <span class="hljs-comment">// padding char</span><br><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-comment">/* scan for the next &#x27;%&#x27; */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (1/8) */</span><br>        <span class="hljs-keyword">while</span>(*fmt!=<span class="hljs-string">&#x27;%&#x27;</span>&amp;&amp;*fmt!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>out(data,fmt,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(data!=<span class="hljs-literal">NULL</span>)&#123;<br>data++;<br>&#125;<br>fmt++;<br>&#125;<br><span class="hljs-comment">/* flush the string found so far */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (2/8) */</span><br><br><span class="hljs-comment">/* check &quot;are we hitting the end?&quot; */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (3/8) */</span><br>        <span class="hljs-keyword">if</span>(*fmt == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br><span class="hljs-keyword">if</span>(data!=<span class="hljs-literal">NULL</span>)&#123;<br>                      *(<span class="hljs-type">char</span> *)data = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <br>&#125;<br><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">/* we found a &#x27;%&#x27; */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (4/8) */</span><br>fmt++;<br>ladjust = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(*fmt == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            ladjust = <span class="hljs-number">1</span>;<br>fmt++;<br>&#125;<br><span class="hljs-comment">/* check format flag */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (5/8) */</span><br>padc = <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">if</span> (*fmt == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            padc = <span class="hljs-string">&#x27;0&#x27;</span>;<br>fmt++;<br>&#125;<br><span class="hljs-comment">/* get width */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (6/8) */</span><br>width = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(isDigit(*fmt))&#123;<br>            width *= <span class="hljs-number">10</span>;<br>width += cToD(*fmt);<br>fmt++;<br>&#125;<br><br><span class="hljs-comment">/* check for long */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (7/8) */</span><br>long_flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(*fmt == <span class="hljs-string">&#x27;l&#x27;</span>)&#123;<br>long_flag = <span class="hljs-number">1</span>;<br>fmt++;<br>&#125;<br><br>neg_flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">switch</span> (*fmt) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>            <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">0</span>)&#123;<br>num = -num;<br>neg_flag = <span class="hljs-number">1</span>;<br>&#125;<br>data =print_num(out,data,num,<span class="hljs-number">10</span>,neg_flag,width,ladjust,padc,<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Refer to other parts (case &#x27;b&#x27;, case &#x27;o&#x27;, etc.) and func &#x27;print_num&#x27; to</span><br><span class="hljs-comment"> * complete this part. Think the differences between case &#x27;d&#x27; and the</span><br><span class="hljs-comment"> * others. (hint: &#x27;neg_flag&#x27;).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Exercise 1.4: Your code here. (8/8) */</span><br><br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;O&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;U&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>:<br><span class="hljs-keyword">if</span> (long_flag) &#123;<br>num = va_arg(ap, <span class="hljs-type">long</span> <span class="hljs-type">int</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>num = va_arg(ap, <span class="hljs-type">int</span>);<br>&#125;<br>data =print_num(out, data, num, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>, width, ladjust, padc, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>c = (<span class="hljs-type">char</span>)va_arg(ap, <span class="hljs-type">int</span>);<br>data = print_char(out, data, c, width, ladjust);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>s = (<span class="hljs-type">char</span> *)va_arg(ap, <span class="hljs-type">char</span> *);<br>data =  print_str(out, data, s, width, ladjust);<br><span class="hljs-keyword">break</span>;<br>  <br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\0&#x27;</span>:<br>fmt--;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">/* output this char as it is */</span><br>out(data, fmt, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(data!=<span class="hljs-literal">NULL</span>)&#123;<br>                                data++;<br>&#125;<br>&#125;<br>fmt++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>lab1思考题</h1><hr><h2 id="一、Thinking">一、Thinking</h2><h3 id="thinking1-1">thinking1.1</h3><p>​        x86交叉编译链：解决编译链程序和目标程序运行环境不同的问题，如在x86环境上使用编译工具进行编译汇编链接，而生成的程序需要运行在ARM开发板上</p><p>​         readelf：显示可执行程序的elf文件信息</p><p>​         objdump：显示程序信息，函数汇编等，常用于调试</p><p>​                              objdump -h **.o 可查看目标文件的结构和内容<br>​                              objdump -S      反汇编  -d可以16进制显示</p><p>​         LD（link script）：主要是用来描述输入文件中的节（section）是如何映射到输出文件的，并且控制输出文件的内存布局（memory layout）；源代码会编译成为目标对象文件（object file），每个对象文件中包含一系列的段（section），为LD的输入文件。</p><h3 id="thinking1-2">thinking1.2</h3><img src="/2023/03/20/OSlab1/2.0.png" class><p>发现在编译hello和readelf时的编译选项并不同</p><img src="/2023/03/20/OSlab1/2.1.png" class><img src="/2023/03/20/OSlab1/2.2.png" class><p>1.static：使用自带的readelf工具发现readelf文件类型为 DYN(Position-Independent Executable file),地址独立可执行文件，这是linux的一种保护方式，可以使程序在任意地址装载。hello则为简单的可执行文件，地址固定。</p><p>2.-32m：在我们的环境中，32位的程序运行的速度会更快，加上-32m选项，编译链接生成32位可执行程序，但是我们自己的readelf只能读64位。但是x86自带交叉编译工具readelf则可以读32位。</p><h3 id="thinking1-3">thinking1.3</h3><p>启动分为两过程，硬件启动和软件启动，硬件启动的入口地址是由硬件决定的，之后才是我们内核也即软件启动，将ELF加载到内存中，此时内核入口由我们自定义的链接器决定。两个入口的含义是不一样的。</p><hr><h2 id="二、实验难点">二、实验难点</h2><h3 id="1-理解我们内核镜像的结构">1.理解我们内核镜像的结构</h3><img src="/2023/03/20/OSlab1/3.1.png" class><p>我们的开始是在stage2初始化CPU和内核栈，之后便调到init中的mips_init 函数用于初始化内核，我们在lab1中完成的仅仅是打印</p><h3 id="2-readelf的补充">2.readelf的补充</h3><p>由ELF的文件地址计算节头表的地址时需要用 binary(const void *)如果用ehdr，ehdr + off，得到的是ehdr偏移ehdr大小的地址</p><h3 id="3-源码的阅读">3.源码的阅读</h3><hr><h2 id="三、实验感想">三、实验感想</h2><h4 id="1-我们现在的mos非常简单，操作系统也非常抽象，在之后的实验中，必须要多读源码，在理解的基础上逐步实现我们的mos">1.我们现在的mos非常简单，操作系统也非常抽象，在之后的实验中，必须要多读源码，在理解的基础上逐步实现我们的mos</h4><h4 id="2-对于mos的makefile并不太熟悉，课下要多下功夫，多读源码。实验的整体难度尚可。">2.对于mos的makefile并不太熟悉，课下要多下功夫，多读源码。实验的整体难度尚可。</h4>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>lab1</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-lab0</title>
    <link href="/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<hr><h1>实验报告</h1><h2 id="lab0思考题">lab0思考题</h2><h3 id="thinking0-1">thinking0.1</h3><pre><code class="hljs">不一样，在新建README.txt时候，处于Untracked状态，文件第二行显示&quot;Untracked files&quot;。当add 追踪再修改处于已修改状态,Modified.txt显示&quot;Changes not staged for commit&quot;，此时使用add命令进入Stage区。这两次add的功能并不相同，第一次是追踪，第二次是提交修改。</code></pre><h3 id="thinking0-2">thinking0.2</h3><img src="/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/Git.png" class><pre><code class="hljs">Add the file --&gt; git addStage the file --&gt; git addcommit --&gt; git commit</code></pre><h3 id="thinking0-3">thinking0.3</h3><pre><code class="hljs">1.git checkout -- print.c2.git reset HEAD print.c3.git rm --cached print.c</code></pre><h3 id="thinking0-4">thinking0.4</h3><img src="/2023/03/18/OS-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/thinking0.4.png" class><pre><code class="hljs">3 hashcode:d5b5d0e2008b045060fc390388ed88519e3378572 hashcode:3afeaf4e09d5ebb5a811f24dfd9e8357b47d021b1 hashcode:8e72b92edb7dd5370ab5ce48d270a9a32ebf78aagit reset --hard HEAD^ 显示当前在版本2git reset --hard 8e72b92edb7dd5370ab5ce48d270a9a32ebf78aa显示在版本1git reset --hard d5b5d0e2008b045060fc390388ed88519e337857又返回到版本3</code></pre><h3 id="thinking0-5">thinking0.5</h3><pre><code class="hljs">echo first直接在shell输出firstecho second &gt; output.txt 将second输出到output中，若文件已存在并替换原来的内容echo third &gt; output.txt 同理，output中只有thirdecho forth &gt;&gt; output.txt 将forth写到output原有内容之后，此时文件中显示thirdforth</code></pre><h3 id="thinking0-6">thinking0.6</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>：<br> 1 <span class="hljs-built_in">echo</span> Shell Start<br>  2 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> a = 1<br>  3 a=1<br>  4 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> b = 2<br>  5 b=2<br>  6 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> c = a+b<br>  7 c=$[<span class="hljs-variable">$a</span>+<span class="hljs-variable">$b</span>]<br>  8 <span class="hljs-built_in">echo</span> c = <span class="hljs-variable">$c</span><br>  9 <span class="hljs-built_in">echo</span> save c to ./file1<br> 10 <span class="hljs-built_in">echo</span> <span class="hljs-variable">$c</span>&gt;file1<br> 11 <span class="hljs-built_in">echo</span> save b to ./file2<br> 12 <span class="hljs-built_in">echo</span> <span class="hljs-variable">$b</span>&gt;file2<br> 13 <span class="hljs-built_in">echo</span> save a to ./file3<br> 14 <span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span>&gt;file3<br> 15 <span class="hljs-built_in">echo</span> save file1 file2 file3 to file4<br> 16 <span class="hljs-built_in">cat</span> file1&gt;file4<br> 17 <span class="hljs-built_in">cat</span> file2&gt;&gt;file4<br> 18 <span class="hljs-built_in">cat</span> file3&gt;&gt;file4<br> 19 <span class="hljs-built_in">echo</span> save file4 to ./result<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span>：<br>  1 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> Shell Start &gt; <span class="hljs-built_in">test</span><br>  2 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> a = 1 &gt;&gt; <span class="hljs-built_in">test</span><br>  3 <span class="hljs-built_in">echo</span> a=1 &gt;&gt; <span class="hljs-built_in">test</span><br>  4 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> b = 2 &gt;&gt; <span class="hljs-built_in">test</span><br>  5 <span class="hljs-built_in">echo</span> b=2 &gt;&gt; <span class="hljs-built_in">test</span><br>  6 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> c = a+b &gt;&gt;<span class="hljs-built_in">test</span><br>  7 <span class="hljs-built_in">echo</span> c=<span class="hljs-string">&#x27;$[$a+$b]&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br>  8 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> c = <span class="hljs-string">&#x27;$c&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br>  9 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save c to ./file1 &gt;&gt; <span class="hljs-built_in">test</span><br> 10 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$c&gt;&#x27;</span>file1 &gt;&gt;<span class="hljs-built_in">test</span><br> 11 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save b to ./file2 &gt;&gt; <span class="hljs-built_in">test</span><br> 12 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$b&gt;&#x27;</span>file2 &gt;&gt;<span class="hljs-built_in">test</span><br> 13 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save a to ./file3 &gt;&gt; <span class="hljs-built_in">test</span><br> 14 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$a&gt;&#x27;</span>file3 &gt;&gt;<span class="hljs-built_in">test</span><br> 15 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save file1 file2 file3 to file4 &gt;&gt; <span class="hljs-built_in">test</span><br> 16 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">cat</span> file1<span class="hljs-string">&#x27;&gt;&#x27;</span>file4  &gt;&gt; <span class="hljs-built_in">test</span><br> 17 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">cat</span> file2<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>file4 &gt;&gt; <span class="hljs-built_in">test</span><br> 18 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">cat</span> file3<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>file4 &gt;&gt;<span class="hljs-built_in">test</span><br> 19 <span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save file4 to ./result &gt;&gt;<span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><hr><h2 id="难点分析">难点分析</h2><h3 id="Exercise0-1">Exercise0.1</h3><pre><code class="hljs">sed -n（安静模式）即只输出经过sed修改后的内容</code></pre><h3 id="Exercise0-2">Exercise0.2</h3><pre><code class="hljs">在bash可执行文件中，熟悉文法结构，每一条都是命令，所以if while中的参数也是命令，-ne，-eq等命令，且须注意在关系成立时返回0，与常规语言不同。</code></pre><h3 id="Exercise0-3">Exercise0.3</h3><pre><code class="hljs">使用grep和awk指令结合使用，可以使用创建中间文件然后再删除，也可以使用管道重定向即一行写完：grep -n $2 $1 | awk -F: '&#123;print $1&#125;' &gt; $3</code></pre><h3 id="Exercise0-4">Exercise0.4</h3><pre><code class="hljs">2.1存在一个调用子目录的Makefile：cd  childDir &amp;&amp; $(MAKE)2.2链接操作：gcc code/fibo.o code/main.o -o fibo2.3头文件不在当前目录gcc -c fibo.c -o fibo.o -I ../include 使用-I参数（预处理过程中需要替换#include中文件头）所以在汇编的第一步预处理过程中也是需要fibo.h头文件</code></pre><hr><h2 id="实验体会">实验体会</h2><h3 id="实验的基本要求与目的：">实验的基本要求与目的：</h3><pre><code class="hljs">1.lab0主要是对一些工具使用的熟悉，文本编辑三剑客grep awk sed最基本的功能2.对Git的简单原理和拓展指令熟悉使用3.命令行运用，可执行文件边写</code></pre><h3 id="实验感受">实验感受</h3><pre><code class="hljs">1.使用命令行虽不及图形操作直观方便，但是更加简洁，对git版本控制的理解也会进一步加深，需要在抽象能力与文件管理能力2.对c语言文件一步一步成为可执行文件的理解进一步加深，比如在预处理的时候也是需要头文件的，这是只是声明，在链接的过程中才会定义。3.使用命令行处理文本时也会更加方便简洁，是一个很好使用的工具。4.无论是编程还是都要保证每一个字符每一条命令的正确性。</code></pre>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OO第一单元总结</title>
    <link href="/2023/03/18/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/2023/03/18/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<hr><h1>OO 第一单元总结</h1><hr><p>本文为OO第一单元总结，本单元主要任务是表达式的展开与化简。核心思想是递归下降法，主要分为预处理、解析、多项式生成、化简四个个核心步骤。三次作业增量迭代的要求如下</p><ul><li><p>第一次作业</p><ul><li>去括号<ul><li>一层括号</li></ul></li><li>多项式化简</li></ul></li><li><p>第二次作业</p><ul><li>括号嵌套</li><li>自定义函数<ul><li>无递归定义，有递归调用</li></ul></li><li>新增三角函数因子</li></ul></li><li><p>第三次作业</p><ul><li><p>自定义函数</p><ul><li>递归声明与调用</li></ul></li><li><p>新增求导因子</p><ul><li>仅出现一次</li></ul></li></ul></li></ul><h2 id="一、程序结构">一、程序结构</h2><h3 id="1-类图-第三次作业">1.类图(第三次作业)</h3><pre><code class=" mermaid">classDiagramMain --&gt; StrHandler : preprocess the input by the method&quot;strHandler&quot;Main --&gt; Parser : parse the input by the method&quot;parseExpr&quot;Main --&gt; Poly : print the result by the method&quot;getPrint&quot;StrHandler --&gt; Func : replace the input&#x27;s functions with exprclass Main&#123;      +main()$&#125;class StrHandler&#123;      +strHandler()$ String      +parseFunc()$ String      +funcHandle()$ String      +findBracket()$ int      +remZero()$ String      +noSignNum()$ String      +noBracket()$ boolean      +isNum()$ boolean      +isTurnNeg()$ boolean&#125;class Func &#123;      -String content      -int sum      -HashMap~Integer, String~ parameters      +getSum() int      +funcStruct() coid      +getContent() String&#125;Parser --&gt; Factor : Parse the factor(Expr/Term/Factor)by LexerParser ..&gt; Lexer : contains Poly ..&gt; Mono : containsFactor --&gt; Poly : turn to Poly from Factor by the method &quot;getPoly()&quot;class Poly &#123;      -int sign      -ArrayList~Mono~ monos      +turnNeg() void      +addPoly() void      +addMono() void      +multPoly() Poly      +getPrint() String&#125;class Mono &#123;      -int sign      -BigInteger con      -BigInteger xin      -BigInteger yin      -BigInteger zin      -HashMap~String,BigInteger~ sins      -HashMap~String,BigInteger~ coss      +setMono() void      +clearHash() void      +turnNeg() void      +addSame() void      +mulMono() Mono      +addTris() void      +addSin() void      +addCos() void      +isSame() boolean      +isSameFang() boolean      +getPrint() String      +printTri() String      +compareTo() int            &#125;class Parser&#123;      -Lexer lexer      +parseExpr() Expr      +parseTerm() Term      +parseFac() Factor      +parseDer() Deri      +parseSin() Sin      +parseCos() Cos&#125;Factor &lt;|-- ExprFactor &lt;|-- TermFactor &lt;|-- CosFactor &lt;|-- SinFactor &lt;|-- NumFactor &lt;|-- VarFactor &lt;|-- DeriFactor &lt;|-- Powerclass Factor&#123;      -int sign      +getSign() int      +setSign() void      +getPoly() Poly      +derivation() Poly&#125;class Lexer&#123;      -String input      -int pos      -String curToken      +next() void      +getNum String      +getCurToken() String      &#125;class Expr&#123;      -int sign      -ArrayList~Term~ terms      +addTerm() void      +getPoly() Poly      +derivation() Poly&#125;class Term&#123;  -int sign  -ArrayList~Factor~ factors  +addFac void  +getPoly Poly  +derivation() Poly  &#125;class Power &#123;      -Expr base      -BigInteger index      -Poly basePoly      +getPoly() Poly      +derivation() Poly&#125;class Cos&#123;  -int sign  -Factor parameter  -BigInteger index  -Poly selfPoly  -String paraStr  +setIndex() void  +getPoly() Poly  +derivation() Poly  +setParameter void  &#125;class Sin&#123;  -int sign  -Factor parameter  -BigInteger index  -Poly selfPoly  -String paraStr  +setIndex() void  +getPoly() Poly  +derivation() Poly  +setParameter void  &#125;class Num&#123;      -int sign      -BigInteger value      +getPoly() Poly      +derivation() Poly&#125;class Var&#123;      -String name      +getPoly() Poly      +derivation() Poly&#125;class Deri&#123;      -int sign      -String fac      -Expr expr      +setFac() void      +setExp() void      +getPoly() Poly      +derivation() Poly&#125;</code></pre><h2 id="2-代码结构">2.代码结构</h2><h3 id="2-1代码行数">2.1代码行数</h3><table><thead><tr><th>Source File</th><th>Total   Lines</th><th>Source Code Lines</th><th>Source Code Line[%]</th><th>Comment Lines</th><th>Comment Lines[%]</th><th>Blank Lines</th><th>Blank Lines[%]</th></tr></thead><tbody><tr><td>Factor.java</td><td>22</td><td>17</td><td>0.7727272727272727</td><td>0</td><td>0.0</td><td>5</td><td>0.22727272727272727</td></tr><tr><td>Deri.java</td><td>24</td><td>19</td><td>0.7916666666666666</td><td>0</td><td>0.0</td><td>5</td><td>0.20833333333333334</td></tr><tr><td>Main.java</td><td>28</td><td>27</td><td>0.9642857142857143</td><td>0</td><td>0.0</td><td>1</td><td>0.03571428571428571</td></tr><tr><td>Num.java</td><td>32</td><td>27</td><td>0.84375</td><td>0</td><td>0.0</td><td>5</td><td>0.15625</td></tr><tr><td>Expr.java</td><td>39</td><td>32</td><td>0.8205128205128205</td><td>0</td><td>0.0</td><td>7</td><td>0.1794871794871795</td></tr><tr><td>Var.java</td><td>44</td><td>39</td><td>0.8863636363636364</td><td>0</td><td>0.0</td><td>5</td><td>0.11363636363636363</td></tr><tr><td>Func.java</td><td>45</td><td>41</td><td>0.9111111111111111</td><td>0</td><td>0.0</td><td>4</td><td>0.08888888888888889</td></tr><tr><td>Term.java</td><td>48</td><td>42</td><td>0.875</td><td>0</td><td>0.0</td><td>6</td><td>0.125</td></tr><tr><td>Power.java</td><td>54</td><td>47</td><td>0.8703703703703703</td><td>0</td><td>0.0</td><td>7</td><td>0.12962962962962962</td></tr><tr><td>Lexer.java</td><td>66</td><td>58</td><td>0.8787878787878788</td><td>0</td><td>0.0</td><td>8</td><td>0.12121212121212122</td></tr><tr><td>Poly.java</td><td>77</td><td>69</td><td>0.8961038961038961</td><td>0</td><td>0.0</td><td>8</td><td>0.1038961038961039</td></tr><tr><td>Cos.java</td><td>98</td><td>90</td><td>0.9183673469387755</td><td>0</td><td>0.0</td><td>8</td><td>0.08163265306122448</td></tr><tr><td>Sin.java</td><td>102</td><td>95</td><td>0.9313725490196079</td><td>0</td><td>0.0</td><td>7</td><td>0.06862745098039216</td></tr><tr><td>Parser.java</td><td>151</td><td>140</td><td>0.9271523178807947</td><td>0</td><td>0.0</td><td>11</td><td>0.0728476821192053</td></tr><tr><td>StrHandler.java</td><td>245</td><td>228</td><td>0.9306122448979591</td><td>1</td><td>0.004081632653061225</td><td>16</td><td>0.0653061224489796</td></tr><tr><td>Mono.java</td><td>315</td><td>295</td><td>0.9365079365079365</td><td>0</td><td>0.0</td><td>20</td><td>0.06349206349206349</td></tr></tbody></table><p>###2.2方法</p><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Cos.Cos()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Cos.derivation(String)</td><td>5</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Cos.getIndex()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Cos.getPoly()</td><td>8</td><td>1</td><td>6</td><td>6</td></tr><tr><td>Cos.setIndex(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Cos.setParameter(Factor)</td><td>4</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Deri.derivation(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Deri.getPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Deri.setExp(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Deri.setFac(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.Expr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Expr.addTerm(Term, int)”</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.derivation(String)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Expr.getPoly()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Factor.derivation(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Factor.getPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Factor.getSign()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Factor.setSign(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Func.funcStruct(String, HashMap&lt;String, Func&gt;)”</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Func.getContent(String[])</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Func.getSum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.Lexer(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getCurToken()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getNum()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Lexer.getPos()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.isSign()</td><td>4</td><td>3</td><td>3</td><td>5</td></tr><tr><td>Lexer.next()</td><td>9</td><td>2</td><td>3</td><td>8</td></tr><tr><td>Main.main(String[])</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Mono.Mono()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mono.Mono(Mono)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Mono.addCos(String, BigInteger)”</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Mono.addSame(Mono)</td><td>6</td><td>1</td><td>7</td><td>7</td></tr><tr><td>“Mono.addSin(String, BigInteger)”</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Mono.addTris(Mono)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Mono.clearHash()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mono.compareTo(Mono)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>“Mono.getPrint(int, int)”</td><td>28</td><td>3</td><td>20</td><td>22</td></tr><tr><td>Mono.isFang(Mono)</td><td>34</td><td>9</td><td>15</td><td>15</td></tr><tr><td>Mono.isSame(Mono)</td><td>4</td><td>3</td><td>2</td><td>4</td></tr><tr><td>Mono.isSameFang(Mono)</td><td>2</td><td>2</td><td>1</td><td>2</td></tr><tr><td>Mono.mulMono(Mono)</td><td>8</td><td>1</td><td>7</td><td>7</td></tr><tr><td>Mono.printTri(int)</td><td>47</td><td>1</td><td>17</td><td>17</td></tr><tr><td>“Mono.setMono(BigInteger, BigInteger, BigInteger, BigInteger, int)”</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Mono.turnNeg()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Num.Num(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Num.derivation(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Num.getPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.Parser(Lexer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.paresDer(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.paresSin(int)</td><td>1</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Parser.parseCos(int)</td><td>1</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Parser.parseExpr()</td><td>7</td><td>1</td><td>4</td><td>5</td></tr><tr><td>Parser.parseFac()</td><td>15</td><td>8</td><td>11</td><td>11</td></tr><tr><td>Parser.parseTerm()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Poly.Poly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.addMono(Mono)</td><td>10</td><td>5</td><td>5</td><td>6</td></tr><tr><td>Poly.addPoly(Poly)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Poly.getPrint()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Poly.mulPoly(Poly)</td><td>3</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.turnNeg()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>“Power.Power(Factor, String)”</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Power.derivation(String)</td><td>4</td><td>2</td><td>3</td><td>3</td></tr><tr><td>Power.getPoly()</td><td>2</td><td>2</td><td>2</td><td>3</td></tr><tr><td>Sin.Sin()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Sin.derivation(String)</td><td>5</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Sin.getIndex()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Sin.getPoly()</td><td>8</td><td>1</td><td>6</td><td>6</td></tr><tr><td>Sin.setIndex(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Sin.setParameter(Factor)</td><td>9</td><td>1</td><td>6</td><td>6</td></tr><tr><td>StrHandler.findBracket(String)</td><td>7</td><td>5</td><td>1</td><td>5</td></tr><tr><td>“StrHandler.funcHandle(String, HashMap&lt;String, Func&gt;)”</td><td>5</td><td>1</td><td>3</td><td>5</td></tr><tr><td>StrHandler.isNum(String)</td><td>5</td><td>4</td><td>1</td><td>5</td></tr><tr><td>StrHandler.isTurnNeg(String)</td><td>9</td><td>1</td><td>1</td><td>9</td></tr><tr><td>StrHandler.noBracket(String)</td><td>12</td><td>2</td><td>1</td><td>9</td></tr><tr><td>StrHandler.noSign(String)</td><td>3</td><td>3</td><td>3</td><td>4</td></tr><tr><td>StrHandler.noSignNum(String)</td><td>8</td><td>4</td><td>3</td><td>8</td></tr><tr><td>StrHandler.noZero(String)</td><td>3</td><td>2</td><td>2</td><td>4</td></tr><tr><td>“StrHandler.parseFunc(String, HashMap&lt;String, Func&gt;)”</td><td>12</td><td>1</td><td>5</td><td>7</td></tr><tr><td>StrHandler.strHandler(String)</td><td>17</td><td>1</td><td>4</td><td>8</td></tr><tr><td>“StrHandler.strHandler(String, HashMap&lt;String, Func&gt;)”</td><td>17</td><td>1</td><td>4</td><td>8</td></tr><tr><td>Term.Term()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.addFac(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.derivation(String)</td><td>7</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Term.getPoly()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Var.Var(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Var.derivation(String)</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Var.getPoly()</td><td>3</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Total</td><td>359</td><td>136</td><td>247</td><td>307</td></tr><tr><td>Average</td><td>4.13</td><td>1.56</td><td>2.84</td><td>3.53</td></tr></tbody></table><p>###2.3类</p><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Cos</td><td>2.83</td><td>6</td><td>17</td></tr><tr><td>Deri</td><td>1.00</td><td>1</td><td>4</td></tr><tr><td>Expr</td><td>2.00</td><td>3</td><td>8</td></tr><tr><td>Factor</td><td>1.00</td><td>1</td><td>4</td></tr><tr><td>Func</td><td>2.00</td><td>3</td><td>6</td></tr><tr><td>Lexer</td><td>2.50</td><td>7</td><td>15</td></tr><tr><td>Main</td><td>3.00</td><td>3</td><td>3</td></tr><tr><td>Mono</td><td>4.50</td><td>17</td><td>72</td></tr><tr><td>Num</td><td>1.00</td><td>1</td><td>3</td></tr><tr><td>Parser</td><td>3.00</td><td>9</td><td>21</td></tr><tr><td>Poly</td><td>2.83</td><td>6</td><td>17</td></tr><tr><td>Power</td><td>2.33</td><td>3</td><td>7</td></tr><tr><td>Sin</td><td>3.17</td><td>6</td><td>19</td></tr><tr><td>StrHandler</td><td>5.18</td><td>7</td><td>57</td></tr><tr><td>Term</td><td>2.50</td><td>5</td><td>10</td></tr><tr><td>Var</td><td>2.33</td><td>4</td><td>7</td></tr><tr><td>Total</td><td></td><td></td><td>270</td></tr><tr><td>Average</td><td>3.10</td><td>5.12</td><td>16.88</td></tr></tbody></table><h2 id="二、核心架构">二、核心架构</h2><h3 id="1-表达式">1.表达式</h3><pre><code class=" mermaid">graph TBExpr --&gt; Term_1Expr --&gt; Term_2Expr --&gt; Term_nTerm_1 --&gt; Factor_1Term_1 --&gt; Factor_2Term_1 --&gt; Factor_3Term_1 --&gt; Factor_4Term_1 --&gt; Factor_5Term_1 --&gt; Factor_6Term_1 --&gt; Factor_7Factor_2 --&gt; p_exprFactor_2 --&gt; p_numFactor_3 --&gt; d_exprFactor_3 --&gt; d_varFactor_4 --&gt; s_facFactor_4 --&gt; s_indexFactor_5 --&gt; c_facFactor_5 --&gt; c_indexExpr((Expr))Term_1((Term_1))Term_2((Term_2))Term_n((Term_n))Factor_1((Expr))Factor_2((Power))Factor_3((Deri))Factor_4((Sin))Factor_5((Cos))Factor_6((Var))Factor_7((Num))p_expr((Expr))p_num((index))d_expr((Expr))d_var((var))s_fac((Factor))s_index((index))c_fac((Factor))c_index((index))</code></pre><h3 id="2-多项式">2.多项式</h3><pre><code class=" mermaid">graph LRExpr((Expr))Term1((Term_1))Term2((Term_2))Termn((Term_n))Factor1((Factor_1))Factor2((Factor_2))Factorn((Factor_n))Expr --&gt; Term1Expr --&gt; Term2Expr --&gt; TermnTerm1 --&gt; Factor1Term1 --&gt; Factor2Term1 --&gt; FactornFactor1 --getPoly--&gt; fp1((Poly1))Factor2 --getPoly--&gt; fp2((Poly2))Factorn --getPoly--&gt; fpn((Polyn))tp1((newPoly1))tp2((newPoly2))tpn((newPolyn))fp1 --multPoly--&gt; tp1fp2 --multPoly--&gt; tp1fpn --multPoly--&gt; tp1Term2 --Factors getPoly multPoly--&gt;tp2Termn --Factors getPoly multPoly--&gt;tpnep1((resultPoly))tp1 --&gt; ep1tp2 --&gt; ep1tpn --&gt; ep1</code></pre><h3 id="3-数学公式">3.数学公式</h3><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>P</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><mi>f</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>P</mi><mi>o</mi><mi>l</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">resultPoly = \sum_{i=0}^n \prod_{j=0}^m factorPoly</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">res</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.13889em;">ltP</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0652em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span></p><h3 id="4-架构设计体验">4.架构设计体验</h3><h4 id="第一次作业">第一次作业</h4><pre><code class="hljs">    第一次作业比较简单，但由于考虑到之后的迭代开发，还是选择了递归下降，此时的代码可以处理括号嵌套的表达式。预处理包括：去除多余的正负号仅保留必要的符号、去除空白符和制表符、将**替换为^；词法语法解析的整体思路参考了练习作业提供的代码；化简在计算的过程中进行，Mono的标准形式为 Mono = ax^i^y^j^z^k^，在单项式计算的时候采用深克隆</code></pre><h4 id="第二次作业">第二次作业</h4><pre><code class="hljs">     第二次迭代增加了括号嵌套、自定义函数、三角函数因子。递归下降已经解决括号嵌套；对于自定义函数将其放到预处理中，也用递归下降先对自定义函数进行表达式化简，之后替换；在Mono中添加两个HashMap&lt;String, index&gt;分别记录三角函数的参数与指数，Mono的标准形式变为：$Mono = ax^i^y^j^z^k^ \prod^&#123;i=0&#125; sin \prod^&#123;i=0&#125; cos$。判断同列项（除了常数）去掉常数项后的字符串比较，为了保证sin（x+y）和sin（y+x）能够化简，在Poly的getPrint方法中，需要先对mono实现comparable接口重写比较方法。</code></pre><h4 id="第三次作业">第三次作业</h4><pre><code class="hljs">     第三次迭代增加了自定义函数的递归调用、求导因子。自定义函数只需要在预处理的过程中像处理第二次表达式的方式处理即可；求导因子我们就当做新加因子，在表达式getPoly的时候处理，利用求导法则分别写出Expr、Term、其他因子的求导方法即可。    由于第二次优化没有做多少，所以第三次最主要是两个优化，sin（y-x）+sin（x-y）和sin^2^+cos^2^。第一个比较好做，只需要在打印三角函数参数的时候依据正负号的数量和字符串比较来实现；第二个优化类似同列项判断，在Mono相加的时候遍历两个三角函数HashMap，判断另一个Mono中去掉相应的项之后的是否为同类项。此时便会出现新情况，例如：sin(x)*cos(x)+sin(x)^3^*cos(x)+cos(x)^3^*sin(x) 化简时出现新的同类项，对此我的做法是递归化简（乱起的名），以上述为例，先将后两项相加得到Mono：sin(x)*cos(x)，之后在Poly中删除刚刚化简得到的Mono，再将该Mono加入Poly中，发现同类项合并得到2*sin(x)*cos(x), 重复上述过程，删除2*sin(x)*cos(x)，再加到Poly中发现没有同类项，到此合并完成。</code></pre><h3 id="5-架构的优缺点">5.架构的优缺点</h3><ul><li><p>优点</p><ul><li>求导因子，在求导因子生成多项式的时候再处理，可以复用之前的Poly相乘和相加的方法，且不会涉及深浅克隆问题</li><li>三角函数存储方式为String，这样优点很明显，比如仅需要调用一次内层因子的打印函数</li><li>边计算边化简，递归化简会比单独写一个化简函数方便，也更符合程序的流程</li><li>可以处理求导因子的嵌套</li></ul></li><li><p>缺点</p><ul><li>对于自定义函数应该也当做因子处理，在解析的过程中替换，而不是在预处理中替换</li><li>由于父类Factor拥有属性sign，但是在解析中真正有正负的只有Num和Term，其他的都默认为符号为1。在我的架构中埋下了隐患，这会在下面谈到</li></ul></li></ul><h3 id="三、Bug">三、Bug</h3><ul><li>第一次<ul><li>互测竟然没有挨刀，在系数为1的时候，特判条件太多，造成漏洞，1 * y * z输出yz</li><li>0-x+x没有输出，这是因为-x+x合并完之后产生新的同类项，但是这个在互测和强测都没有测出来，自己也没注意到</li></ul></li><li>第二次<ul><li>1-x+x，哎，第一次作业埋的雷</li><li>sin(0) ** 0=0  在判断的时候先判断了sin参数是否为0</li><li>x**21 输出为x* * x1  直接对Mono输出的字符串直接进行替换</li></ul></li><li>第三次<ul><li>dx(sin((-x))) 输出cos(x)  承接上文我的架构，由于我的sin因子里有Factor属性，Poly属性（Factor生成），在提负号到外面的时候只改变了Poly的符号（将所有Mono变号），但是没有把Factor变号。就算变号，由于（-x）是表达式因子，而在我的架构中表达式默认符号为正</li></ul></li><li>总结出现的bug<ul><li>if特判条件，能否把所有的情况都考虑到，是否会漏到一些情况，应该优点判断那些情况</li><li>直接对字符串处理是一件愚蠢至极的方法</li><li>迭代产生的bug，大多数都是复用之前的方法导致错误</li></ul></li></ul><h2 id="四、Hack策略">四、Hack策略</h2><p>列举一些hack成功的例子</p><ul><li><p>边界条件</p><ul><li><p>sin((-x)) --&gt; sin(-x)</p></li><li><pre><code class="hljs">1f(x)=cos(cos(cos(cos(x))))sin(sin(cos(cos(cos(cos(cos(cos(dx(f(x)))))))))) --&gt; TLE                 利用cost条件实现TLE<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br><span class="hljs-comment">*  求导因子出现的位置，对特殊的因子求导</span><br><br><span class="hljs-comment">  * ```</span><br>    1<br>    <span class="hljs-built_in">f</span>(x,y) = ((+x))**2+y<br>    -dx(<span class="hljs-built_in">f</span>(y,0))+y<br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="hljs">2f(x,y,z)=x-(y+z)g(x,z,y)=-dz((y-z)**2)-(f(0,-1,+1)-g(x**+0,x**+2,x**01))<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><br>* ```<br>  <span class="hljs-number">2</span><br>  <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-variable">x</span>) = <span class="hljs-title">sin</span>(<span class="hljs-title">cos</span>(<span class="hljs-variable">x</span>))</span><br>  <span class="hljs-function"><span class="hljs-title">g</span>(<span class="hljs-variable">y</span> ) = <span class="hljs-title">dy</span>(<span class="hljs-title">f</span>(<span class="hljs-variable">y</span>))</span><br>  <span class="hljs-function"><span class="hljs-title">g</span>(<span class="hljs-variable">y</span>)</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h2 id="五、心得体会">五、心得体会</h2><pre><code class="hljs">  在第一次和第二次我几乎都没怎么做测试，第三次测试也只是把第二次数据改了改添加了求导因子，然后和室友python对拍，结果就是三次作业都有bug，下周说什么也得把评测机写出来。在写代码的时候尽量保证程序正义性，再结合随机测试数据和评测机才是正道！！   复用之前的方法很容易出bug，接口的实现尤为重要，对于每个方法都需要清楚知道输入限制及方法的作用，迭代之后是否还能接着用。慢工出细活，写OO还是得抽出连续大量的时间，且要长时间专注。递归下降确实好用，但就是感觉缺少了一点面向对象的思想，第一单元感觉就像是数据结构哈哈哈哈。感觉评测没有上学期的OOpre覆盖性强，一个点就好几千上万条数据，bug还得靠互测。</code></pre><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OO</tag>
      
      <tag>总结</tag>
      
      <tag>递归下降</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
